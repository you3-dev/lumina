<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magnetic Slider - Lumina</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 25%, #0d1b2a 50%, #1b0a28 75%, #0a0a1a 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            padding: 10px;
            overflow: hidden;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .header {
            text-align: center;
            margin-bottom: 10px;
        }
        .title {
            font-size: 20px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            letter-spacing: 3px;
        }
        .back-link {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #88ccff;
            text-decoration: none;
            font-size: 14px;
            padding: 8px 12px;
            border: 1px solid #88ccff;
            border-radius: 6px;
            transition: all 0.3s;
            z-index: 100;
        }
        .back-link:hover {
            background: rgba(136, 204, 255, 0.2);
        }
        .info-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .info-item {
            padding: 6px 14px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        .info-item span {
            color: #ffcc00;
            font-weight: bold;
        }
        .stage-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .stage-btn {
            padding: 8px 16px;
            font-size: 13px;
            border: 2px solid #88ccff;
            border-radius: 8px;
            background: rgba(136, 204, 255, 0.1);
            color: #88ccff;
            cursor: pointer;
            transition: all 0.3s;
        }
        .stage-btn:hover {
            background: rgba(136, 204, 255, 0.3);
        }
        .stage-btn.active {
            background: rgba(136, 204, 255, 0.4);
            box-shadow: 0 0 15px rgba(136, 204, 255, 0.5);
        }
        #game-container {
            position: relative;
        }
        #game-board {
            display: grid;
            gap: 4px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            touch-action: none;
        }
        .cell {
            width: 70px;
            height: 70px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background 0.2s;
        }
        .cell.goal {
            background: rgba(255, 200, 0, 0.3);
            border: 3px dashed #ffcc00;
            animation: goalPulse 1.5s infinite;
        }
        @keyframes goalPulse {
            0%, 100% { box-shadow: inset 0 0 15px rgba(255, 200, 0, 0.3); }
            50% { box-shadow: inset 0 0 25px rgba(255, 200, 0, 0.6); }
        }
        .piece {
            width: 58px;
            height: 58px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            user-select: none;
            position: relative;
        }
        .piece:hover {
            transform: scale(1.05);
        }
        .piece.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            z-index: 10;
        }
        .piece.n-pole {
            background: linear-gradient(135deg, #ff4444 0%, #cc2222 100%);
            border: 3px solid #ff6666;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .piece.s-pole {
            background: linear-gradient(135deg, #4488ff 0%, #2266cc 100%);
            border: 3px solid #66aaff;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .piece.neutral {
            background: linear-gradient(135deg, #888888 0%, #555555 100%);
            border: 3px solid #aaaaaa;
            color: #ddd;
        }
        .piece.target {
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.8);
        }
        .piece.target::after {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background: #ffcc00;
            border-radius: 50%;
            border: 2px solid #fff;
        }
        .move-hint {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            animation: hintPulse 0.8s infinite;
        }
        @keyframes hintPulse {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .btn {
            padding: 10px 20px;
            font-size: 14px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        .btn-reset {
            background: rgba(255, 100, 100, 0.2);
            border-color: #ff6666;
            color: #ff6666;
        }
        .btn-reset:hover {
            background: rgba(255, 100, 100, 0.4);
        }
        .btn-undo {
            background: rgba(255, 200, 100, 0.2);
            border-color: #ffcc66;
            color: #ffcc66;
        }
        .btn-undo:hover {
            background: rgba(255, 200, 100, 0.4);
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 12px;
            color: #aaa;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .legend-symbol {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        .legend-symbol.n { background: #ff4444; color: #fff; }
        .legend-symbol.s { background: #4488ff; color: #fff; }
        .legend-symbol.neu { background: #888; color: #ddd; }
        #clear-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #clear-popup.show {
            display: flex;
        }
        .clear-content {
            text-align: center;
            animation: popIn 0.5s ease;
        }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .clear-text {
            font-size: 48px;
            font-weight: bold;
            color: #00ffcc;
            text-shadow: 0 0 30px #00ffcc;
            margin-bottom: 15px;
        }
        .clear-moves {
            font-size: 24px;
            color: #ffcc00;
            margin-bottom: 25px;
        }
        .clear-btn {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(0, 255, 204, 0.2);
            border: 2px solid #00ffcc;
            color: #00ffcc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0 10px;
        }
        .clear-btn:hover {
            background: rgba(0, 255, 204, 0.4);
        }
        .magnetic-effect {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            animation: magneticFade 0.5s forwards;
            z-index: 100;
        }
        @keyframes magneticFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5) translateY(-20px); }
        }
        @media (max-width: 400px) {
            .cell {
                width: 60px;
                height: 60px;
            }
            .piece {
                width: 50px;
                height: 50px;
                font-size: 26px;
            }
            .title {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <div class="header">
        <h1 class="title">MAGNETIC SLIDER</h1>
    </div>

    <div class="info-bar">
        <div class="info-item">手数: <span id="move-count">0</span></div>
        <div class="info-item">ベスト: <span id="best-count">-</span></div>
    </div>

    <div class="stage-select">
        <button class="stage-btn active" data-stage="1">Easy</button>
        <button class="stage-btn" data-stage="2">Normal</button>
        <button class="stage-btn" data-stage="3">Hard</button>
    </div>

    <div id="game-container">
        <div id="game-board"></div>
    </div>

    <div class="buttons">
        <button class="btn btn-undo" id="undo-btn">UNDO</button>
        <button class="btn btn-reset" id="reset-btn">RESET</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-symbol n">+</div>
            <span>N極 (引き寄せ: S)</span>
        </div>
        <div class="legend-item">
            <div class="legend-symbol s">−</div>
            <span>S極 (引き寄せ: N)</span>
        </div>
        <div class="legend-item">
            <div class="legend-symbol neu">○</div>
            <span>無極</span>
        </div>
    </div>

    <div id="clear-popup">
        <div class="clear-content">
            <div class="clear-text">CLEAR!</div>
            <div class="clear-moves" id="clear-moves">10手でクリア！</div>
            <button class="clear-btn" id="retry-btn">もう一度</button>
            <button class="clear-btn" id="next-btn">次のステージ</button>
        </div>
    </div>

    <script>
        // ============================================
        // 定数
        // ============================================
        const POLE_N = 'N';     // N極（赤/+）
        const POLE_S = 'S';     // S極（青/-）
        const POLE_NONE = null; // 無極（灰色）

        const DIRECTIONS = [
            { dx: 0, dy: -1, name: 'up' },
            { dx: 0, dy: 1, name: 'down' },
            { dx: -1, dy: 0, name: 'left' },
            { dx: 1, dy: 0, name: 'right' }
        ];

        // ============================================
        // ステージ定義
        // ============================================
        const STAGES = [
            // Easy: 4x4, シンプルな配置
            {
                name: 'Easy',
                gridSize: 4,
                goal: { x: 3, y: 3 },
                pieces: [
                    { x: 0, y: 0, pole: POLE_N, isTarget: true },
                    { x: 2, y: 1, pole: POLE_S, isTarget: false },
                    { x: 1, y: 2, pole: POLE_N, isTarget: false }
                ]
            },
            // Normal: 4x4, より複雑
            {
                name: 'Normal',
                gridSize: 4,
                goal: { x: 3, y: 0 },
                pieces: [
                    { x: 0, y: 3, pole: POLE_S, isTarget: true },
                    { x: 1, y: 1, pole: POLE_N, isTarget: false },
                    { x: 2, y: 2, pole: POLE_S, isTarget: false },
                    { x: 3, y: 2, pole: POLE_NONE, isTarget: false },
                    { x: 0, y: 1, pole: POLE_N, isTarget: false }
                ]
            },
            // Hard: 5x5, 本格的なパズル
            {
                name: 'Hard',
                gridSize: 5,
                goal: { x: 4, y: 4 },
                pieces: [
                    { x: 0, y: 0, pole: POLE_N, isTarget: true },
                    { x: 2, y: 0, pole: POLE_S, isTarget: false },
                    { x: 4, y: 1, pole: POLE_N, isTarget: false },
                    { x: 1, y: 2, pole: POLE_S, isTarget: false },
                    { x: 3, y: 2, pole: POLE_N, isTarget: false },
                    { x: 0, y: 3, pole: POLE_NONE, isTarget: false },
                    { x: 2, y: 4, pole: POLE_S, isTarget: false }
                ]
            }
        ];

        // ============================================
        // ゲーム状態
        // ============================================
        let currentStage = 0;
        let gridSize = 4;
        let grid = [];
        let pieces = [];
        let goalPos = { x: 0, y: 0 };
        let selectedPiece = null;
        let moveCount = 0;
        let moveHistory = [];
        let bestScores = {};

        // DOM要素
        const boardEl = document.getElementById('game-board');
        const moveCountEl = document.getElementById('move-count');
        const bestCountEl = document.getElementById('best-count');
        const clearPopup = document.getElementById('clear-popup');
        const clearMovesEl = document.getElementById('clear-moves');

        // ============================================
        // 初期化
        // ============================================
        function init() {
            loadBestScores();
            setupEventListeners();
            loadStage(currentStage);
        }

        function setupEventListeners() {
            document.querySelectorAll('.stage-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const stage = parseInt(btn.dataset.stage) - 1;
                    selectStage(stage);
                });
            });

            document.getElementById('reset-btn').addEventListener('click', resetStage);
            document.getElementById('undo-btn').addEventListener('click', undoMove);
            document.getElementById('retry-btn').addEventListener('click', () => {
                clearPopup.classList.remove('show');
                resetStage();
            });
            document.getElementById('next-btn').addEventListener('click', () => {
                clearPopup.classList.remove('show');
                selectStage((currentStage + 1) % STAGES.length);
            });
        }

        function selectStage(stageIndex) {
            currentStage = stageIndex;
            document.querySelectorAll('.stage-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === stageIndex);
            });
            loadStage(stageIndex);
        }

        function loadStage(stageIndex) {
            const stage = STAGES[stageIndex];
            gridSize = stage.gridSize;
            goalPos = { ...stage.goal };
            pieces = stage.pieces.map(p => ({ ...p }));
            moveCount = 0;
            moveHistory = [];
            selectedPiece = null;

            updateMoveCount();
            updateBestDisplay();
            createBoard();
            render();
        }

        function resetStage() {
            loadStage(currentStage);
        }

        // ============================================
        // ボード作成
        // ============================================
        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    if (x === goalPos.x && y === goalPos.y) {
                        cell.classList.add('goal');
                    }

                    cell.addEventListener('click', () => handleCellClick(x, y));
                    cell.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleCellClick(x, y);
                    }, { passive: false });

                    boardEl.appendChild(cell);
                    grid[y][x] = cell;
                }
            }
        }

        // ============================================
        // 描画
        // ============================================
        function render() {
            // 全ピースをクリア
            document.querySelectorAll('.piece').forEach(p => p.remove());
            document.querySelectorAll('.move-hint').forEach(h => h.remove());

            // ピースを配置
            for (const piece of pieces) {
                const cell = grid[piece.y][piece.x];
                const pieceEl = document.createElement('div');
                pieceEl.className = 'piece';

                if (piece.pole === POLE_N) {
                    pieceEl.classList.add('n-pole');
                    pieceEl.textContent = '+';
                } else if (piece.pole === POLE_S) {
                    pieceEl.classList.add('s-pole');
                    pieceEl.textContent = '−';
                } else {
                    pieceEl.classList.add('neutral');
                    pieceEl.textContent = '○';
                }

                if (piece.isTarget) {
                    pieceEl.classList.add('target');
                }

                if (selectedPiece === piece) {
                    pieceEl.classList.add('selected');
                }

                cell.appendChild(pieceEl);
            }

            // 選択中の移動可能方向を表示
            if (selectedPiece) {
                showMoveHints(selectedPiece);
            }
        }

        function showMoveHints(piece) {
            for (const dir of DIRECTIONS) {
                const nx = piece.x + dir.dx;
                const ny = piece.y + dir.dy;

                if (isValidMove(piece, nx, ny)) {
                    const cell = grid[ny][nx];
                    const hint = document.createElement('div');
                    hint.className = 'move-hint';
                    cell.appendChild(hint);
                }
            }
        }

        // ============================================
        // ゲームロジック
        // ============================================
        function handleCellClick(x, y) {
            const clickedPiece = getPieceAt(x, y);

            if (selectedPiece) {
                // 移動を試みる
                if (isValidMove(selectedPiece, x, y)) {
                    executeMove(selectedPiece, x, y);
                } else if (clickedPiece && clickedPiece !== selectedPiece) {
                    // 別のピースを選択
                    selectedPiece = clickedPiece;
                    render();
                } else {
                    // 選択解除
                    selectedPiece = null;
                    render();
                }
            } else if (clickedPiece) {
                // ピースを選択
                selectedPiece = clickedPiece;
                render();
            }
        }

        function getPieceAt(x, y) {
            return pieces.find(p => p.x === x && p.y === y);
        }

        function isValidMove(piece, nx, ny) {
            // 範囲チェック
            if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) {
                return false;
            }

            // 隣接チェック
            const dx = nx - piece.x;
            const dy = ny - piece.y;
            if (Math.abs(dx) + Math.abs(dy) !== 1) {
                return false;
            }

            // 移動先にピースがないか
            if (getPieceAt(nx, ny)) {
                return false;
            }

            return true;
        }

        function executeMove(piece, nx, ny) {
            // 移動前の状態を保存
            const beforeState = pieces.map(p => ({ ...p }));

            // ピースを移動
            piece.x = nx;
            piece.y = ny;

            // 磁力効果を適用
            applyMagneticEffects(piece, nx, ny);

            // 移動履歴を保存
            moveHistory.push(beforeState);
            moveCount++;
            updateMoveCount();

            selectedPiece = null;
            render();

            // クリア判定
            checkClear();
        }

        function applyMagneticEffects(movedPiece, toX, toY) {
            if (movedPiece.pole === POLE_NONE) return;

            // 移動先の隣接マスをチェック
            for (const dir of DIRECTIONS) {
                const adjX = toX + dir.dx;
                const adjY = toY + dir.dy;

                const adjPiece = getPieceAt(adjX, adjY);
                if (!adjPiece || adjPiece.pole === POLE_NONE) continue;

                // 異なる極: 引き寄せ（movedPieceに向かって1マス移動）
                if (isOpposite(movedPiece.pole, adjPiece.pole)) {
                    // adjPieceをmovedPieceの方向に引き寄せ
                    // ただし、移動先がmovedPieceの位置なので実際には動けない
                    // 代わりに、adjPieceの反対側から引き寄せるか確認
                    // この実装では「隣接した異極は吸い寄せられて一緒に移動」
                    // → movedPieceが移動した後の位置に向かってadjPieceを1マス近づける
                    const pullX = adjX - dir.dx;
                    const pullY = adjY - dir.dy;

                    // movedPieceの位置には移動できないので、効果なし
                    // ただし、movedPieceが移動する「前」の位置が空いていれば、そこに引き寄せる
                    // この実装: 引き寄せは「movedPieceの元の位置」への移動
                    // 仕様を再解釈: 異極が隣接したら、そのピースはmovedPieceの元の位置に吸い寄せられる

                    // 実装方針: 移動後にadjPieceがmovedPieceの隣にある場合、
                    // movedPieceの移動元（今は空）にadjPieceを引き寄せる
                    // → これは少し複雑なので、シンプルに「異極が隣接 → 隣接ピースがこちら側に1マス移動」
                    // pullX, pullYはmovedPieceの位置なので移動不可
                    // 別アプローチ: 引き寄せは後続の手で自然に発生する動きとして表現

                    // 最終実装: 引き寄せ効果 = adjPieceをmovedPieceの「手前」に移動
                    // 移動方向の反対側が空いていれば、そこに引き寄せ
                    showMagneticEffect(adjX, adjY, '♥');
                }
                // 同じ極: 反発（押し出し）
                else if (isSame(movedPiece.pole, adjPiece.pole)) {
                    // adjPieceを反対方向に押し出す
                    const pushX = adjX + dir.dx;
                    const pushY = adjY + dir.dy;

                    if (pushX >= 0 && pushX < gridSize &&
                        pushY >= 0 && pushY < gridSize &&
                        !getPieceAt(pushX, pushY)) {
                        adjPiece.x = pushX;
                        adjPiece.y = pushY;
                        showMagneticEffect(adjX, adjY, '⚡');
                    }
                }
            }
        }

        function isOpposite(pole1, pole2) {
            return (pole1 === POLE_N && pole2 === POLE_S) ||
                   (pole1 === POLE_S && pole2 === POLE_N);
        }

        function isSame(pole1, pole2) {
            return pole1 === pole2 && pole1 !== POLE_NONE;
        }

        function showMagneticEffect(x, y, symbol) {
            const cell = grid[y][x];
            const effect = document.createElement('div');
            effect.className = 'magnetic-effect';
            effect.textContent = symbol;
            effect.style.left = '50%';
            effect.style.top = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            cell.appendChild(effect);
            setTimeout(() => effect.remove(), 500);
        }

        // ============================================
        // Undo機能
        // ============================================
        function undoMove() {
            if (moveHistory.length === 0) return;

            pieces = moveHistory.pop();
            moveCount--;
            updateMoveCount();
            selectedPiece = null;
            render();
        }

        // ============================================
        // クリア判定
        // ============================================
        function checkClear() {
            const targetPiece = pieces.find(p => p.isTarget);
            if (targetPiece.x === goalPos.x && targetPiece.y === goalPos.y) {
                // クリア！
                setTimeout(() => {
                    showClearPopup();
                    saveBestScore();
                }, 300);
            }
        }

        function showClearPopup() {
            clearMovesEl.textContent = `${moveCount}手でクリア！`;
            clearPopup.classList.add('show');
        }

        // ============================================
        // スコア管理
        // ============================================
        function updateMoveCount() {
            moveCountEl.textContent = moveCount;
        }

        function updateBestDisplay() {
            const best = bestScores[currentStage];
            bestCountEl.textContent = best !== undefined ? best : '-';
        }

        function loadBestScores() {
            try {
                const saved = localStorage.getItem('magnetic_slider_best');
                if (saved) {
                    bestScores = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Failed to load best scores:', e);
            }
        }

        function saveBestScore() {
            const current = bestScores[currentStage];
            if (current === undefined || moveCount < current) {
                bestScores[currentStage] = moveCount;
                try {
                    localStorage.setItem('magnetic_slider_best', JSON.stringify(bestScores));
                } catch (e) {
                    console.warn('Failed to save best score:', e);
                }
                updateBestDisplay();
            }
        }

        // ============================================
        // 開始
        // ============================================
        init();
    </script>
</body>
</html>
