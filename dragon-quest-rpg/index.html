<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ‰ãƒ©ã‚¯ã‚¨é¢¨RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -ms-touch-action: manipulation;
        }

        body {
            background: #000;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', 'Yu Gothic', sans-serif;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #fadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.3s ease-in-out;
        }

        #fadeOverlay.active {
            opacity: 1;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #mapNameArea {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 12px;
            border-radius: 4px;
            pointer-events: auto;
        }

        #mapName {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
        }

        .map-pin-btn {
            font-size: 1.1rem;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .map-pin-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .map-pin-btn:active {
            transform: scale(0.95);
        }

        .map-pin-btn.hidden {
            display: none;
        }

        #dpad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: background 0.1s;
        }

        .dpad-btn:active, .dpad-btn.pressed {
            background: rgba(255, 255, 255, 0.4);
        }

        #dpad-up { top: 0; left: 50px; }
        #dpad-down { bottom: 0; left: 50px; }
        #dpad-left { top: 50px; left: 0; }
        #dpad-right { top: 50px; right: 0; }

        #dpad-center {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
        }

        #action-buttons {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: background 0.1s;
        }

        .action-btn:active, .action-btn.pressed {
            background: rgba(255, 255, 255, 0.4);
        }

        #btn-b {
            margin-top: 30px;
        }

        /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a2e 0%, #1a1a4e 50%, #2a2a6e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #titleScreen.hidden {
            display: none;
        }

        .sound-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffd700;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s ease;
            z-index: 101;
        }

        .sound-toggle:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.1);
        }

        .sound-toggle:active {
            transform: scale(0.95);
        }

        .sound-toggle.muted {
            border-color: #666;
            opacity: 0.7;
        }

        .title-content {
            text-align: center;
            color: #fff;
        }

        .game-title {
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow:
                0 0 10px #ffd700,
                0 0 20px #ff8c00,
                3px 3px 0 #8b4513;
            margin-bottom: 10px;
            animation: titleGlow 2s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 10px #ffd700, 0 0 20px #ff8c00, 3px 3px 0 #8b4513; }
            50% { text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00, 3px 3px 0 #8b4513; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #87ceeb;
            margin-bottom: 60px;
        }

        .title-menu {
            margin-bottom: 40px;
        }

        .menu-item {
            font-size: 1.4rem;
            padding: 15px 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s;
        }

        .menu-item:hover {
            color: #ffd700;
            transform: scale(1.05);
        }

        .menu-item .cursor {
            opacity: 0;
            transition: opacity 0.2s;
        }

        .menu-item.selected .cursor,
        .menu-item:hover .cursor {
            opacity: 1;
        }

        .menu-item.selected {
            color: #ffd700;
        }

        .press-start {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            animation: blink 1.5s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .title-menu.active ~ .press-start {
            display: none;
        }

        /* ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—è¡¨ç¤º */
        #worldMapOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        #worldMapOverlay.active {
            display: flex;
        }

        .map-frame {
            background: linear-gradient(135deg, #d4a574 0%, #c9956c 25%, #e6c9a8 50%, #c9956c 75%, #d4a574 100%);
            border: 8px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            box-shadow:
                inset 0 0 30px rgba(139, 69, 19, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            max-width: 90vw;
            max-height: 85vh;
        }

        .map-frame::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 2px solid rgba(139, 69, 19, 0.4);
            border-radius: 5px;
            pointer-events: none;
        }

        .map-title {
            text-align: center;
            font-size: 1.3rem;
            color: #4a2c0a;
            margin-bottom: 15px;
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }

        #worldMapCanvas {
            display: block;
            border: 3px solid #5c3317;
            border-radius: 5px;
            background: #1a1a2e;
        }

        .map-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75rem;
            color: #4a2c0a;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border: 1px solid #5c3317;
            border-radius: 2px;
        }

        .map-close-hint {
            text-align: center;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #6b4423;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="fadeOverlay"></div>

    <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
    <div id="titleScreen">
        <div id="soundToggle" class="sound-toggle">ğŸ”Š</div>
        <div class="title-content">
            <h1 class="game-title">ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ã‚¨ã‚¹ãƒˆ</h1>
            <p class="subtitle">ã€œ å‹‡è€…ã®å†’é™º ã€œ</p>
            <div class="title-menu">
                <div class="menu-item" id="menu-continue" style="display: none;">
                    <span class="cursor">â–¶</span>
                    <span>ã¤ã¥ãã‹ã‚‰</span>
                </div>
                <div class="menu-item" id="menu-newgame">
                    <span class="cursor">â–¶</span>
                    <span>ã¯ã˜ã‚ã‹ã‚‰</span>
                </div>
            </div>
            <p class="press-start" id="pressStart">Press ENTER or Tap to Start</p>
        </div>
    </div>

    <!-- ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <div id="worldMapOverlay">
        <div class="map-frame">
            <div class="map-title" id="worldMapTitle">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</div>
            <canvas id="worldMapCanvas"></canvas>
            <div class="map-legend">
                <div class="legend-item"><div class="legend-color" style="background: #44aa44;"></div>è‰åŸ</div>
                <div class="legend-item"><div class="legend-color" style="background: #886644;"></div>å±±</div>
                <div class="legend-item"><div class="legend-color" style="background: #2244aa;"></div>æµ·</div>
                <div class="legend-item"><div class="legend-color" style="background: #116611;"></div>æ£®</div>
                <div class="legend-item"><div class="legend-color" style="background: #ffffff;"></div>å»ºç‰©</div>
                <div class="legend-item"><div class="legend-color" style="background: #ff3333;"></div>ç¾åœ¨åœ°</div>
            </div>
            <div class="map-close-hint">Mã‚­ãƒ¼ ã¾ãŸã¯ ã‚¿ãƒƒãƒ—ã§é–‰ã˜ã‚‹</div>
        </div>
    </div>

    <div id="hud">
        <div id="mapNameArea">
            <span id="mapName">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</span>
            <span id="floorDisplay" style="color: #aaddff; margin-left: 8px;"></span>
            <span id="mapPinBtn" class="map-pin-btn">ğŸ“</span>
        </div>

        <!-- ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºï¼ˆé–‹ç™ºç”¨ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã§éè¡¨ç¤ºï¼‰
        <div id="encounterDebug" style="position: fixed; top: 40px; right: 10px; background: rgba(0,0,0,0.7); color: #0f0; padding: 5px 10px; font-size: 12px; font-family: monospace; border-radius: 4px; z-index: 1000;"></div>
        -->

        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">â–²</div>
            <div class="dpad-btn" id="dpad-left">â—€</div>
            <div id="dpad-center"></div>
            <div class="dpad-btn" id="dpad-right">â–¶</div>
            <div class="dpad-btn" id="dpad-down">â–¼</div>
        </div>

        <div id="action-buttons">
            <div class="action-btn" id="btn-b">B</div>
            <div class="action-btn" id="btn-a">A</div>
        </div>
    </div>

    <script>
        // ========================================
        // ã‚²ãƒ¼ãƒ è¨­å®š
        // ========================================
        const VISIBLE_TILES = 10;
        const SAVE_KEY = 'dragonquest_rpg_save';

        // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
        const MODE = {
            TITLE: 'title',
            FIELD: 'field',
            BATTLE: 'battle',
            MENU: 'menu',
            INN: 'inn',
            SHOP: 'shop',
            DIALOG: 'dialog',
            ENDING: 'ending',
            MAP_VIEW: 'map_view'
        };

        let gameMode = MODE.TITLE;
        let titleMenuIndex = 0;
        let titleMenuActive = false;
        let hasSaveData = false;
        let debugToggleCount = 0;  // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

        // ã‚¿ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—
        const TILE = {
            GRASS: 0,
            MOUNTAIN: 1,
            SEA: 2,
            CASTLE: 3,
            TOWN: 4,
            STAIRS: 5,
            FLOOR: 6,
            WALL: 7,
            PORTAL: 8,       // æ—…ã®æ‰‰
            STAIRS_UP: 9,    // ä¸Šã‚Šéšæ®µ
            STAIRS_DOWN: 10, // ä¸‹ã‚Šéšæ®µ
            // ç ‚æ¼ ã‚¿ã‚¤ãƒ«
            SAND: 11,        // ç ‚æ¼ 
            OASIS: 12,       // ã‚ªã‚¢ã‚·ã‚¹
            PYRAMID: 13,     // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰å…¥å£
            QUICKSAND: 14,   // æµç ‚ï¼ˆãƒ¯ãƒ¼ãƒ—ç”¨ï¼‰
            HIDDEN_WALL: 15, // éš ã—å£ï¼ˆèª¿ã¹ã‚‹ã¨é€šè·¯ã«ãªã‚‹ï¼‰
            HOLE: 16,             // ç©´ï¼ˆåœ°åº•ã¸è½ä¸‹ï¼‰
            UNDERWORLD_FLOOR: 17, // åœ°åº•åºŠ
            UNDERWORLD_WALL: 18,  // åœ°åº•å£
            WEDGE_ALTAR: 19,      // æ¥”ã®ç¥­å£‡
            UNDERWORLD_TOWN: 20,  // åœ°åº•ã®è¡—ï¼ˆæš—ã„èƒŒæ™¯ï¼‰
            // ã‚¨ãƒªã‚¢4: æ°·é›ªã®å¤§é™¸ã‚¿ã‚¤ãƒ«
            ICE_FLOOR: 21,        // æ»‘ã‚‹æ°·åºŠ
            ICE_WALL: 22,         // æ°·ã®å£ï¼ˆæ­¢ã¾ã‚Œã‚‹ï¼‰
            ICE_HOLE: 23,         // æ°·ã®ç©´ï¼ˆè½ã¡ã‚‹ã¨æˆ»ã‚‹ï¼‰
            SNOW: 24,             // é›ªåŸï¼ˆé€šå¸¸æ­©è¡Œå¯èƒ½ï¼‰
            ICE_CASTLE_FLOOR: 25, // æ°·ã®åŸã®åºŠ
            TORCH: 26,            // ç‡­å°ï¼ˆç¯ç«ãƒ‘ã‚ºãƒ«ç”¨ï¼‰
            ICE_ALTAR: 27,        // æ°·ã®ç¥­å£‡ï¼ˆè¨˜æ†¶ãƒ‘ã‚ºãƒ«ç”¨ï¼‰
            ICE_SWITCH: 28,       // åœ§åŠ›ã‚¹ã‚¤ãƒƒãƒ
            ICE_BLOCK: 29         // æŠ¼ã›ã‚‹æ°·ãƒ–ãƒ­ãƒƒã‚¯
        };

        // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—åˆ¥ã®ã‚¿ã‚¤ãƒ«è‰²
        const MAP_TILE_COLORS = {
            field: {
                [TILE.GRASS]: '#2d5a27',
                [TILE.MOUNTAIN]: '#6b4423',
                [TILE.SEA]: '#1a4a7a',
                [TILE.CASTLE]: '#2d5a27',
                [TILE.TOWN]: '#2d5a27',
                [TILE.STAIRS]: '#4a4a4a',
                [TILE.FLOOR]: '#8b7355',
                [TILE.WALL]: '#4a4a5a'
            },
            castle: {
                [TILE.FLOOR]: '#5a5a6a',
                [TILE.WALL]: '#3a3a4a',
                [TILE.STAIRS]: '#4a4a4a'
            },
            town: {
                [TILE.FLOOR]: '#a0a0a0',
                [TILE.WALL]: '#6a6a7a',
                [TILE.STAIRS]: '#4a4a4a'
            },
            dungeon: {
                [TILE.FLOOR]: '#4a4a3a',
                [TILE.WALL]: '#2a2a2a',
                [TILE.STAIRS]: '#5a5a4a'
            }
        };

        const DEFAULT_TILE_COLORS = {
            [TILE.GRASS]: '#2d5a27',
            [TILE.MOUNTAIN]: '#6b4423',
            [TILE.SEA]: '#1a4a7a',
            [TILE.CASTLE]: '#2d5a27',
            [TILE.TOWN]: '#2d5a27',
            [TILE.STAIRS]: '#4a4a4a',
            [TILE.FLOOR]: '#8b7355',
            [TILE.WALL]: '#4a4a5a',
            [TILE.PORTAL]: '#6a2a8a',      // æ—…ã®æ‰‰ï¼ˆç´«ï¼‰
            [TILE.STAIRS_UP]: '#5a5a4a',   // ä¸Šã‚Šéšæ®µ
            [TILE.STAIRS_DOWN]: '#4a4a3a', // ä¸‹ã‚Šéšæ®µ
            // ç ‚æ¼ ã‚¿ã‚¤ãƒ«
            [TILE.SAND]: '#d4a559',        // ç ‚æ¼ ï¼ˆé»„åœŸè‰²ï¼‰
            [TILE.OASIS]: '#2d8a57',       // ã‚ªã‚¢ã‚·ã‚¹ï¼ˆç·‘ï¼‰
            [TILE.PYRAMID]: '#c4a040',     // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼ˆé‡‘è‰²ï¼‰
            [TILE.QUICKSAND]: '#b89050',   // æµç ‚ï¼ˆæš—ã„ç ‚è‰²ï¼‰
            [TILE.HIDDEN_WALL]: '#2a2a2a', // éš ã—å£ï¼ˆå£ã¨åŒã˜è‰²ï¼‰
            [TILE.HOLE]: '#1a0a1a',
            [TILE.UNDERWORLD_FLOOR]: '#2a1a2a',
            [TILE.UNDERWORLD_WALL]: '#0a0a0a',
            [TILE.WEDGE_ALTAR]: '#8a6a3a',
            [TILE.UNDERWORLD_TOWN]: '#2a1a2a',  // åœ°åº•åºŠã¨åŒã˜æš—ã„èƒŒæ™¯
            // ã‚¨ãƒªã‚¢4: æ°·é›ªã®å¤§é™¸ã‚¿ã‚¤ãƒ«è‰²
            [TILE.ICE_FLOOR]: '#a8d8ea',       // æ°·åºŠï¼ˆè–„ã„æ°´è‰²ï¼‰
            [TILE.ICE_WALL]: '#5a8aa8',        // æ°·å£ï¼ˆæ¿ƒã„æ°´è‰²ï¼‰
            [TILE.ICE_HOLE]: '#1a3a5a',        // æ°·ã®ç©´ï¼ˆæš—ã„é’ï¼‰
            [TILE.SNOW]: '#e8f0f8',            // é›ªåŸï¼ˆç™½ã«è¿‘ã„è‰²ï¼‰
            [TILE.ICE_CASTLE_FLOOR]: '#c8e0f0', // æ°·ã®åŸåºŠï¼ˆæ˜ã‚‹ã„æ°´è‰²ï¼‰
            [TILE.TORCH]: '#c8e0f0',           // ç‡­å°ï¼ˆåºŠã¨åŒè‰²ï¼‰
            [TILE.ICE_ALTAR]: '#88b8d8',       // æ°·ã®ç¥­å£‡ï¼ˆä¸­é–“ã®æ°´è‰²ï¼‰
            [TILE.ICE_SWITCH]: '#7898b8',      // ã‚¹ã‚¤ãƒƒãƒï¼ˆã‚„ã‚„æš—ã„æ°´è‰²ï¼‰
            [TILE.ICE_BLOCK]: '#6888a8'        // æ°·ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆæš—ã‚ã®æ°´è‰²ï¼‰
        };

        const WALKABLE_TILES = [TILE.GRASS, TILE.CASTLE, TILE.TOWN, TILE.STAIRS, TILE.FLOOR, TILE.PORTAL, TILE.STAIRS_UP, TILE.STAIRS_DOWN, TILE.SAND, TILE.OASIS, TILE.PYRAMID, TILE.QUICKSAND, TILE.UNDERWORLD_FLOOR, TILE.WEDGE_ALTAR, TILE.UNDERWORLD_TOWN, TILE.ICE_FLOOR, TILE.SNOW, TILE.ICE_CASTLE_FLOOR, TILE.TORCH, TILE.ICE_ALTAR, TILE.ICE_SWITCH, TILE.ICE_HOLE];
        const ENCOUNTER_TILES = [TILE.GRASS, TILE.FLOOR, TILE.SAND, TILE.UNDERWORLD_FLOOR, TILE.ICE_FLOOR, TILE.SNOW, TILE.ICE_CASTLE_FLOOR]; // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãŒç™ºç”Ÿã™ã‚‹ã‚¿ã‚¤ãƒ«ï¼ˆè‰åŸã€ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³åºŠã€ç ‚æ¼ ã€åœ°åº•åºŠã€æ°·åºŠã€é›ªåŸã€æ°·ã®åŸï¼‰

        // ========================================
        // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿
        // ========================================
        const items = {
            // æ¶ˆè²»ã‚¢ã‚¤ãƒ†ãƒ 
            1: { id: 1, name: 'è–¬è‰', description: 'HPã‚’30å›å¾©ã™ã‚‹', type: 'heal', value: 30, price: 8 },
            2: { id: 2, name: 'æ¯’æ¶ˆã—è‰', description: 'æ¯’ã‚’æ²»ç™‚ã™ã‚‹', type: 'cure', price: 10 },
            3: { id: 3, name: 'è–æ°´', description: 'å¼±ã„æ•µã‚’é€€ã‘ã‚‹', type: 'holy', price: 20 },
            8: { id: 8, name: 'é­”æ³•ã®éµ', description: 'æ‰‰ã‚’é–‹ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹', type: 'key', price: 0 },
            // æ­¦å™¨ (equippable: è£…å‚™å¯èƒ½ãªã‚¸ãƒ§ãƒ–ãƒªã‚¹ãƒˆ)
            10: { id: 10, name: 'ã“ã‚“ã¼ã†', type: 'weapon', value: 2, price: 10, equippable: ['hero', 'mage'] },
            11: { id: 11, name: 'ã©ã†ã®ã¤ã‚‹ã', type: 'weapon', value: 10, price: 100, equippable: ['hero'] },
            12: { id: 12, name: 'ã¦ã¤ã®ã¤ã‚‹ã', type: 'weapon', value: 20, price: 300, equippable: ['hero'] },
            13: { id: 13, name: 'ã¯ãŒã­ã®ã¤ã‚‹ã', type: 'weapon', value: 35, price: 700, equippable: ['hero'] },
            14: { id: 14, name: 'ã»ã®ãŠã®ã¤ã‚‹ã', type: 'weapon', value: 40, price: 0, equippable: ['hero'] },
            // é˜²å…·ï¼ˆresistances: 1.0=ç­‰å€, 0.5=åŠæ¸›, 0=ç„¡åŠ¹, 2.0=å¼±ç‚¹ï¼‰
            20: { id: 20, name: 'ãŸã³ã³ã¨ã®ãµã', type: 'armor', value: 1, price: 10, equippable: ['hero', 'mage'] },
            21: { id: 21, name: 'ã‹ã‚ã®ã‚ˆã‚ã„', type: 'armor', value: 5, price: 80, equippable: ['hero', 'mage'] },
            22: { id: 22, name: 'ãã•ã‚Šã‹ãŸã³ã‚‰', type: 'armor', value: 12, price: 250, equippable: ['hero'], resistances: { lightning: 0.8 } },
            23: { id: 23, name: 'ã¦ã¤ã®ã‚ˆã‚ã„', type: 'armor', value: 22, price: 600, equippable: ['hero'], resistances: { fire: 0.9, lightning: 1.2 } },
            24: { id: 24, name: 'ã¾ã»ã†ã®ã‚ˆã‚ã„', type: 'armor', value: 35, price: 1200, equippable: ['hero', 'mage'], resistances: { fire: 0.7, ice: 0.7 } },
            // ã‚¨ãƒªã‚¢2 æ­¦å™¨ãƒ»é˜²å…·ï¼ˆå‹‡è€…ç”¨ï¼‰
            15: { id: 15, name: 'ã•ã°ãã®ã¤ã‚‹ã', type: 'weapon', value: 45, price: 1500, equippable: ['hero'] },
            16: { id: 16, name: 'ãƒ•ã‚¡ãƒ©ã‚ªã®ã¤ã‚‹ã', type: 'weapon', value: 55, price: 3000, equippable: ['hero'] },
            17: { id: 17, name: 'ãŠã†ã”ã‚“ã®ã¤ã‚', type: 'weapon', value: 65, price: 0, equippable: ['hero'] }, // éš ã—é€šè·¯ã®å®ç®±
            25: { id: 25, name: 'ã•ã°ãã®ã‚ˆã‚ã„', type: 'armor', value: 40, price: 1800, equippable: ['hero'], resistances: { fire: 0.6, ice: 1.2 } },
            26: { id: 26, name: 'ãƒ•ã‚¡ãƒ©ã‚ªã®ã‚ˆã‚ã„', type: 'armor', value: 50, price: 3500, equippable: ['hero'], resistances: { fire: 0.5, light: 0.8 } },
            // ã‚¨ãƒªã‚¢2 æ­¦å™¨ãƒ»é˜²å…·ï¼ˆé­”æ³•ä½¿ã„ç”¨ï¼‰
            40: { id: 40, name: 'ã¾ã©ã†ã—ã®æ–', type: 'weapon', value: 15, price: 800, equippable: ['mage'] },
            41: { id: 41, name: 'ã»ã®ãŠã®æ–', type: 'weapon', value: 28, price: 2000, equippable: ['mage'] },
            42: { id: 42, name: 'ã„ã‹ãšã¡ã®æ–', type: 'weapon', value: 40, price: 4000, equippable: ['mage'] },
            43: { id: 43, name: 'ã‘ã‚“ã˜ã‚ƒã®æ–', type: 'weapon', value: 55, price: 0, equippable: ['mage'] }, // å®ç®±é™å®š
            50: { id: 50, name: 'ã¾ã©ã†ã—ã®ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 18, price: 1000, equippable: ['mage'], resistances: { fire: 0.8, ice: 0.8 } },
            51: { id: 51, name: 'ã»ã—ãµã‚‹ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 32, price: 2500, equippable: ['mage'], resistances: { light: 0.6, fire: 0.8, ice: 0.8 } },
            52: { id: 52, name: 'ã ã„ã¾ã©ã†ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 45, price: 5000, equippable: ['mage'], resistances: { fire: 0.6, ice: 0.6, lightning: 0.8 } },
            // ã‚¨ãƒªã‚¢3 æ­¦å™¨ãƒ»é˜²å…·ï¼ˆå‹‡è€…ç”¨ï¼‰
            18: { id: 18, name: 'ã‚„ã¿ã®ã¤ã‚‹ã', type: 'weapon', value: 75, price: 5000, equippable: ['hero'] },
            19: { id: 19, name: 'ã»ã—ããšã®ã¤ã‚‹ã', type: 'weapon', value: 90, price: 8000, equippable: ['hero'] },
            27: { id: 27, name: 'ã‚„ã¿ã®ã‚ˆã‚ã„', type: 'armor', value: 60, price: 6000, equippable: ['hero'], resistances: { fire: 0.6, ice: 0.6, light: 1.3 } },
            28: { id: 28, name: 'ã»ã—ããšã®ã‚ˆã‚ã„', type: 'armor', value: 75, price: 10000, equippable: ['hero'], resistances: { fire: 0.5, ice: 0.5, lightning: 0.5, wind: 0.7, light: 0.7 } },
            // ã‚¨ãƒªã‚¢3 æ­¦å™¨ãƒ»é˜²å…·ï¼ˆé­”æ³•ä½¿ã„ç”¨ï¼‰
            44: { id: 44, name: 'ã‚„ã¿ã®æ–', type: 'weapon', value: 50, price: 4500, equippable: ['mage'] },
            45: { id: 45, name: 'ã»ã—ããšã®æ–', type: 'weapon', value: 70, price: 7500, equippable: ['mage'] },
            53: { id: 53, name: 'ã‚„ã¿ã®ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 55, price: 5500, equippable: ['mage'], resistances: { fire: 0.5, ice: 0.5, light: 1.3 } },
            54: { id: 54, name: 'ã»ã—ããšã®ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 70, price: 9000, equippable: ['mage'], resistances: { fire: 0.5, ice: 0.5, lightning: 0.5, wind: 0.6, light: 0.6 } },
            // ã‚¯ã‚¨ã‚¹ãƒˆã‚¢ã‚¤ãƒ†ãƒ ï¼ˆã‚¨ãƒªã‚¢2ï¼‰
            30: { id: 30, name: 'æ¸…ã‚‰ã‹ãªæ°´', description: 'ã‚ªã‚¢ã‚·ã‚¹ã®æ‘ã‚’æ•‘ã†è–ãªã‚‹æ°´', type: 'quest', price: 0 },
            31: { id: 31, name: 'ç‹å®¶ã®ç´‹ç« ', description: 'å¤ªé™½ã®åŸå¡ã¸ã®å…¥åŸè¨±å¯è¨¼', type: 'quest', price: 0 },
            32: { id: 32, name: 'é€šè¡Œæ‰‹å½¢', description: 'ãƒã‚¶ãƒ¼ãƒ«ã®ç”ºã¸ã®é€šè¡Œè¨±å¯è¨¼', type: 'quest', price: 0 },
            33: { id: 33, name: 'å¤ªé™½ã®è­·ç¬¦', description: 'ç ‚æ¼ ã®å®ˆè­·è€…ã®åŠ›ã‚’å°ã˜ãŸè­·ç¬¦', type: 'quest', price: 0 },
            // å›å¾©ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆä¸Šä½ï¼‰
            4: { id: 4, name: 'ä¸Šè–¬è‰', description: 'HPã‚’100å›å¾©ã™ã‚‹', type: 'heal', value: 100, price: 50 },
            5: { id: 5, name: 'ä¸–ç•Œæ¨¹ã®è‘‰', description: 'æˆ¦é—˜ä¸èƒ½ã‚’å›å¾©ã™ã‚‹', type: 'revive', price: 500 },
            9: { id: 9, name: 'ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•', description: 'æœ€å¾Œã«è¨ªã‚ŒãŸç”ºã«æˆ»ã‚‹', type: 'escape', price: 25 },
            // ã‚¨ãƒªã‚¢4: æ°·é›ªã®å¤§é™¸ã‚¢ã‚¤ãƒ†ãƒ 
            // æ¶ˆè²»ã‚¢ã‚¤ãƒ†ãƒ 
            60: { id: 60, name: 'ã»ã‹ã»ã‹ã‚¹ãƒ¼ãƒ—', description: 'å‡çµçŠ¶æ…‹ã‚’å›å¾©ã€3ã‚¿ãƒ¼ãƒ³å‡çµè€æ€§', type: 'cure', price: 100 },
            61: { id: 61, name: 'ãŸã„ã¾ã¤', description: 'æš—æ‰€ã‚’ç…§ã‚‰ã™', type: 'tool', price: 50 },
            62: { id: 62, name: 'ãµã¶ãã‚ˆã‘ã®è–¬', description: 'æ°·å±æ€§ãƒ€ãƒ¡ãƒ¼ã‚¸50%è»½æ¸›ï¼ˆ3ã‚¿ãƒ¼ãƒ³ï¼‰', type: 'buff', price: 200 },
            // æ­¦å™¨ï¼ˆã‚¨ãƒªã‚¢4ï¼‰
            70: { id: 70, name: 'ã“ãŠã‚Šã®ã¤ã‚‹ã', type: 'weapon', value: 55, price: 12000, equippable: ['hero'] },
            71: { id: 71, name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰ã‚½ãƒ¼ãƒ‰', type: 'weapon', value: 70, price: 0, equippable: ['hero'] },
            72: { id: 72, name: 'ã“ãŠã‚Šã®ã¤ãˆ', type: 'weapon', value: 45, price: 10000, equippable: ['mage', 'seer'] },
            73: { id: 73, name: 'ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ãƒ­ãƒƒãƒ‰', type: 'weapon', value: 60, price: 0, equippable: ['mage', 'seer'] },
            74: { id: 74, name: 'ã“ãŠã‚Šã®ãŠãŠãªãŸ', type: 'weapon', value: 65, price: 0, equippable: ['iceKnight'] },
            // é˜²å…·ï¼ˆã‚¨ãƒªã‚¢4ï¼‰
            80: { id: 80, name: 'ãµã‚†ã”ã‚‚ã‚Šã®ãµã', type: 'armor', value: 45, price: 8000, equippable: ['hero', 'mage', 'seer', 'iceKnight'], resistances: { ice: 0.7 } },
            81: { id: 81, name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰ãƒ¡ã‚¤ãƒ«', type: 'armor', value: 60, price: 0, equippable: ['hero', 'iceKnight'], resistances: { ice: 0.5 } },
            82: { id: 82, name: 'ã‚†ãã®ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 40, price: 7000, equippable: ['mage', 'seer'], resistances: { ice: 0.6 } },
            83: { id: 83, name: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ«ãƒ­ãƒ¼ãƒ–', type: 'armor', value: 55, price: 0, equippable: ['mage', 'seer'], resistances: { ice: 0.4, fire: 0.8 } },
            // ã‚¢ã‚¯ã‚»ã‚µãƒªï¼ˆã‚¨ãƒªã‚¢4ï¼‰
            90: { id: 90, name: 'ã“ãŠã‚Šã®ã‚†ã³ã‚', type: 'accessory', value: 0, price: 5000, equippable: ['hero', 'mage', 'seer', 'iceKnight'], resistances: { ice: 0.75 } },
            91: { id: 91, name: 'ã»ã®ãŠã®ãƒšãƒ³ãƒ€ãƒ³ãƒˆ', type: 'accessory', value: 0, price: 0, equippable: ['hero', 'mage', 'seer', 'iceKnight'], spellBoost: { fire: 1.2 } },
            92: { id: 92, name: 'ã˜ã‚‡ãŠã†ã®ãƒ†ã‚£ã‚¢ãƒ©', type: 'accessory', value: 0, price: 0, equippable: ['hero', 'mage', 'seer', 'iceKnight'], mpBoost: 30 },
            // ã‚¯ã‚¨ã‚¹ãƒˆã‚¢ã‚¤ãƒ†ãƒ ï¼ˆã‚¨ãƒªã‚¢4ï¼‰
            95: { id: 95, name: 'å¤ªé™½ã®ç‚', description: 'å¥³ç‹ã‚’æ•‘ã†åŠ›ã‚’æŒã¤è–ãªã‚‹ç‚', type: 'quest', price: 0 },
            96: { id: 96, name: 'æ¥µå…‰ã®å®ç ', description: 'æµ·ã‚’æ¸¡ã‚‹åŠ›ã‚’æŒã¤å®ç ', type: 'quest', price: 0 }
        };

        // ã‚·ãƒ§ãƒƒãƒ—å•†å“ãƒªã‚¹ãƒˆï¼ˆã‚¨ãƒªã‚¢åˆ¥å¯¾å¿œï¼‰
        const shopItemsByArea = {
            default: [11, 12, 13, 21, 22, 23], // ã©ã†ã®ã¤ã‚‹ãã€œã¦ã¤ã®ã‚ˆã‚ã„
            area2_shop: [12, 13, 14, 22, 23, 24, 1, 2, 3], // ã‚ˆã‚Šå¼·ã„è£…å‚™ + å›å¾©ã‚¢ã‚¤ãƒ†ãƒ 
            // ç ‚æ¼ ã‚¨ãƒªã‚¢ã®ã‚·ãƒ§ãƒƒãƒ—
            oasis_shop: [1, 2, 4, 9, 12, 13, 22, 23, 40, 50], // ã‚ªã‚¢ã‚·ã‚¹ã®æ‘ï¼šåŸºæœ¬è£…å‚™ã¨å›å¾© + é­”æ³•ä½¿ã„åˆæœŸè£…å‚™
            bazaar_shop: [1, 2, 4, 5, 9, 13, 15, 23, 25, 41, 51], // ãƒã‚¶ãƒ¼ãƒ«ã®ç”ºï¼šä¸­ç´šè£…å‚™ + é­”æ³•ä½¿ã„ä¸­ç´šè£…å‚™
            hidden_shop: [4, 5, 15, 16, 25, 26, 42, 52], // éš ã‚Œé‡Œï¼šé«˜ç´šè£…å‚™ + é­”æ³•ä½¿ã„é«˜ç´šè£…å‚™
            // ã‚¨ãƒªã‚¢3ã®ã‚·ãƒ§ãƒƒãƒ—
            underworld_shop: [1, 4, 5, 9, 18, 19, 27, 28, 44, 45, 53, 54], // åœ°åº•ã®æ‘ï¼šå›å¾©ã‚¢ã‚¤ãƒ†ãƒ  + ã‚¨ãƒªã‚¢3è£…å‚™
            // ã‚¨ãƒªã‚¢4ã®ã‚·ãƒ§ãƒƒãƒ—
            snow_village_weapon: [70, 72, 80, 82, 90], // é›ªåŸã®æ‘ãƒ»æ­¦å™¨å±‹ï¼šæ°·ã®æ­¦å™¨ãƒ»é˜²å…·
            snow_village_item: [1, 4, 5, 9, 60, 61, 62] // é›ªåŸã®æ‘ãƒ»é“å…·å±‹ï¼šå›å¾©ã‚¢ã‚¤ãƒ†ãƒ  + æ°·å¯¾ç­–ã‚¢ã‚¤ãƒ†ãƒ 
        };
        let currentShopId = 'default';
        const shopItems = shopItemsByArea.default; // äº’æ›æ€§ã®ãŸã‚ç¶­æŒ

        // ç¾åœ¨ã®ã‚·ãƒ§ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
        function getShopItems() {
            return shopItemsByArea[currentShopId] || shopItemsByArea.default;
        }

        // ========================================
        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªç®¡ç†ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        // ========================================
        const MAX_STACK_SIZE = 99;

        // ã‚¹ã‚¿ãƒƒã‚¯å¯èƒ½ã‹ã©ã†ã‹åˆ¤å®šï¼ˆè£…å‚™å“ä»¥å¤–ã¯ã‚¹ã‚¿ãƒƒã‚¯å¯èƒ½ï¼‰
        function isStackable(itemId) {
            const item = items[itemId];
            if (!item) return false;
            return item.type !== 'weapon' && item.type !== 'armor';
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ 
        function addItem(itemId, quantity = 1) {
            const item = items[itemId];
            if (!item) return false;

            if (isStackable(itemId)) {
                const existing = player.inventory.find(slot => slot.id === itemId);
                if (existing) {
                    existing.quantity = Math.min(existing.quantity + quantity, MAX_STACK_SIZE);
                } else {
                    player.inventory.push({ id: itemId, quantity: quantity });
                }
            } else {
                // è£…å‚™å“ã¯1ã¤ãšã¤è¿½åŠ 
                for (let i = 0; i < quantity; i++) {
                    player.inventory.push({ id: itemId, quantity: 1 });
                }
            }
            return true;
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
        function removeItem(itemId, quantity = 1) {
            const index = player.inventory.findIndex(slot => slot.id === itemId);
            if (index === -1) return false;

            const slot = player.inventory[index];
            slot.quantity -= quantity;

            if (slot.quantity <= 0) {
                player.inventory.splice(index, 1);
            }
            return true;
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã®æ‰€æŒæ•°ã‚’å–å¾—
        function getItemCount(itemId) {
            const slot = player.inventory.find(slot => slot.id === itemId);
            return slot ? slot.quantity : 0;
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒã£ã¦ã„ã‚‹ã‹åˆ¤å®š
        function hasItem(itemId, quantity = 1) {
            return getItemCount(itemId) >= quantity;
        }

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚’ã‚¢ã‚¤ãƒ†ãƒ IDé †ã«æ•´ç†
        function organizeInventory() {
            player.inventory.sort((a, b) => a.id - b.id);
        }

        // ========================================
        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
        // ========================================
        const monsters = {
            // ===== åºç›¤ã®æ•µï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ»æ£® Lv1~3æƒ³å®šï¼‰=====
            slime: {
                name: 'ã‚¹ãƒ©ã‚¤ãƒ ',
                sprite: 'ğŸŸ¢',
                level: 1,
                hp: 8,
                atk: 5,
                def: 2,
                speed: 3,
                exp: 2,
                gold: 2,
                resistances: { sleep: 1.0, blind: 1.0, poison: 1.0 }
            },
            dracky: {
                name: 'ãƒ‰ãƒ©ã‚­ãƒ¼',
                sprite: 'ğŸ¦‡',
                level: 2,
                hp: 10,
                atk: 7,
                def: 3,
                speed: 6,
                exp: 3,
                gold: 3,
                resistances: { sleep: 0.8, blind: 0.6, poison: 1.0 }
            },
            bat: {
                name: 'ãŠãŠã“ã†ã‚‚ã‚Š',
                sprite: 'ğŸ¦‡',
                hueRotate: 180, // è‰²é•ã„ï¼ˆé’ç³»ï¼‰
                level: 3,
                hp: 14,
                atk: 9,
                def: 4,
                speed: 8,
                exp: 5,
                gold: 5,
                resistances: { sleep: 0.8, blind: 0.5, poison: 1.0 }
            },
            // ===== ä¸­ç›¤ã®æ•µï¼ˆæ´çªŸB1ãƒ»æ£®ã®å¥¥ Lv4~6æƒ³å®šï¼‰=====
            ghost: {
                name: 'ã‚´ãƒ¼ã‚¹ãƒˆ',
                sprite: 'ğŸ‘»',
                level: 4,
                hp: 18,
                atk: 12,
                def: 5,
                speed: 5,
                exp: 10,
                gold: 8,
                resistances: { sleep: 0.3, blind: 1.0, poison: 0, light: 1.5, fire: 1.5 }  // å…‰ãƒ»ç‚å¼±ç‚¹
            },
            scorpion: {
                name: 'ãŠãŠã•ãã‚Š',
                sprite: 'ğŸ¦‚',
                level: 5,
                hp: 22,
                atk: 14,
                def: 8,
                speed: 7,
                exp: 15,
                gold: 12,
                resistances: { sleep: 0.7, blind: 0.8, poison: 0 } // æ¯’ç„¡åŠ¹
            },
            // ===== å¾ŒåŠã®æ•µï¼ˆæ´çªŸæ·±éƒ¨ Lv7~9æƒ³å®šï¼‰=====
            skeleton: {
                name: 'ãŒã„ã“ã¤',
                sprite: 'ğŸ’€',
                level: 6,
                hp: 28,
                atk: 18,
                def: 10,
                speed: 4,
                exp: 25,
                gold: 20,
                resistances: { sleep: 0, blind: 0.8, poison: 0, fire: 1.5, light: 1.5 }  // ç‚ãƒ»å…‰å¼±ç‚¹
            },
            armoredKnight: {
                name: 'ã•ã¾ã‚ˆã†ã‚ˆã‚ã„',
                sprite: 'ğŸ›¡ï¸',
                level: 7,
                hp: 40,
                atk: 22,
                def: 18,
                speed: 3,
                exp: 35,
                gold: 30,
                resistances: { sleep: 0.2, blind: 0.5, poison: 0, lightning: 1.5, fire: 0.5 }  // é›·å¼±ç‚¹ã€ç‚è€æ€§
            },
            deathKnight: {
                name: 'ã—ã‚Šã‚‡ã†ã®ãã—',
                sprite: 'ğŸ›¡ï¸',
                hueRotate: 270, // è‰²é•ã„ï¼ˆç´«ç³»ï¼‰
                level: 8,
                hp: 55,
                atk: 28,
                def: 22,
                speed: 5,
                exp: 50,
                gold: 45,
                resistances: { sleep: 0, blind: 0.3, poison: 0, light: 1.5, fire: 1.5 }  // å…‰ãƒ»ç‚å¼±ç‚¹
            },
            // ===== ä¸­ãƒœã‚¹ç´š =====
            midBoss: {
                name: 'æ´çªŸã®ç•ªäºº',
                sprite: 'ğŸ—¿',
                level: 9,
                hp: 100,
                atk: 35,
                def: 18,
                speed: 6,
                exp: 80,
                gold: 100,
                isBoss: true,
                resistances: { sleep: 0.1, blind: 0.2, poison: 0.3 }
            },
            // ========================================
            // ã‚¨ãƒªã‚¢2: å¤ªé™½ã¨ç ‚ã®ç‹å›½ï¼ˆLv10~25æƒ³å®šï¼‰
            // ========================================
            // ===== ç ‚æ¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆLv10~13ï¼‰=====
            sandSlime: {
                name: 'ã‚µãƒ³ãƒ‰ã‚¹ãƒ©ã‚¤ãƒ ',
                sprite: 'ğŸŸ¡',
                level: 10,
                hp: 35,
                atk: 22,
                def: 12,
                speed: 5,
                exp: 30,
                gold: 25,
                resistances: { sleep: 1.0, blind: 1.0, poison: 0.5 }
            },
            desertScorpion: {
                name: 'ã‚µãƒ³ãƒ‰ã‚¹ã‚³ãƒ¼ãƒ”ã‚ªãƒ³',
                sprite: 'ğŸ¦‚',
                hueRotate: 30,
                level: 11,
                hp: 45,
                atk: 28,
                def: 18,
                speed: 9,
                exp: 40,
                gold: 35,
                canPoison: true,
                resistances: { sleep: 0.5, blind: 0.7, poison: 0 }
            },
            cactusMan: {
                name: 'ã‚µãƒœãƒ†ãƒ³ãƒãƒ³',
                sprite: 'ğŸŒµ',
                level: 11,
                hp: 40,
                atk: 25,
                def: 15,
                speed: 4,
                exp: 35,
                gold: 30,
                resistances: { sleep: 0.8, blind: 0.6, poison: 0, fire: 1.5, ice: 0.5 }  // ç‚å¼±ç‚¹ã€æ°·è€æ€§
            },
            desertVulture: {
                name: 'ãƒ‡ã‚¶ãƒ¼ãƒˆãƒãƒ«ãƒãƒ£ãƒ¼',
                sprite: 'ğŸ¦…',
                level: 12,
                hp: 38,
                atk: 30,
                def: 10,
                speed: 14,
                exp: 45,
                gold: 40,
                resistances: { sleep: 0.6, blind: 0.4, poison: 1.0 }
            },
            // ===== ç ‚æ¼ ä¸­ç›¤ï¼ˆLv13~16ï¼‰=====
            desertMummy: {
                name: 'ãƒ‡ã‚¶ãƒ¼ãƒˆãƒŸã‚¤ãƒ©',
                sprite: 'ğŸ§Ÿ',
                level: 13,
                hp: 55,
                atk: 32,
                def: 20,
                speed: 4,
                exp: 55,
                gold: 50,
                resistances: { sleep: 0.2, blind: 0.8, poison: 0, fire: 2.0, ice: 0.5 }  // ç‚å¤§å¼±ç‚¹ã€æ°·è€æ€§
            },
            sandDevil: {
                name: 'ã™ãªã˜ã”ã',
                sprite: 'ğŸŒ€',
                hueRotate: 40,
                level: 14,
                hp: 50,
                atk: 35,
                def: 16,
                speed: 8,
                exp: 60,
                gold: 55,
                resistances: { sleep: 0.3, blind: 0.5, poison: 0.5 }
            },
            pyramidGuard: {
                name: 'ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã‚¬ãƒ¼ãƒ‰',
                sprite: 'ğŸ—¿',
                hueRotate: 180,
                level: 15,
                hp: 70,
                atk: 38,
                def: 28,
                speed: 5,
                exp: 75,
                gold: 70,
                resistances: { sleep: 0, blind: 0.5, poison: 0, lightning: 1.5, fire: 0.5 }  // é›·å¼±ç‚¹ã€ç‚è€æ€§
            },
            cursedPharaoh: {
                name: 'ã®ã‚ã„ã®ãƒ•ã‚¡ãƒ©ã‚ª',
                sprite: 'ğŸ‘‘',
                hueRotate: 270,
                level: 15,
                hp: 65,
                atk: 35,
                def: 22,
                speed: 7,
                exp: 70,
                gold: 65,
                resistances: { sleep: 0, blind: 0.3, poison: 0, fire: 1.5, light: 1.5 }  // ç‚ãƒ»å…‰å¼±ç‚¹
            },
            // ===== ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³æ·±éƒ¨ï¼ˆLv16~19ï¼‰=====
            desertGolem: {
                name: 'ãƒ‡ã‚¶ãƒ¼ãƒˆã‚´ãƒ¼ãƒ¬ãƒ ',
                sprite: 'ğŸª¨',
                level: 16,
                hp: 90,
                atk: 42,
                def: 35,
                speed: 3,
                exp: 90,
                gold: 85,
                resistances: { sleep: 0, blind: 0, poison: 0, lightning: 1.5, fire: 0.5, ice: 0.5 }  // é›·å¼±ç‚¹ã€ç‚æ°·è€æ€§
            },
            sandWorm: {
                name: 'ã‚µãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ ',
                sprite: 'ğŸ›',
                hueRotate: 40,
                level: 17,
                hp: 85,
                atk: 45,
                def: 25,
                speed: 6,
                exp: 100,
                gold: 95,
                resistances: { sleep: 0.4, blind: 0.6, poison: 0.3, ice: 1.5, fire: 0.5 }  // æ°·å¼±ç‚¹ã€ç‚è€æ€§
            },
            banditLeader: {
                name: 'ã¨ã†ããã®ã‹ã—ã‚‰',
                sprite: 'ğŸ¥·',
                level: 17,
                hp: 75,
                atk: 48,
                def: 22,
                speed: 12,
                exp: 95,
                gold: 150,
                resistances: { sleep: 0.5, blind: 0.4, poison: 0.8 }
            },
            ancientSoldier: {
                name: 'ã„ã«ã—ãˆã®ã¸ã„ã—',
                sprite: 'âš”ï¸',
                level: 18,
                hp: 80,
                atk: 50,
                def: 30,
                speed: 7,
                exp: 110,
                gold: 100,
                resistances: { sleep: 0, blind: 0.5, poison: 0 }
            },
            // ===== é«˜ãƒ¬ãƒ™ãƒ«ï¼ˆLv19~22ï¼‰=====
            sphinxMinor: {
                name: 'ã‚¹ãƒ•ã‚£ãƒ³ã‚¯ã‚¹',
                sprite: 'ğŸ¦',
                level: 19,
                hp: 100,
                atk: 52,
                def: 32,
                speed: 10,
                exp: 130,
                gold: 120,
                resistances: { sleep: 0.2, blind: 0.3, poison: 0.5 }
            },
            djinn: {
                name: 'ãƒ©ãƒ³ãƒ—ã®ã¾ã˜ã‚“',
                sprite: 'ğŸ§',
                level: 20,
                hp: 95,
                atk: 55,
                def: 28,
                speed: 11,
                exp: 140,
                gold: 130,
                resistances: { sleep: 0.1, blind: 0.2, poison: 0.3 }
            },
            mummyKing: {
                name: 'ãƒŸã‚¤ãƒ©ãŠã¨ã“',
                sprite: 'ğŸ§Ÿ',
                hueRotate: 180,
                level: 21,
                hp: 110,
                atk: 58,
                def: 35,
                speed: 5,
                exp: 160,
                gold: 150,
                weakToFire: true,
                resistances: { sleep: 0, blind: 0.5, poison: 0 }
            },
            // ===== ã‚¨ãƒªã‚¢2 ãƒœã‚¹ç´š =====
            quicksandBoss: {
                name: 'æµç ‚ã®ä¸»',
                sprite: 'ğŸŒŠ',
                hueRotate: 40,
                level: 18,
                hp: 180,
                atk: 45,
                def: 30,
                speed: 8,
                exp: 200,
                gold: 300,
                isBoss: true,
                resistances: { sleep: 0, blind: 0.2, poison: 0 }
            },
            banditKing: {
                name: 'ç›—è³Šç‹',
                sprite: 'ğŸ‘¤',
                level: 19,
                hp: 200,
                atk: 52,
                def: 28,
                speed: 14,
                exp: 250,
                gold: 500,
                isBoss: true,
                resistances: { sleep: 0.1, blind: 0.3, poison: 0.5 }
            },
            pyramidGuardian: {
                name: 'ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã®å®ˆè­·è€…',
                sprite: 'ğŸ¦…',
                hueRotate: 300,
                level: 22,
                hp: 280,
                atk: 60,
                def: 40,
                speed: 10,
                exp: 400,
                gold: 400,
                isBoss: true,
                resistances: { sleep: 0, blind: 0.1, poison: 0 }
            },
            desertGuardian: {
                name: 'ç ‚æ¼ ã®å®ˆè­·è€…',
                sprite: 'ğŸ—¿',
                hueRotate: 45,
                level: 25,
                hp: 400,
                atk: 70,
                def: 50,
                speed: 12,
                exp: 600,
                gold: 800,
                isBoss: true,
                actions: 2,
                resistances: { sleep: 0, blind: 0, poison: 0 }
            },
            // ========================================
            // ã‚¨ãƒªã‚¢3: æš—é»’ã®æ£®ã¨åœ°åº•ä¸–ç•Œï¼ˆLv18~28æƒ³å®šï¼‰
            // ========================================
            // ===== ã‚¨ãƒªã‚¢3åœ°ä¸Šç”¨ï¼ˆLv18~22ï¼‰=====
            shadowSlime: {
                name: 'ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ ',
                sprite: 'ğŸŸ£',
                level: 18,
                hp: 70,
                atk: 40,
                def: 20,
                speed: 12,
                exp: 100,
                gold: 70,
                resistances: { sleep: 0.3, poison: 0.5, light: 1.5 }  // å…‰å¼±ç‚¹
            },
            darkBat: {
                name: 'ãƒ€ãƒ¼ã‚¯ãƒãƒƒãƒˆ',
                sprite: 'ğŸ¦‡',
                level: 19,
                hp: 55,
                atk: 35,
                def: 15,
                speed: 25,
                exp: 90,
                gold: 55,
                resistances: { light: 1.5, wind: 1.5 }  // å…‰ãƒ»é¢¨å¼±ç‚¹
            },
            cursedTree: {
                name: 'ã˜ã‚…ã‹ã„',
                sprite: 'ğŸŒ³',
                level: 20,
                hp: 100,
                atk: 45,
                def: 30,
                speed: 5,
                exp: 130,
                gold: 85,
                resistances: { fire: 2.0, ice: 0.5, lightning: 0.5 }  // ç‚å¤§å¼±ç‚¹ã€æ°·é›·è€æ€§
            },
            ancientGolem: {
                name: 'ã„ã«ã—ãˆã‚´ãƒ¼ãƒ¬ãƒ ',
                sprite: 'ğŸ—¿',
                level: 22,
                hp: 150,
                atk: 55,
                def: 45,
                speed: 3,
                exp: 200,
                gold: 120,
                resistances: { sleep: 0, blind: 0, lightning: 1.5, fire: 0.5, ice: 0.5 }  // é›·å¼±ç‚¹ã€ç‚æ°·è€æ€§
            },
            darkKnight: {
                name: 'ãƒ€ãƒ¼ã‚¯ãƒŠã‚¤ãƒˆ',
                sprite: 'ğŸ–¤',
                level: 21,
                hp: 90,
                atk: 50,
                def: 35,
                speed: 15,
                exp: 150,
                gold: 100,
                resistances: { light: 1.5, fire: 0.5 }  // å…‰å¼±ç‚¹ã€ç‚è€æ€§
            },
            // ===== ã‚¨ãƒªã‚¢3åœ°åº•ç”¨ï¼ˆLv22~28ï¼‰=====
            underworldBat: {
                name: 'ã¡ã¦ã„ã‚³ã‚¦ãƒ¢ãƒª',
                sprite: 'ğŸ¦‡',
                level: 22,
                hp: 65,
                atk: 42,
                def: 18,
                speed: 28,
                exp: 110,
                gold: 65,
                resistances: { light: 1.5, wind: 1.5 }  // å…‰ãƒ»é¢¨å¼±ç‚¹
            },
            shadowDragon: {
                name: 'ã‚·ãƒ£ãƒ‰ãƒ¼ãƒ‰ãƒ©ã‚´ãƒ³',
                sprite: 'ğŸ‰',
                level: 25,
                hp: 180,
                atk: 70,
                def: 40,
                speed: 18,
                exp: 300,
                gold: 200,
                resistances: { light: 1.5, ice: 1.5, fire: 0.5 }  // å…‰ãƒ»æ°·å¼±ç‚¹ã€ç‚è€æ€§
            },
            deathWraith: {
                name: 'ãƒ‡ã‚¹ãƒ¬ã‚¤ã‚¹',
                sprite: 'ğŸ‘»',
                level: 24,
                hp: 85,
                atk: 55,
                def: 25,
                speed: 22,
                exp: 180,
                gold: 130,
                resistances: { sleep: 0, poison: 0, light: 2.0, fire: 1.5 }  // å…‰å¤§å¼±ç‚¹ã€ç‚å¼±ç‚¹
            },
            stoneGuardian: {
                name: 'ã„ã‚ã®ã¾ã‚‚ã‚Šã¦',
                sprite: 'ğŸª¨',
                level: 23,
                hp: 130,
                atk: 48,
                def: 50,
                speed: 5,
                exp: 160,
                gold: 90,
                resistances: { lightning: 1.5, fire: 0.5, ice: 0.5 }  // é›·å¼±ç‚¹ã€ç‚æ°·è€æ€§
            },
            wedgeGuardian: {
                name: 'ãã•ã³ã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'âš”ï¸',
                level: 28,
                hp: 350,
                atk: 80,
                def: 50,
                speed: 20,
                exp: 800,
                gold: 500,
                isBoss: true
            },
            // ã‚¨ãƒªã‚¢3æœ€çµ‚ãƒœã‚¹ï¼šå…‰ã®å®ˆè­·è€…ï¼ˆé—‡ã«å •ã¡ãŸå§¿ï¼‰
            shadowGuardian: {
                name: 'ã‚„ã¿ã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'ğŸ‘ï¸',
                level: 38,
                hp: 2000,
                atk: 145,
                def: 75,
                speed: 28,
                exp: 3500,
                gold: 1800,
                isBoss: true,
                actions: 2,  // 2å›è¡Œå‹•
                skills: ['attack', 'attack', 'giragura', 'hyados', 'strongAttack', 'behoma'],
                resistances: { sleep: 0, blind: 0.3, poison: 0 }
            },
            // æ¥”ã®å®ˆè­·è€…ï¼ˆ4å±æ€§ï¼‰- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¼·åŒ–ï¼†skillsè¿½åŠ 
            wedgeGuardian_north: {
                name: 'ã“ãŠã‚Šã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'â„ï¸',
                level: 32,
                hp: 950,
                atk: 105,
                def: 60,
                speed: 20,
                exp: 1200,
                gold: 750,
                isBoss: true,
                skills: ['attack', 'attack', 'hyados', 'strongAttack'],
                resistances: { ice: 0, fire: 2.0, sleep: 0.3 }
            },
            wedgeGuardian_east: {
                name: 'ã»ã®ãŠã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'ğŸ”¥',
                level: 32,
                hp: 900,
                atk: 115,
                def: 50,
                speed: 24,
                exp: 1250,
                gold: 780,
                isBoss: true,
                skills: ['attack', 'attack', 'giragura', 'strongAttack'],
                resistances: { fire: 0, ice: 2.0, sleep: 0.3 }
            },
            wedgeGuardian_south: {
                name: 'ã‹ãœã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'ğŸŒ€',
                level: 32,
                hp: 850,
                atk: 95,
                def: 55,
                speed: 38,
                exp: 1150,
                gold: 720,
                isBoss: true,
                skills: ['attack', 'attack', 'bagigross', 'strongAttack'],
                resistances: { death: 0, sleep: 0.3 }
            },
            wedgeGuardian_west: {
                name: 'ã„ã‹ãšã¡ã®ã—ã‚…ã”ã—ã‚ƒ',
                sprite: 'âš¡',
                level: 33,
                hp: 1000,
                atk: 110,
                def: 65,
                speed: 22,
                exp: 1300,
                gold: 800,
                isBoss: true,
                skills: ['attack', 'attack', 'raiden', 'strongAttack'],
                resistances: { lightning: 0, paralysis: 0, sleep: 0.3 }
            },
            // å›³æ›¸å®¤ã®å®ˆè­·è€…ï¼ˆå¤åŸä¸­ãƒœã‚¹ï¼‰
            libraryGuardian: {
                name: 'ã¨ã—ã‚‡ã—ã¤ã®ã°ã‚“ã«ã‚“',
                sprite: 'ğŸ“š',
                level: 34,
                hp: 700,
                atk: 95,
                def: 60,
                speed: 18,
                exp: 1500,
                gold: 900,
                isBoss: true,
                skills: ['attack', 'attack', 'strongAttack', 'mahoton'],
                resistances: { sleep: 0.5 }
            },
            // ===== æ¥”ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ç”¨é›‘é­šæ•µ =====
            boneWarrior: {
                name: 'ã»ã­ã›ã‚“ã—',
                sprite: 'ğŸ’€',
                level: 25,
                hp: 80,
                atk: 45,
                def: 30,
                speed: 12,
                exp: 140,
                gold: 90,
                resistances: { sleep: 0, poison: 0 }
            },
            cursedMage: {
                name: 'ã®ã‚ã„ã®ã¾ã˜ã‚…ã¤ã—',
                sprite: 'ğŸ§™',
                hueRotate: 270,
                level: 27,
                hp: 70,
                atk: 30,
                def: 25,
                speed: 18,
                exp: 160,
                gold: 100,
                spells: ['gira', 'rariho'],
                resistances: { sleep: 0.3 }
            },
            // ===== å¤åŸç”¨é›‘é­šæ•µ =====
            darkArmor: {
                name: 'ãƒ€ãƒ¼ã‚¯ã‚¢ãƒ¼ãƒãƒ¼',
                sprite: 'ğŸ›¡ï¸',
                hueRotate: 180,
                level: 28,
                hp: 130,
                atk: 60,
                def: 50,
                speed: 8,
                exp: 200,
                gold: 130,
                resistances: { sleep: 0.1, poison: 0 }
            },
            deathMagician: {
                name: 'ãƒ‡ã‚¹ãƒã‚¸ã‚·ãƒ£ãƒ³',
                sprite: 'ğŸ§™',
                hueRotate: 320,
                level: 29,
                hp: 90,
                atk: 40,
                def: 30,
                speed: 20,
                exp: 180,
                gold: 110,
                spells: ['giragura', 'mahoton'],
                resistances: { sleep: 0.2 }
            },
            cursedKnight: {
                name: 'ã®ã‚ã‚ã‚ŒãŸãã—',
                sprite: 'âš”ï¸',
                level: 30,
                hp: 160,
                atk: 70,
                def: 55,
                speed: 14,
                exp: 250,
                gold: 150,
                resistances: { sleep: 0, poison: 0, blind: 0.3 }
            },
            // ===== ãƒœã‚¹ç´š =====
            dragon: {
                name: 'ãƒ‰ãƒ©ã‚´ãƒ³',
                sprite: 'ğŸ‰',
                level: 10,
                hp: 80,
                atk: 35,
                def: 20,
                speed: 10,
                exp: 100,
                gold: 150,
                resistances: { sleep: 0.1, blind: 0.3, poison: 0.5 }
            },
            maou: {
                name: 'é­”ç‹',
                sprite: 'ğŸ‘¿',
                hp: 200,
                mp: 100,
                atk: 50,
                def: 30,
                speed: 15,
                exp: 500,
                gold: 0,
                isBoss: true,
                actions: 2, // 2å›è¡Œå‹•
                resistances: { sleep: 0, blind: 0, poison: 0 }, // å®Œå…¨è€æ€§
                // é­”ç‹å°‚ç”¨ã‚¹ã‚­ãƒ«
                skills: ['attack', 'hageshiiHonoo', 'behoma', 'ionazun']
            },
            // ===== ã‚¨ãƒªã‚¢4: æ°·é›ªã®å¤§é™¸ï¼ˆLv35~50ï¼‰=====
            snowSlime: {
                name: 'ã‚†ãã‚¹ãƒ©ã‚¤ãƒ ',
                sprite: 'ğŸ§Š',
                level: 35,
                hp: 120,
                atk: 55,
                def: 35,
                speed: 12,
                exp: 180,
                gold: 80,
                skills: ['attack', 'iceBreath'],
                resistances: { ice: 0, fire: 2.0 }
            },
            iceBat: {
                name: 'ã‚¢ã‚¤ã‚¹ãƒãƒƒãƒˆ',
                sprite: 'ğŸ¦‡',
                level: 36,
                hp: 90,
                atk: 60,
                def: 25,
                speed: 25,
                exp: 200,
                gold: 90,
                skills: ['attack', 'drain'],
                resistances: { ice: 0.5, fire: 1.5 }
            },
            snowWolf: {
                name: 'ã‚¹ãƒãƒ¼ã‚¦ãƒ«ãƒ•',
                sprite: 'ğŸº',
                level: 37,
                hp: 140,
                atk: 70,
                def: 40,
                speed: 20,
                exp: 220,
                gold: 100,
                skills: ['attack', 'howl'],
                resistances: { ice: 0.5, fire: 1.5 }
            },
            frozenKnight: {
                name: 'ã“ãŠã‚Šã®ãã—',
                sprite: 'ğŸ—¡ï¸',
                level: 38,
                hp: 180,
                atk: 75,
                def: 55,
                speed: 10,
                exp: 280,
                gold: 150,
                skills: ['attack', 'strongAttack'],
                resistances: { ice: 0, fire: 1.5, lightning: 1.5 }
            },
            iceElemental: {
                name: 'ã‚¢ã‚¤ã‚¹ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆ',
                sprite: 'ğŸ’ ',
                level: 40,
                hp: 160,
                atk: 65,
                def: 45,
                speed: 15,
                exp: 300,
                gold: 130,
                skills: ['attack', 'hyados'],
                resistances: { ice: 0, fire: 2.0, lightning: 0.5 }
            },
            frostGiant: {
                name: 'ãƒ•ãƒ­ã‚¹ãƒˆã‚¸ãƒ£ã‚¤ã‚¢ãƒ³ãƒˆ',
                sprite: 'ğŸ‘¹',
                level: 42,
                hp: 250,
                atk: 90,
                def: 60,
                speed: 8,
                exp: 400,
                gold: 200,
                skills: ['attack', 'strongAttack'],
                resistances: { ice: 0, fire: 1.5 }
            },
            crystalDragon: {
                name: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ«ãƒ‰ãƒ©ã‚´ãƒ³',
                sprite: 'ğŸ²',
                level: 45,
                hp: 300,
                atk: 100,
                def: 70,
                speed: 18,
                exp: 500,
                gold: 300,
                skills: ['attack', 'iceBreath', 'hyados'],
                resistances: { ice: 0, fire: 1.5, light: 0.5 }
            },
            // ã‚¨ãƒªã‚¢4ä¸­ãƒœã‚¹: æ°·ã®ã‚´ãƒ¼ãƒ¬ãƒ 
            iceGolem: {
                name: 'ã“ãŠã‚Šã®ã‚´ãƒ¼ãƒ¬ãƒ ',
                sprite: 'ğŸ—¿',
                level: 40,
                hp: 800,
                atk: 75,
                def: 60,
                speed: 8,
                exp: 1500,
                gold: 900,
                isBoss: true,
                skills: ['attack', 'iceBreath', 'strongAttack'],
                resistances: { ice: 0, fire: 2.0, lightning: 1.5, sleep: 0, poison: 0 }
            },
            // ã‚¨ãƒªã‚¢4æœ€çµ‚ãƒœã‚¹: æ°·ã®å¥³ç‹
            iceQueen: {
                name: 'ã“ãŠã‚Šã®ã˜ã‚‡ãŠã†',
                sprite: 'ğŸ‘¸',
                level: 48,
                hp: 1500,
                atk: 95,
                def: 70,
                speed: 20,
                exp: 3000,
                gold: 1500,
                isBoss: true,
                actions: 2,
                skills: ['attack', 'hyados', 'iceBreath', 'absoluteZero', 'behoma'],
                resistances: { ice: 0, fire: 2.0, light: 0.5, sleep: 0, poison: 0 }
            }
        };

        // ãƒœã‚¹å°‚ç”¨ã‚¹ã‚­ãƒ«
        const bossSkills = {
            // å…¨ä½“æ”»æ’ƒã‚¹ã‚­ãƒ«ï¼ˆelement: å±æ€§ï¼‰
            hageshiiHonoo: { name: 'ã¯ã’ã—ã„ã»ã®ãŠ', type: 'attack', target: 'all', power: 45, element: 'fire', flashColor: 'rgba(255, 50, 0, 0.7)' },
            ionazun: { name: 'ã‚¤ã‚ªãƒŠã‚ºãƒ³', type: 'attack', target: 'all', power: 55, element: 'lightning', flashColor: 'rgba(255, 255, 0, 0.7)' },
            hyados: { name: 'ãƒ’ãƒ£ãƒ€ãƒ«ã‚³', type: 'attack', target: 'all', power: 40, element: 'ice', flashColor: 'rgba(100, 200, 255, 0.7)' },
            giragura: { name: 'ã‚®ãƒ©ã‚°ãƒ¬ã‚¤ãƒ‰', type: 'attack', target: 'all', power: 50, element: 'fire', flashColor: 'rgba(255, 200, 50, 0.9)' },
            bagigross: { name: 'ãƒã‚®ã‚¯ãƒ­ã‚¹', type: 'attack', target: 'all', power: 45, element: 'wind', flashColor: 'rgba(200, 255, 200, 0.7)' },
            raiden: { name: 'ãƒ©ã‚¤ãƒ‡ã‚¤ãƒ³', type: 'attack', target: 'all', power: 48, element: 'lightning', flashColor: 'rgba(255, 255, 100, 0.8)' },
            // å˜ä½“æ”»æ’ƒã‚¹ã‚­ãƒ«ï¼ˆç‰©ç†ãªã®ã§å±æ€§ãªã—ï¼‰
            strongAttack: { name: 'ã¤ã‚ˆã„ã“ã†ã’ã', type: 'attack', target: 'single', power: 60, flashColor: 'rgba(255, 100, 100, 0.5)' },
            // ã‚°ãƒ©ã‚·ã‚ªç”¨ã‚¹ã‚­ãƒ«
            iceSlash: { name: 'ã“ãŠã‚Šã®ã„ã¡ã’ã', type: 'attack', target: 'single', power: 55, element: 'ice', flashColor: 'rgba(150, 220, 255, 0.6)' },
            // å›å¾©ã‚¹ã‚­ãƒ«
            behoma: { name: 'ãƒ™ãƒ›ãƒ', type: 'heal', power: 9999, flashColor: 'rgba(0, 255, 100, 0.5)' },
            // è£œåŠ©ã‚¹ã‚­ãƒ«
            mahoton: { name: 'ãƒãƒ›ãƒˆãƒ¼ãƒ³', type: 'debuff', effect: 'silence', flashColor: 'rgba(128, 0, 128, 0.5)' },
            // ã‚¨ãƒªã‚¢4ç”¨ã‚¹ã‚­ãƒ«
            iceBreath: { name: 'ã¤ã‚ãŸã„ã„ã', type: 'attack', target: 'all', power: 35, element: 'ice', flashColor: 'rgba(150, 220, 255, 0.7)' },
            absoluteZero: { name: 'ãœã£ãŸã„ã‚Œã„ã©', type: 'attack', target: 'all', power: 65, element: 'ice', flashColor: 'rgba(200, 240, 255, 0.9)' },
            // é›‘é­šæ•µç”¨ã‚¹ã‚­ãƒ«
            drain: { name: 'HPå¸å', type: 'drain', target: 'single', power: 20, flashColor: 'rgba(150, 50, 150, 0.5)' },
            howl: { name: 'ãŠãŸã‘ã³', type: 'debuff', effect: 'stun', flashColor: 'rgba(255, 200, 100, 0.5)' }
        };

        // ã‚¨ãƒªã‚¢åˆ¥ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆmapIdãƒ™ãƒ¼ã‚¹ï¼‰
        // åŒã˜ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’è¤‡æ•°å›å…¥ã‚Œã‚‹ã¨å‡ºç¾ç‡ãŒä¸ŠãŒã‚‹
        const encounterTables = {
            // ã‚¨ãƒªã‚¢1: æœ€åˆã®å¤§é™¸
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆLv1~3ï¼‰- åˆå¿ƒè€…å‘ã‘
            field: ['slime', 'slime', 'slime', 'dracky', 'dracky', 'bat'],
            // æ·±ã„æ£®ï¼ˆLv3~5ï¼‰- ã‚„ã‚„å¼·ã‚
            forest: ['dracky', 'bat', 'bat', 'ghost', 'scorpion'],
            // æš—é»’ã®æ´çªŸï¼ˆLv5~8ï¼‰- ä¸­ç›¤ã€œå¾ŒåŠ
            dungeon: ['ghost', 'scorpion', 'skeleton', 'skeleton', 'armoredKnight', 'deathKnight'],

            // ã‚¨ãƒªã‚¢2: å¤ªé™½ã¨ç ‚ã®ç‹å›½ï¼ˆLv10~25ï¼‰
            // ç ‚æ¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆLv10~14ï¼‰
            desert_field: ['sandSlime', 'sandSlime', 'desertScorpion', 'cactusMan', 'desertVulture', 'desertMummy'],
            // ç ‚æ¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¥¥åœ°ï¼ˆLv13~17ï¼‰
            desert_deep: ['desertMummy', 'sandDevil', 'sandDevil', 'pyramidGuard', 'cursedPharaoh', 'desertGolem'],
            // æµç ‚ã®æ´çªŸï¼ˆLv14~18ï¼‰
            quicksand_cave: ['sandDevil', 'sandDevil', 'sandWorm', 'sandWorm', 'desertGolem'],
            // ç›—è³Šã®ã‚¢ã‚¸ãƒˆï¼ˆLv15~18ï¼‰
            bandit_hideout: ['banditLeader', 'banditLeader', 'banditLeader', 'desertScorpion', 'cactusMan'],
            // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼ˆLv16~22ï¼‰
            pyramid: ['pyramidGuard', 'cursedPharaoh', 'desertMummy', 'ancientSoldier', 'mummyKing'],
            pyramid_deep: ['ancientSoldier', 'mummyKing', 'sphinxMinor', 'djinn'],
            // ç ‚æ¼ ã®åŸï¼ˆLv20~25ï¼‰
            desert_castle: ['sphinxMinor', 'djinn', 'mummyKing', 'ancientSoldier'],
            // æ—§ã‚¨ãƒªã‚¢2äº’æ›
            area2_field: ['sandSlime', 'sandSlime', 'desertScorpion', 'cactusMan', 'desertVulture', 'desertMummy'],
            area2_dungeon: ['pyramidGuard', 'cursedPharaoh', 'desertGolem', 'sandWorm'],

            // ã‚¨ãƒªã‚¢3: æš—é»’ã®æ£®ã¨åœ°åº•ä¸–ç•Œï¼ˆLv18~28ï¼‰
            // ã‚¨ãƒªã‚¢3åœ°ä¸Šï¼ˆLv18~22ï¼‰
            area3_surface: ['shadowSlime', 'darkBat', 'cursedTree', 'ancientGolem', 'darkKnight'],
            // ã‚¨ãƒªã‚¢3åœ°åº•ï¼ˆLv22~28ï¼‰
            area3_underworld: ['underworldBat', 'shadowDragon', 'deathWraith', 'stoneGuardian'],
            // ã‚¨ãƒªã‚¢3ãƒœã‚¹æˆ¦
            area3_boss: ['wedgeGuardian'],
            // æ¥”ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼ˆLv25~29ï¼‰
            wedge_dungeon_b1: ['shadowSlime', 'darkBat', 'boneWarrior', 'boneWarrior'],
            wedge_dungeon_b2: ['darkKnight', 'cursedMage', 'shadowDragon', 'boneWarrior'],
            wedge_dungeon_b3: [], // ãƒœã‚¹ã‚¨ãƒªã‚¢ã®ã¿ï¼ˆã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãªã—ï¼‰
            // å¤åŸã‚»ãƒ¬ã‚¹ãƒ†ã‚£ã‚¢ï¼ˆLv28~35ï¼‰
            castle_b2: ['ghost', 'ghost', 'skeleton', 'deathWraith'],
            castle_b1: ['skeleton', 'skeleton', 'darkArmor', 'deathWraith'],
            castle_1f: ['darkArmor', 'skeleton', 'deathMagician', 'cursedKnight'],
            castle_2f: ['darkArmor', 'deathMagician', 'deathMagician', 'cursedKnight'],
            castle_3f: ['cursedKnight', 'cursedKnight', 'deathMagician'], // ãƒœã‚¹ãƒ•ãƒ­ã‚¢ï¼ˆä½ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆï¼‰
            // ã‚¨ãƒªã‚¢4: æ°·é›ªã®å¤§é™¸ï¼ˆLv35~50ï¼‰
            area4_field: ['snowSlime', 'snowSlime', 'iceBat', 'snowWolf', 'snowWolf'],
            area4_cave: ['snowSlime', 'frozenKnight', 'iceElemental', 'iceBat'],
            area4_temple: ['iceElemental', 'iceElemental', 'frostGiant', 'frozenKnight'],
            area4_castle: ['frozenKnight', 'frostGiant', 'crystalDragon', 'crystalDragon']
        };

        // æ—§typeåã¨ã®äº’æ›ç”¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        const encounterTableFallback = {
            field: 'field',
            dungeon: 'dungeon'
        };

        // ========================================
        // å‘ªæ–‡ãƒ‡ãƒ¼ã‚¿
        // ========================================
        const spells = {
            // å›å¾©å‘ªæ–‡ï¼ˆå‹‡è€…ãƒ»åƒ§ä¾¶ç³»ï¼‰
            hoimi: { id: 'hoimi', name: 'ãƒ›ã‚¤ãƒŸ', mp: 3, type: 'heal', power: 30, learnLevel: 2, learnableBy: ['hero'], element: 'heal', flashColor: 'rgba(0, 255, 100, 0.5)' },
            behoimi: { id: 'behoimi', name: 'ãƒ™ãƒ›ã‚¤ãƒŸ', mp: 6, type: 'heal', power: 80, learnLevel: 12, learnableBy: ['hero'], element: 'heal', flashColor: 'rgba(0, 255, 100, 0.6)' },
            behoma: { id: 'behoma', name: 'ãƒ™ãƒ›ãƒ', mp: 12, type: 'heal', power: 999, learnLevel: 32, learnableBy: ['hero'], element: 'heal', flashColor: 'rgba(0, 255, 100, 0.8)' },
            behomazun: { id: 'behomazun', name: 'ãƒ™ãƒ›ãƒã‚ºãƒ³', mp: 40, type: 'heal', power: 999, learnLevel: 60, learnableBy: ['hero'], element: 'heal', flashColor: 'rgba(0, 255, 100, 1.0)' },
            // å¾©æ´»å‘ªæ–‡ï¼ˆå‹‡è€…ï¼‰
            zaoraru: { id: 'zaoraru', name: 'ã‚¶ã‚ªãƒ©ãƒ«', mp: 10, type: 'revive', successRate: 0.5, learnLevel: 22, learnableBy: ['hero'], element: 'heal', flashColor: 'rgba(255, 255, 200, 0.7)' },
            zaoriku: { id: 'zaoriku', name: 'ã‚¶ã‚ªãƒªã‚¯', mp: 20, type: 'revive', successRate: 1.0, learnLevel: 99, learnableBy: [], element: 'heal', flashColor: 'rgba(255, 255, 255, 1.0)' },
            // æ”»æ’ƒå‘ªæ–‡ï¼ˆå˜ä½“ï¼‰- é­”æ³•ä½¿ã„ç³»
            mera: { id: 'mera', name: 'ãƒ¡ãƒ©', mp: 2, type: 'attack', target: 'single', power: 15, learnLevel: 3, learnableBy: ['hero', 'mage'], element: 'fire', flashColor: 'rgba(255, 100, 0, 0.6)' },
            merami: { id: 'merami', name: 'ãƒ¡ãƒ©ãƒŸ', mp: 8, type: 'attack', target: 'single', power: 80, learnLevel: 28, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 100, 0, 0.8)' },
            merazoma: { id: 'merazoma', name: 'ãƒ¡ãƒ©ã‚¾ãƒ¼ãƒ', mp: 15, type: 'attack', target: 'single', power: 200, learnLevel: 45, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 50, 0, 1.0)' },
            hyado: { id: 'hyado', name: 'ãƒ’ãƒ£ãƒ‰', mp: 4, type: 'attack', target: 'single', power: 25, learnLevel: 6, learnableBy: ['mage'], element: 'ice', flashColor: 'rgba(100, 200, 255, 0.6)' },
            hyados: { id: 'hyados', name: 'ãƒ’ãƒ£ãƒ€ãƒ«ã‚³', mp: 8, type: 'attack', target: 'all', power: 50, learnLevel: 20, learnableBy: ['mage'], element: 'ice', flashColor: 'rgba(100, 200, 255, 0.8)' },
            // æ”»æ’ƒå‘ªæ–‡ï¼ˆå…¨ä½“ï¼‰- é­”æ³•ä½¿ã„ç³»
            gira: { id: 'gira', name: 'ã‚®ãƒ©', mp: 5, type: 'attack', target: 'all', power: 35, learnLevel: 8, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 255, 100, 0.6)' },
            giragura: { id: 'giragura', name: 'ã‚®ãƒ©ã‚°ãƒ¬ã‚¤ãƒ‰', mp: 15, type: 'attack', target: 'all', power: 120, learnLevel: 35, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 200, 50, 0.9)' },
            begirama: { id: 'begirama', name: 'ãƒ™ã‚®ãƒ©ãƒ', mp: 10, type: 'attack', target: 'all', power: 70, learnLevel: 18, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 200, 50, 0.8)' },
            begiragon: { id: 'begiragon', name: 'ãƒ™ã‚®ãƒ©ã‚´ãƒ³', mp: 20, type: 'attack', target: 'all', power: 150, learnLevel: 40, learnableBy: ['mage'], element: 'fire', flashColor: 'rgba(255, 150, 0, 1.0)' },
            gigadein: { id: 'gigadein', name: 'ã‚®ã‚¬ãƒ‡ã‚¤ãƒ³', mp: 30, type: 'attack', target: 'all', power: 300, learnLevel: 50, learnableBy: ['hero'], element: 'light', flashColor: 'rgba(255, 255, 100, 1.0)' },
            minadein: { id: 'minadein', name: 'ãƒŸãƒŠãƒ‡ã‚¤ãƒ³', mp: 50, type: 'attack', target: 'all', power: 1000, learnLevel: 99, learnableBy: ['hero'], element: 'light', flashColor: 'rgba(255, 255, 255, 1.0)' },
            // é¢¨å±æ€§å‘ªæ–‡
            bagi: { id: 'bagi', name: 'ãƒã‚®', mp: 4, type: 'attack', target: 'all', power: 20, learnLevel: 10, learnableBy: ['seer'], element: 'wind', flashColor: 'rgba(150, 255, 150, 0.6)' },
            bagima: { id: 'bagima', name: 'ãƒã‚®ãƒ', mp: 8, type: 'attack', target: 'all', power: 60, learnLevel: 22, learnableBy: ['seer'], element: 'wind', flashColor: 'rgba(150, 255, 150, 0.8)' },
            // é›·å±æ€§å‘ªæ–‡
            dein: { id: 'dein', name: 'ãƒ‡ã‚¤ãƒ³', mp: 6, type: 'attack', target: 'single', power: 40, learnLevel: 15, learnableBy: ['hero'], element: 'lightning', flashColor: 'rgba(255, 255, 0, 0.7)' },
            raiden: { id: 'raiden', name: 'ãƒ©ã‚¤ãƒ‡ã‚¤ãƒ³', mp: 12, type: 'attack', target: 'all', power: 100, learnLevel: 30, learnableBy: ['hero'], element: 'lightning', flashColor: 'rgba(255, 255, 0, 0.9)' },
            // çŠ¶æ…‹ç•°å¸¸å‘ªæ–‡ - é­”æ³•ä½¿ã„ç³»
            rariho: { id: 'rariho', name: 'ãƒ©ãƒªãƒ›ãƒ¼', mp: 3, type: 'status', statusEffect: 'sleep', successRate: 0.7, learnLevel: 5, learnableBy: ['mage', 'seer'], element: 'status', flashColor: 'rgba(150, 100, 200, 0.5)' },
            manusa: { id: 'manusa', name: 'ãƒãƒŒãƒ¼ã‚µ', mp: 4, type: 'status', statusEffect: 'blind', successRate: 0.6, learnLevel: 9, learnableBy: ['mage'], element: 'status', flashColor: 'rgba(150, 100, 200, 0.5)' },
            mahoton: { id: 'mahoton', name: 'ãƒãƒ›ãƒˆãƒ¼ãƒ³', mp: 4, type: 'status', statusEffect: 'silence', successRate: 0.6, learnLevel: 12, learnableBy: ['mage'], element: 'status', flashColor: 'rgba(100, 100, 150, 0.5)' },
            // ãƒ‡ãƒãƒ•å‘ªæ–‡ - è³¢è€…ç³»
            rukani: { id: 'rukani', name: 'ãƒ«ã‚«ãƒ‹', mp: 3, type: 'debuff', debuffType: 'defense', debuffRate: 0.5, successRate: 0.75, learnLevel: 3, learnableBy: ['seer'], element: 'status', flashColor: 'rgba(100, 50, 150, 0.5)' },
            // è£œåŠ©å‘ªæ–‡
            sukuruto: { id: 'sukuruto', name: 'ã‚¹ã‚¯ãƒ«ãƒˆ', mp: 4, type: 'buff', buffType: 'defense', buffRate: 1.5, learnLevel: 25, learnableBy: ['hero'], element: 'buff', flashColor: 'rgba(100, 200, 255, 0.5)' },
            baikiruto: { id: 'baikiruto', name: 'ãƒã‚¤ã‚­ãƒ«ãƒˆ', mp: 6, type: 'buff', buffType: 'attack', buffRate: 2.0, learnLevel: 35, learnableBy: ['mage'], element: 'buff', flashColor: 'rgba(255, 100, 100, 0.6)' },
            piorimu: { id: 'piorimu', name: 'ãƒ”ã‚ªãƒªãƒ ', mp: 4, type: 'buff', buffType: 'speed', buffRate: 2.0, duration: 99, learnLevel: 8, learnableBy: ['seer'], element: 'buff', flashColor: 'rgba(150, 255, 150, 0.5)' },
            // ç§»å‹•å‘ªæ–‡
            riremito: { id: 'riremito', name: 'ãƒªãƒ¬ãƒŸãƒˆ', mp: 4, type: 'escape', learnLevel: 12, learnableBy: ['hero', 'mage'], element: 'move', flashColor: 'rgba(200, 200, 255, 0.5)' },
            rura: { id: 'rura', name: 'ãƒ«ãƒ¼ãƒ©', mp: 8, type: 'warp', learnLevel: 15, learnableBy: ['hero'], element: 'move', flashColor: 'rgba(100, 200, 255, 0.7)' },
            // æ°·çµé¨å£«å°‚ç”¨ã‚¹ã‚­ãƒ«
            iceSlash: { id: 'iceSlash', name: 'ã“ãŠã‚Šã®ã„ã¡ã’ã', mp: 6, type: 'attack', target: 'single', power: 55, learnLevel: 1, learnableBy: ['iceKnight'], element: 'ice', flashColor: 'rgba(150, 220, 255, 0.6)' },
            frostArmor: { id: 'frostArmor', name: 'ãƒ•ãƒ­ã‚¹ãƒˆã‚¢ãƒ¼ãƒãƒ¼', mp: 8, type: 'buff', buffType: 'defense', buffRate: 1.8, learnLevel: 40, learnableBy: ['iceKnight'], element: 'ice', flashColor: 'rgba(180, 230, 255, 0.6)' }
        };

        // çŠ¶æ…‹ç•°å¸¸ã®å®šç¾©
        const STATUS_EFFECTS = {
            sleep: { name: 'çœ ã‚Š', icon: 'ğŸ’¤', badge: 'çœ ', duration: { min: 2, max: 3 } },
            poison: { name: 'æ¯’', icon: 'â˜ ï¸', badge: 'æ¯’', damageRate: 0.1 },
            blind: { name: 'å¹»æƒ‘', icon: 'ğŸ’«', badge: 'å¹»', hitRateModifier: 0.5 },
            silence: { name: 'æ²ˆé»™', icon: 'ğŸ”‡', badge: 'é»™', duration: { min: 3, max: 5 } }
        };

        // ========================================
        // å±æ€§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        // æ”»æ’ƒå±æ€§ã®å®šç¾©
        const ELEMENTS = ['fire', 'ice', 'lightning', 'wind', 'light'];

        // å±æ€§ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ã‚’è¨ˆç®—
        function getElementMultiplier(spell, enemy) {
            // æ”»æ’ƒå‘ªæ–‡ä»¥å¤–ã¯ç­‰å€
            if (!spell || spell.type !== 'attack' || !spell.element) {
                return { multiplier: 1.0, effectiveness: 'normal' };
            }

            const element = spell.element;
            // æ”»æ’ƒå±æ€§ä»¥å¤–ï¼ˆheal, buffç­‰ï¼‰ã¯ç­‰å€
            if (!ELEMENTS.includes(element)) {
                return { multiplier: 1.0, effectiveness: 'normal' };
            }

            const resistances = enemy.resistances || {};
            const multiplier = resistances[element] !== undefined ? resistances[element] : 1.0;

            // åŠ¹æœåˆ¤å®š
            let effectiveness = 'normal';
            if (multiplier === 0) {
                effectiveness = 'immune';      // ç„¡åŠ¹
            } else if (multiplier >= 2.0) {
                effectiveness = 'weak';        // å¼±ç‚¹ï¼ˆ2å€ä»¥ä¸Šï¼‰
            } else if (multiplier >= 1.5) {
                effectiveness = 'effective';   // åŠ¹æœçš„ï¼ˆ1.5å€ä»¥ä¸Šï¼‰
            } else if (multiplier <= 0.25) {
                effectiveness = 'resistant';   // å¼·è€æ€§ï¼ˆ0.25å€ä»¥ä¸‹ï¼‰
            } else if (multiplier <= 0.5) {
                effectiveness = 'resisted';    // è€æ€§ï¼ˆ0.5å€ä»¥ä¸‹ï¼‰
            }

            return { multiplier, effectiveness };
        }

        // å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
        function getElementEffectivenessMessage(effectiveness, enemyName) {
            switch (effectiveness) {
                case 'immune':
                    return `${enemyName} ã«ã¯ ã¾ã£ãŸã ãã‹ãªã‹ã£ãŸï¼`;
                case 'weak':
                    return 'ã“ã†ã‹ã¯ ã°ã¤ãã‚“ã ï¼';
                case 'effective':
                    return 'ã“ã†ã‹ãŒ ã‚ã‚‹ã‚ˆã†ã ï¼';
                case 'resistant':
                    return 'ã‚ã¾ã‚Š ãã„ã¦ã„ãªã„ã‚ˆã†ã ...';
                case 'resisted':
                    return 'ã“ã†ã‹ã¯ ã„ã¾ã²ã¨ã¤ã®ã‚ˆã†ã ...';
                default:
                    return null;
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è£…å‚™ã‹ã‚‰å±æ€§è€æ€§ã‚’å–å¾—
        function getPlayerElementResistance(member, element) {
            if (!element || !ELEMENTS.includes(element)) {
                return 1.0;  // å±æ€§ãªã—ã¯ç­‰å€
            }

            let totalResistance = 1.0;

            // è£…å‚™ã—ã¦ã„ã‚‹é˜²å…·ã®è€æ€§ã‚’ç¢ºèª
            if (member.equipment && member.equipment.armor) {
                const armor = items[member.equipment.armor];
                if (armor && armor.resistances && armor.resistances[element] !== undefined) {
                    totalResistance *= armor.resistances[element];
                }
            }

            return totalResistance;
        }

        // æ•µã‚¹ã‚­ãƒ«â†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å±æ€§ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ã‚’è¨ˆç®—
        function getPlayerElementMultiplier(skill, member) {
            // ã‚¹ã‚­ãƒ«ã«å±æ€§ãŒãªã„å ´åˆã¯ç­‰å€
            if (!skill || !skill.element) {
                return { multiplier: 1.0, effectiveness: 'normal' };
            }

            const element = skill.element;
            const resistance = getPlayerElementResistance(member, element);

            // åŠ¹æœåˆ¤å®š
            let effectiveness = 'normal';
            if (resistance === 0) {
                effectiveness = 'immune';      // ç„¡åŠ¹
            } else if (resistance <= 0.25) {
                effectiveness = 'resistant';   // å¼·è€æ€§
            } else if (resistance <= 0.5) {
                effectiveness = 'resisted';    // è€æ€§
            } else if (resistance >= 2.0) {
                effectiveness = 'weak';        // å¼±ç‚¹
            } else if (resistance >= 1.5) {
                effectiveness = 'effective';   // åŠ¹æœçš„
            }

            return { multiplier: resistance, effectiveness };
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã®å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        function getPlayerElementEffectivenessMessage(effectiveness, memberName) {
            switch (effectiveness) {
                case 'immune':
                    return `${memberName} ã¯ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ ã†ã‘ãªã‹ã£ãŸï¼`;
                case 'resistant':
                    return `${memberName} ã¯ ã»ã¨ã‚“ã© ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ ã†ã‘ãªã‹ã£ãŸï¼`;
                case 'resisted':
                    return `${memberName} ã¸ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯ ã™ããªã‹ã£ãŸï¼`;
                case 'weak':
                    return `${memberName} ã® ã‚ˆã‚ã¦ã‚“ã‚’ ã¤ã„ãŸï¼`;
                case 'effective':
                    return `${memberName} ã« ã“ã†ã‹ã¦ãã ï¼`;
                default:
                    return null;
            }
        }

        // å‘ªæ–‡ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡ºç”¨
        let spellFlash = { active: false, color: '', alpha: 0 };

        // ãƒœã‚¹æˆ¦æ¼”å‡ºç”¨
        let screenShake = { active: false, intensity: 0, duration: 0 };
        let gameCleared = false;  // é­”ç‹è¨ä¼ãƒ•ãƒ©ã‚°ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ç¶­æŒï¼‰
        let endingPhase = null;   // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°é€²è¡ŒçŠ¶æ…‹

        // ========================================
        // ========================================
        // ã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ  (SE + BGM)
        // ========================================
        const SOUND_SETTING_KEY = 'dragonQuestSoundEnabled';
        let audioCtx = null;
        // localStorageã‹ã‚‰ã‚µã‚¦ãƒ³ãƒ‰è¨­å®šã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ONï¼‰
        let soundEnabled = localStorage.getItem(SOUND_SETTING_KEY) !== 'false';
        let seEnabled = soundEnabled;
        let seVolume = 0.5;
        let bgmEnabled = soundEnabled;
        let bgmVolume = 0.3;
        let audioInitialized = false;

        // AudioContextã‚’åˆæœŸåŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«å‘¼ã³å‡ºã™ï¼‰
        let audioUnlocked = false;

        function initAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;

            // AudioContextåˆæœŸåŒ–
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // Web Audio APIã§ç„¡éŸ³ãƒãƒƒãƒ•ã‚¡ã‚’å†ç”Ÿã—ã¦ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
            try {
                const buffer = audioCtx.createBuffer(1, 1, 22050);
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);
            } catch (e) {
                // WebAudio unlock failed
            }

            audioInitialized = true;
        }

        // SEå†ç”Ÿç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆWeb Audio APIç‰ˆï¼‰
        const audioBufferCache = {};  // ãƒ‡ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ãƒãƒƒãƒ•ã‚¡ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥

        async function loadAudioBuffer(filename) {
            if (audioBufferCache[filename]) {
                return audioBufferCache[filename];
            }
            try {
                const response = await fetch(`se/${filename}`);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBufferCache[filename] = audioBuffer;
                return audioBuffer;
            } catch (e) {
                return null;
            }
        }

        function playAudioBuffer(buffer, volume, loop = false) {
            if (!buffer || !audioCtx) return null;
            const source = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();
            source.buffer = buffer;
            source.loop = loop;
            gainNode.gain.value = volume;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
            return { source, gainNode };
        }

        function playSE(filename) {
            if (!seEnabled || !audioCtx) return;

            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚ã‚Œã°å³å†ç”Ÿã€ãªã‘ã‚Œã°ãƒ­ãƒ¼ãƒ‰ã—ã¦å†ç”Ÿ
            if (audioBufferCache[filename]) {
                playAudioBuffer(audioBufferCache[filename], seVolume);
            } else {
                loadAudioBuffer(filename).then(buffer => {
                    if (buffer) {
                        playAudioBuffer(buffer, seVolume);
                    }
                });
            }
        }

        // åŸºæœ¬çš„ãªéŸ³ã‚’ç”Ÿæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
        function createOscillator(type, frequency, duration, volume = seVolume * 0.6) {
            if (!audioCtx || !seEnabled) return null;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain).connect(audioCtx.destination);
            return { osc, gain };
        }

        // SEå®šç¾©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆmp3å„ªå…ˆã€ãªã‘ã‚Œã°ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰
        const SE = {
            // æˆ¦é—˜ç³»ï¼ˆmp3ã‚ã‚Šï¼‰
            attack: function() {
                playSE('battle-attack.mp3');
            },
            critical: function() {
                playSE('battle-attack-critical.mp3');
            },
            damage: function() {
                playSE('battle-damage.mp3');
            },
            miss: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('sine', 400, 0.15, seVolume * 0.3);
                if (osc) {
                    osc.osc.frequency.exponentialRampToValueAtTime(200, t + 0.15);
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.15);
                }
            },

            // å‘ªæ–‡ç³»ï¼ˆmp3ã‚ã‚Šï¼‰
            magicAttack: function() {
                playSE('battle-spell-attack.mp3');
            },
            heal: function() {
                playSE('battle-spell-cure.mp3');
            },
            buff: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const notes = [440, 554, 659, 880];
                notes.forEach((freq, i) => {
                    const osc = createOscillator('triangle', freq, 0.2, seVolume * 0.4);
                    if (osc) {
                        osc.osc.start(t + i * 0.06);
                        osc.osc.stop(t + i * 0.06 + 0.2);
                    }
                });
            },
            debuff: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('triangle', 600, 0.25, seVolume * 0.4);
                if (osc) {
                    osc.osc.frequency.exponentialRampToValueAtTime(200, t + 0.25);
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.25);
                }
            },

            // çµæœç³»
            victory: function() {
                playSE('battle-victory-intro.mp3');
            },
            defeat: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const melody = [
                    { freq: 392, time: 0, dur: 0.3 },
                    { freq: 349, time: 0.3, dur: 0.3 },
                    { freq: 294, time: 0.6, dur: 0.5 }
                ];
                melody.forEach(note => {
                    const osc = createOscillator('triangle', note.freq, note.dur, seVolume * 0.4);
                    if (osc) {
                        osc.osc.start(t + note.time);
                        osc.osc.stop(t + note.time + note.dur);
                    }
                });
            },
            escape: function() {
                playSE('battle-escape.mp3');
            },

            // UIç³»ï¼ˆmp3ãªã—ï¼‰
            cursor: function() {
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('square', 880, 0.05, seVolume * 0.2);
                if (osc) {
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.05);
                }
            },
            confirm: function() {
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc1 = createOscillator('square', 880, 0.08, seVolume * 0.3);
                if (osc1) {
                    osc1.osc.start(t);
                    osc1.osc.stop(t + 0.08);
                }
                const osc2 = createOscillator('square', 1320, 0.1, seVolume * 0.3);
                if (osc2) {
                    osc2.osc.start(t + 0.08);
                    osc2.osc.stop(t + 0.18);
                }
            },
            cancel: function() {
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('square', 440, 0.1, seVolume * 0.3);
                if (osc) {
                    osc.osc.frequency.exponentialRampToValueAtTime(220, t + 0.1);
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.1);
                }
            },

            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç³»
            chest: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const melody = [
                    { freq: 392, time: 0, dur: 0.15 },
                    { freq: 494, time: 0.12, dur: 0.15 },
                    { freq: 587, time: 0.24, dur: 0.15 },
                    { freq: 784, time: 0.36, dur: 0.4 }
                ];
                melody.forEach(note => {
                    const osc = createOscillator('square', note.freq, note.dur, seVolume * 0.35);
                    if (osc) {
                        osc.osc.start(t + note.time);
                        osc.osc.stop(t + note.time + note.dur);
                    }
                });
            },
            levelUp: function() {
                playSE('levelup.mp3');
            },
            stairs: function() {
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('triangle', 440, 0.15, seVolume * 0.3);
                if (osc) {
                    osc.osc.frequency.exponentialRampToValueAtTime(660, t + 0.15);
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.15);
                }
            },
            door: function() {
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc = createOscillator('sawtooth', 100, 0.25, seVolume * 0.2);
                if (osc) {
                    osc.osc.frequency.setValueAtTime(100, t);
                    osc.osc.frequency.linearRampToValueAtTime(150, t + 0.1);
                    osc.osc.frequency.linearRampToValueAtTime(80, t + 0.25);
                    osc.osc.start(t);
                    osc.osc.stop(t + 0.25);
                }
            },
            encounter: function() {
                playSE('encounter.mp3');
            },
            save: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const notes = [523, 659, 784];
                notes.forEach((freq, i) => {
                    const osc = createOscillator('sine', freq, 0.25, seVolume * 0.3);
                    if (osc) {
                        osc.osc.start(t + i * 0.1);
                        osc.osc.stop(t + i * 0.1 + 0.25);
                    }
                });
            },
            inn: function() {
                playSE('inn.mp3');
            },
            buy: function() {
                // mp3ãªã—ï¼šã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
                if (!audioCtx || !seEnabled) return;
                const t = audioCtx.currentTime;
                const osc1 = createOscillator('triangle', 1200, 0.08, seVolume * 0.35);
                if (osc1) {
                    osc1.osc.start(t);
                    osc1.osc.stop(t + 0.08);
                }
                const osc2 = createOscillator('triangle', 1600, 0.1, seVolume * 0.3);
                if (osc2) {
                    osc2.osc.start(t + 0.05);
                    osc2.osc.stop(t + 0.15);
                }
            },
            revive: function() {
                // å›å¾©éŸ³ã‚’æµç”¨
                playSE('battle-spell-cure.mp3');
            }
        };

        // ========================================
        // BGMã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        const BGM = {
            current: null,
            currentType: null,
            fadingOut: false,

            // BGMã‚¿ã‚¤ãƒ—ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒãƒ”ãƒ³ã‚°
            files: {
                title: 'title.mp3',
                field: 'field.mp3',
                town: 'town.mp3',
                castle: 'castle.mp3',
                dungeon: 'dungeon.mp3',
                bossDungeon: 'boss-dungeon.mp3',
                battle: 'battle.mp3',
                bossBattle: 'boss-battle.mp3',
                victory: 'battle-victory.mp3',
                ending: 'ending.mp3'
            },

            // Web Audio APIç”¨ã®çŠ¶æ…‹ç®¡ç†
            source: null,
            gainNode: null,
            buffer: null,
            startTime: 0,
            pauseTime: 0,
            isPlaying: false,

            play: function(type) {
                if (!bgmEnabled || !audioCtx) return;
                if (this.currentType === type && this.isPlaying) return;

                this.stop();

                const file = this.files[type];
                if (!file) return;

                this.currentType = type;

                // ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦å†ç”Ÿ
                loadAudioBuffer(file).then(buffer => {
                    if (buffer && this.currentType === type) {
                        this.buffer = buffer;
                        this._startPlayback(0);
                    }
                }).catch(e => {});
            },

            _startPlayback: function(offset) {
                if (!this.buffer || !audioCtx) return;

                this.source = audioCtx.createBufferSource();
                this.gainNode = audioCtx.createGain();
                this.source.buffer = this.buffer;
                this.source.loop = true;
                this.gainNode.gain.value = bgmVolume;
                this.source.connect(this.gainNode);
                this.gainNode.connect(audioCtx.destination);
                this.source.start(0, offset);
                this.startTime = audioCtx.currentTime - offset;
                this.isPlaying = true;
            },

            stop: function() {
                if (this.source) {
                    try { this.source.stop(); } catch(e) {}
                    this.source = null;
                }
                this.gainNode = null;
                this.buffer = null;
                this.currentType = null;
                this.isPlaying = false;
                this.pauseTime = 0;
            },

            pause: function() {
                if (this.source && this.isPlaying) {
                    this.pauseTime = (audioCtx.currentTime - this.startTime) % this.buffer.duration;
                    try { this.source.stop(); } catch(e) {}
                    this.source = null;
                    this.isPlaying = false;
                }
            },

            resume: function() {
                if (this.buffer && !this.isPlaying && bgmEnabled) {
                    this._startPlayback(this.pauseTime);
                }
            },

            setVolume: function(vol) {
                bgmVolume = vol;
                if (this.gainNode) {
                    this.gainNode.gain.value = vol;
                }
            },

            // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã‹ã‚‰BGMã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            getBgmTypeForMap: function(mapData) {
                if (!mapData) return 'field';
                const mapType = mapData.type;

                // ãƒœã‚¹ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³åˆ¤å®šï¼ˆç‰¹å®šã®ãƒãƒƒãƒ—IDï¼‰
                if (mapData.mapId && (
                    mapData.mapId.includes('maou') ||
                    mapData.mapId.includes('boss') ||
                    mapData.mapId === 'area3_castle_b2'
                )) {
                    return 'bossDungeon';
                }

                switch (mapType) {
                    case 'field': return 'field';
                    case 'town': return 'town';
                    case 'castle': return 'castle';
                    case 'dungeon': return 'dungeon';
                    default: return 'field';
                }
            }
        };

        // ã‚µã‚¦ãƒ³ãƒ‰ãƒˆã‚°ãƒ«æ©Ÿèƒ½
        function toggleSound() {
            soundEnabled = !soundEnabled;
            seEnabled = soundEnabled;
            bgmEnabled = soundEnabled;

            // localStorageã«ä¿å­˜
            localStorage.setItem(SOUND_SETTING_KEY, soundEnabled);

            // ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
            updateSoundToggleIcon();

            // BGMåˆ¶å¾¡
            if (soundEnabled) {
                // ONã«ã—ãŸå ´åˆã€ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ãªã‚‰ã‚¿ã‚¤ãƒˆãƒ«BGMã‚’å†ç”Ÿ
                const titleScreen = document.getElementById('titleScreen');
                if (titleScreen && !titleScreen.classList.contains('hidden')) {
                    BGM.play('title');
                }
            } else {
                // OFFã«ã—ãŸå ´åˆã€BGMåœæ­¢
                BGM.stop();
            }
        }

        function updateSoundToggleIcon() {
            const toggleBtn = document.getElementById('soundToggle');
            if (toggleBtn) {
                toggleBtn.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
                toggleBtn.classList.toggle('muted', !soundEnabled);
            }
        }

        // ========================================
        // ã‚²ãƒ¼ãƒ é€²è¡Œãƒ•ãƒ©ã‚°ç®¡ç†
        // ========================================
        const gameProgress = {
            // ãƒœã‚¹æ’ƒç ´ãƒ•ãƒ©ã‚°
            bossDefeated: {
                midBoss: false,     // ä¸­ãƒœã‚¹ï¼ˆæ´çªŸã®ç•ªäººï¼‰
                maou: false,        // é­”ç‹
                // ã‚¨ãƒªã‚¢2ãƒœã‚¹
                quicksandBoss: false,    // æµç ‚ã®ä¸»
                banditKing: false,       // ç›—è³Šç‹
                pyramidGuardian: false,  // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã®å®ˆè­·è€…
                desertGuardian: false,   // ç ‚æ¼ ã®å®ˆè­·è€…ï¼ˆåŸã®ä¸­ãƒœã‚¹ï¼‰
                // ã‚¨ãƒªã‚¢3ãƒœã‚¹
                shadowGuardian: false,   // é—‡ã®å®ˆè­·è€…ï¼ˆå¤åŸã®æœ€çµ‚ãƒœã‚¹ï¼‰
                wedgeGuardian_north: false, // åŒ—ã®æ¥”å®ˆè­·è€…
                wedgeGuardian_east: false,  // æ±ã®æ¥”å®ˆè­·è€…
                wedgeGuardian_south: false, // å—ã®æ¥”å®ˆè­·è€…
                wedgeGuardian_west: false,  // è¥¿ã®æ¥”å®ˆè­·è€…
                libraryGuardian: false,     // å›³æ›¸å®¤ã®å®ˆè­·è€…
                // ã‚¨ãƒªã‚¢4ãƒœã‚¹
                iceGolem: false,            // æ°·ã®ã‚´ãƒ¼ãƒ¬ãƒ ï¼ˆä¸­ãƒœã‚¹ï¼‰
                iceQueen: false             // æ°·ã®å¥³ç‹ï¼ˆã‚¨ãƒªã‚¢ãƒœã‚¹ï¼‰
            },
            // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼é€²è¡Œãƒ•ãƒ©ã‚°
            storyFlags: {
                reportedMidBossDefeat: false,  // ä¸­ãƒœã‚¹æ’ƒç ´ã‚’ç‹æ§˜ã«å ±å‘Š
                portalRoomUnlocked: false,     // æ—…ã®æ‰‰ã®éƒ¨å±‹ã¸ã®é€šè¡Œè¨±å¯
                bazaarUnlocked: false,         // ãƒã‚¶ãƒ¼ãƒ«ã®ç”ºã¸ã®é€šè¡Œè¨±å¯
                desertPortalUnlocked: false,   // ç ‚æ¼ ã®æ—…ã®æ‰‰é–‹æ”¾
                desertCastleUnlocked: false,   // å¤ªé™½ã®åŸå¡ã¸ã®é€šè¡Œè¨±å¯
                mageJoined: false,             // é­”æ³•ä½¿ã„ãŒä»²é–“ã«ãªã£ãŸ
                serenJoined: false,            // æ˜Ÿèª­ã¿ã‚»ãƒ¬ãƒ³ãŒä»²é–“ã«ãªã£ãŸ
                ancientCastleUnlocked: false,  // å¤åŸæœ€ä¸ŠéšãŒé–‹æ”¾ã•ã‚ŒãŸ
                area3Entered: false,           // ã‚¨ãƒªã‚¢3ã«å…¥ã£ãŸï¼ˆãƒ«ãƒ¼ãƒ©åˆ¶é™åˆ¤å®šç”¨ï¼‰
                area3SealActivated: false,     // å°å°ãŒç™ºå‹•ã—ãŸ
                shadowGuardianDefeated: false, // é—˜ã®å®ˆè­·è€…ã‚’æ’ƒç ´ã—ãŸ
                area3Completed: false,         // ã‚¨ãƒªã‚¢3ã‚’ã‚¯ãƒªã‚¢ã—ãŸ
                ancientSpellReceived: false,   // å¤ä»£å‘ªæ–‡ã‚¶ã‚ªãƒªã‚¯ã‚’æˆã‹ã£ãŸ
                // ã‚¨ãƒªã‚¢4ãƒ•ãƒ©ã‚°
                northPathOpened: false,        // åŒ—ã®å±±é“é–‹é€š
                area4Entered: false,           // ã‚¨ãƒªã‚¢4ã«å…¥ã£ãŸ
                iceGolemDefeated: false,       // æ°·ã®ã‚´ãƒ¼ãƒ¬ãƒ æ’ƒç ´
                frozenLakeCleared: false,      // å‡ã‚Šã¤ã„ãŸæ¹–ã‚¯ãƒªã‚¢
                torchPuzzleCleared: false,     // ç¯ç«ãƒ‘ã‚ºãƒ«ã‚¯ãƒªã‚¢
                memoryPuzzleCleared: false,    // è¨˜æ†¶ãƒ‘ã‚ºãƒ«ã‚¯ãƒªã‚¢
                sunFlameObtained: false,       // å¤ªé™½ã®ç‚å…¥æ‰‹
                glacioJoined: false,           // ã‚°ãƒ©ã‚·ã‚ªåŠ å…¥
                iceQueenDefeated: false,       // æ°·ã®å¥³ç‹æ’ƒç ´
                area4Completed: false,         // ã‚¨ãƒªã‚¢4ã‚¯ãƒªã‚¢
                auroraOrbObtained: false       // æ¥µå…‰ã®å®ç å…¥æ‰‹
            },
            // ã‚¯ã‚¨ã‚¹ãƒˆãƒ•ãƒ©ã‚°ï¼ˆã‚¨ãƒªã‚¢2ï¼‰
            quests: {
                // æ°´ä¸è¶³ã®è§£æ¶ˆã‚¯ã‚¨ã‚¹ãƒˆ
                waterShortage: {
                    started: false,      // ã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹
                    bossDefeated: false, // æµç ‚ã®ä¸»ã‚’å€’ã—ãŸ
                    itemObtained: false, // æ¸…ã‚‰ã‹ãªæ°´ã‚’å…¥æ‰‹
                    completed: false     // æ‘é•·ã«æ¸¡ã—ã¦å®Œäº†
                },
                // é€šè¡Œæ‰‹å½¢ã®å¥ªé‚„ã‚¯ã‚¨ã‚¹ãƒˆ
                passportRecovery: {
                    started: false,      // ã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹
                    bossDefeated: false, // ç›—è³Šç‹ã‚’å€’ã—ãŸ
                    completed: false     // ãƒã‚¶ãƒ¼ãƒ«ã«å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã£ãŸ
                },
                // ç‹å®¶ã®ç´‹ç« ã‚¯ã‚¨ã‚¹ãƒˆ
                royalCrest: {
                    started: false,      // ã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹
                    bossDefeated: false, // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã®å®ˆè­·è€…ã‚’å€’ã—ãŸ
                    itemObtained: false, // ç´‹ç« ã‚’å…¥æ‰‹
                    completed: false     // åŸã®é–€ãŒé–‹ã„ãŸ
                },
                // ã‚»ãƒ¬ãƒ³åŠ å…¥ã‚¯ã‚¨ã‚¹ãƒˆ
                serenJoin: {
                    stage1_met: false,        // åˆå›é­é‡
                    stage2_helped: false,     // ã‚¯ã‚¨ã‚¹ãƒˆå—æ³¨
                    stage3_completed: false,  // æ¡ä»¶é”æˆ
                    joined: false             // åŠ å…¥å®Œäº†
                },
                // ã‚°ãƒ©ã‚·ã‚ªåŠ å…¥ã‚¯ã‚¨ã‚¹ãƒˆ
                glacioJoin: {
                    met: false,               // æ°·çµé¨å£«ã¨é­é‡
                    iceGolemDefeated: false,  // æ°·ã®ã‚´ãƒ¼ãƒ¬ãƒ æ’ƒç ´ã§è§£æ”¾
                    joined: false             // åŠ å…¥å®Œäº†
                },
                // æ¥”ã‚¯ã‚¨ã‚¹ãƒˆ
                wedges: {
                    wedge_north: false,  // åŒ—ã®æ¥”
                    wedge_east: false,   // æ±ã®æ¥”
                    wedge_south: false,  // å—ã®æ¥”
                    wedge_west: false,   // è¥¿ã®æ¥”
                    allCollected: false  // å…¨åé›†å®Œäº†
                }
            },
            // ã‚¨ãƒªã‚¢åˆ¥é€²è¡ŒçŠ¶æ…‹
            areas: {},
            // ç™ºè¦‹æ¸ˆã¿éš ã—é€šè·¯ï¼ˆãƒãƒƒãƒ—ID -> åº§æ¨™é…åˆ—ï¼‰
            openedPassages: {},
            // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šè¨ªå•æ¸ˆã¿æ‹ ç‚¹ãƒªã‚¹ãƒˆ
            visitedLocations: [],
            // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é€²å…¥ç›´å‰ã®ä½ç½®
            lastEntrance: null
        };

        // ãƒ•ãƒ©ã‚°æ“ä½œãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function setStoryFlag(flagName, value = true) {
            if (gameProgress.storyFlags.hasOwnProperty(flagName)) {
                gameProgress.storyFlags[flagName] = value;
            }
        }

        function getStoryFlag(flagName) {
            return gameProgress.storyFlags[flagName] || false;
        }

        function setBossDefeated(bossName, value = true) {
            if (gameProgress.bossDefeated.hasOwnProperty(bossName)) {
                gameProgress.bossDefeated[bossName] = value;
                // é­”ç‹æ’ƒç ´ã¯æ—¢å­˜ãƒ•ãƒ©ã‚°ã¨é€£å‹•
                if (bossName === 'maou') {
                    gameCleared = value;
                }
            }
        }

        function isBossDefeated(bossName) {
            return gameProgress.bossDefeated[bossName] || false;
        }

        function resetGameProgress() {
            gameProgress.bossDefeated.midBoss = false;
            gameProgress.bossDefeated.maou = false;
            gameProgress.bossDefeated.quicksandBoss = false;
            gameProgress.bossDefeated.banditKing = false;
            gameProgress.bossDefeated.pyramidGuardian = false;
            gameProgress.bossDefeated.desertGuardian = false;
            gameProgress.bossDefeated.shadowGuardian = false;
            gameProgress.bossDefeated.wedgeGuardian_north = false;
            gameProgress.bossDefeated.wedgeGuardian_east = false;
            gameProgress.bossDefeated.wedgeGuardian_south = false;
            gameProgress.bossDefeated.wedgeGuardian_west = false;
            gameProgress.bossDefeated.libraryGuardian = false;
            gameProgress.storyFlags.reportedMidBossDefeat = false;
            gameProgress.storyFlags.portalRoomUnlocked = false;
            gameProgress.storyFlags.mageJoined = false;
            gameProgress.storyFlags.ancientCastleUnlocked = false;
            gameProgress.storyFlags.area3Entered = false;
            gameProgress.storyFlags.area3SealActivated = false;
            gameProgress.storyFlags.shadowGuardianDefeated = false;
            gameProgress.storyFlags.area3Completed = false;
            gameProgress.storyFlags.ancientSpellReceived = false;
            // ã‚¨ãƒªã‚¢4ãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ
            gameProgress.bossDefeated.iceGolem = false;
            gameProgress.bossDefeated.iceQueen = false;
            gameProgress.storyFlags.northPathOpened = false;
            gameProgress.storyFlags.area4Entered = false;
            gameProgress.storyFlags.iceGolemDefeated = false;
            gameProgress.storyFlags.frozenLakeCleared = false;
            gameProgress.storyFlags.torchPuzzleCleared = false;
            gameProgress.storyFlags.memoryPuzzleCleared = false;
            gameProgress.storyFlags.sunFlameObtained = false;
            gameProgress.storyFlags.glacioJoined = false;
            gameProgress.storyFlags.iceQueenDefeated = false;
            gameProgress.storyFlags.area4Completed = false;
            gameProgress.storyFlags.auroraOrbObtained = false;
            // ã‚¯ã‚¨ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆ
            Object.keys(gameProgress.quests).forEach(questName => {
                Object.keys(gameProgress.quests[questName]).forEach(flag => {
                    gameProgress.quests[questName][flag] = false;
                });
            });
            gameProgress.areas = {};
            gameProgress.openedPassages = {};
        }

        // éš ã—é€šè·¯æ“ä½œãƒ˜ãƒ«ãƒ‘ãƒ¼
        function isPassageOpened(mapId, x, y) {
            const passages = gameProgress.openedPassages[mapId];
            if (!passages) return false;
            return passages.some(p => p.x === x && p.y === y);
        }

        function openPassage(mapId, x, y) {
            if (!gameProgress.openedPassages[mapId]) {
                gameProgress.openedPassages[mapId] = [];
            }
            if (!isPassageOpened(mapId, x, y)) {
                gameProgress.openedPassages[mapId].push({ x, y });
            }
        }

        // ãƒãƒƒãƒ—èª­ã¿è¾¼ã¿æ™‚ã«ç™ºè¦‹æ¸ˆã¿éš ã—é€šè·¯ã‚’é©ç”¨
        function applyOpenedPassages(mapData) {
            const mapId = mapData.mapId;
            const passages = gameProgress.openedPassages[mapId];
            if (!passages || !mapData.data) return;

            passages.forEach(p => {
                if (mapData.data[p.y] && mapData.data[p.y][p.x] === TILE.HIDDEN_WALL) {
                    mapData.data[p.y][p.x] = TILE.FLOOR;
                }
            });
        }

        // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šè¨ªå•æ¸ˆã¿æ‹ ç‚¹ã®ç™»éŒ²
        function registerVisitedLocation(mapData) {
            if (!mapData.isSettlement) return;

            // æ—¢ã«ç™»éŒ²æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
            const exists = gameProgress.visitedLocations.some(loc => loc.mapId === mapData.mapId);
            if (exists) return;

            // æ‹ ç‚¹ã‚’ç™»éŒ²ï¼ˆã‚¨ãƒªã‚¢æƒ…å ±ã‚‚ä¿å­˜ï¼‰
            gameProgress.visitedLocations.push({
                mapId: mapData.mapId,
                displayName: mapData.name,
                area: mapData.area || 'area1',
                arrivalX: mapData.arrivalX || 0,
                arrivalY: mapData.arrivalY || 0
            });
        }

        // ãƒ«ãƒ¼ãƒ©ã§ç§»å‹•å¯èƒ½ãªæ‹ ç‚¹ã‚’å–å¾—ï¼ˆã‚¨ãƒªã‚¢åˆ¶é™å¯¾å¿œï¼‰
        function getAvailableRuraLocations() {
            // ã‚¨ãƒªã‚¢3ã«ã„ã‚‹å ´åˆã€ã‚¨ãƒªã‚¢3ã®æ‹ ç‚¹ã®ã¿è¿”ã™
            if (currentMap.area === 'area3') {
                return gameProgress.visitedLocations.filter(loc => loc.area === 'area3');
            }
            // ãã‚Œä»¥å¤–ã¯å…¨æ‹ ç‚¹ï¼ˆã‚¨ãƒªã‚¢3ä»¥å¤–ï¼‰
            return gameProgress.visitedLocations.filter(loc => loc.area !== 'area3');
        }

        // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é€²å…¥å‰ã®ä½ç½®ã‚’è¨˜æ†¶
        function recordDungeonEntrance(prevMapData, prevX, prevY, prevMapPath) {
            // å±‹å¤–ã‹ã‚‰å±‹å†…/ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã¸ç§»å‹•ã—ãŸå ´åˆã®ã¿è¨˜æ†¶
            if (prevMapData && prevMapData.isOutdoor === true) {
                gameProgress.lastEntrance = {
                    mapId: prevMapData.mapId,
                    mapPath: prevMapPath,
                    x: prevX,
                    y: prevY,
                    name: prevMapData.name
                };
            }
        }

        // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å…¥å£æƒ…å ±ã‚’å–å¾—
        function getLastEntrance() {
            return gameProgress.lastEntrance;
        }

        // ç¾åœ¨ã®ãƒãƒƒãƒ—ãŒå±‹å¤–ã‹ã©ã†ã‹
        function isCurrentMapOutdoor() {
            return currentMap && currentMap.isOutdoor === true;
        }

        // ã‚¯ã‚¨ã‚¹ãƒˆãƒ•ãƒ©ã‚°æ“ä½œ
        function setQuestFlag(questName, flagName, value = true) {
            if (gameProgress.quests[questName] && gameProgress.quests[questName].hasOwnProperty(flagName)) {
                gameProgress.quests[questName][flagName] = value;
            }
        }

        function getQuestFlag(questName, flagName) {
            if (gameProgress.quests[questName]) {
                return gameProgress.quests[questName][flagName] || false;
            }
            return false;
        }

        function isQuestCompleted(questName) {
            return getQuestFlag(questName, 'completed');
        }

        function areAllDesertQuestsCompleted() {
            const allCompleted = isQuestCompleted('waterShortage') &&
                   isQuestCompleted('passportRecovery') &&
                   isQuestCompleted('royalCrest');
            // å…¨ã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†æ™‚ã«ç ‚æ¼ ã®åŸã‚’é–‹æ”¾
            if (allCompleted && !getStoryFlag('desertCastleUnlocked')) {
                setStoryFlag('desertCastleUnlocked', true);
                saveGame();
            }
            return allCompleted;
        }

        // ========================================
        // ãƒãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå¤–éƒ¨JSONãƒ•ã‚¡ã‚¤ãƒ«é€£æºï¼‰
        // ========================================

        // ç¾åœ¨ã®ãƒãƒƒãƒ—ãƒ‘ã‚¹ã‚’ä¿æŒ
        let currentMapPath = 'maps/castle.json';

        // ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹
        let mapLoadState = {
            loading: false,
            fadeAlpha: 0,
            targetMapPath: null,
            targetX: 0,
            targetY: 0
        };

        // ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãƒãƒƒãƒ—ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const maps = {
            field: {
                mapId: 'field',
                name: 'ãƒ«ãƒŸãƒŠã‚¹å¤§é™¸',
                type: 'field',
                cols: 20,
                rows: 20,
                encounterRate: 0.08,
                isSafe: false,
                data: [
                    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                    [2,2,2,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,2,2],
                    [2,2,0,0,0,0,0,0,0,2,2,0,0,0,0,1,1,0,0,2],
                    [2,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,2],
                    [2,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,2],
                    [2,0,0,0,1,1,0,0,0,3,0,0,0,0,0,0,0,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
                    [2,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,5,0,0,2],
                    [2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
                    [2,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,2],
                    [2,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,2],
                    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
                    [2,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2],
                    [2,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,2,2],
                    [2,2,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,2,2,2],
                    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
                ],
                warps: [
                    { x: 9, y: 5, targetMap: 'maps/castle.json', targetX: 7, targetY: 12 },
                    { x: 4, y: 10, targetMap: 'maps/town.json', targetX: 7, targetY: 13 },
                    { x: 16, y: 10, targetMap: 'maps/dungeon.json', targetX: 1, targetY: 1 }
                ],
                npcs: [],
                chests: []
            },
            castle: {
                mapId: 'castle',
                name: 'ã‚°ãƒ©ãƒ³ãƒ‡ã‚£ã‚¢åŸ',
                type: 'castle',
                cols: 15,
                rows: 15,
                encounterRate: 0,
                isSafe: true,
                data: [
                    [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,7,7,7,6,6,6,7,7,7,6,6,7],
                    [7,6,6,7,6,6,6,6,6,6,6,7,6,6,7],
                    [7,6,6,7,6,6,6,6,6,6,6,7,6,6,7],
                    [7,6,6,7,6,6,6,6,6,6,6,7,6,6,7],
                    [7,6,6,7,7,6,6,6,6,6,7,7,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,5,6,6,6,6,6,6,7],
                    [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],
                    [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]
                ],
                warps: [
                    { x: 7, y: 12, targetMap: 'maps/field.json', targetX: 9, targetY: 6 }
                ],
                npcs: [
                    { id: 'king', x: 7, y: 2, sprite: 'ğŸ‘‘', type: 'king', messages: ['ãŠãŠã€å‹‡è€…ã‚ˆï¼', 'ã‚ˆããå‚ã£ãŸã€‚', 'é­”ç‹ãŒä¸–ç•Œã‚’é—˜ã§è¦†ãŠã†ã¨ã—ã¦ãŠã‚‹ã€‚', 'ã©ã†ã‹ä¸–ç•Œã‚’æ•‘ã£ã¦ãã‚Œï¼', 'æ±ã®æ´çªŸã«ã»ã®ãŠã®ã¤ã‚‹ããŒã‚ã‚‹ã¨ã„ã†ã€‚', 'æ—…ç«‹ã¤ãŒã‚ˆã„ï¼'], clearedMessages: ['ãŠãŠã€å‹‡è€…ã‚ˆï¼', 'ã‚ˆããé­”ç‹ã‚’å€’ã—ã¦ãã‚ŒãŸï¼', 'ã“ã‚Œã§ä¸–ç•Œã«å¹³å’ŒãŒæˆ»ã£ãŸã€‚', 'ããªãŸã¯çœŸã®è‹±é›„ã˜ã‚ƒï¼'] },
                    { id: 'guard1', x: 3, y: 10, sprite: 'ğŸ’‚', type: 'guard', messages: ['ç‹æ§˜ã‚’ãŠå®ˆã‚Šã™ã‚‹ã®ãŒ', 'æˆ‘ã€…ã®å‹™ã‚ã§ã™ã€‚'], clearedMessages: ['å‹‡è€…æ§˜ï¼', 'ã‚ãªãŸã®ãŠã‹ã’ã§å¹³å’Œã«ãªã‚Šã¾ã—ãŸï¼'] },
                    { id: 'guard2', x: 11, y: 10, sprite: 'ğŸ’‚', type: 'guard', messages: ['ã“ã®åŸã¯å®‰å…¨ã§ã™ã€‚', 'ã”å®‰å¿ƒãã ã•ã„ã€‚'], clearedMessages: ['é­”ç‹ãŒå€’ã•ã‚ŒãŸã¨èãã¾ã—ãŸï¼', 'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€å‹‡è€…æ§˜ï¼'] }
                ],
                chests: [
                    { id: 'castle_chest1', x: 4, y: 5, itemId: 8, isOpened: false }
                ]
            },
            town: {
                mapId: 'town',
                name: 'ã‚¢ãƒ«ã‚«ãƒ‡ã‚£ã‚¢ã®è¡—',
                type: 'town',
                cols: 15,
                rows: 15,
                encounterRate: 0,
                isSafe: true,
                data: [
                    [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,7,7,6,6,6,6,6,6,6,7,7,6,7],
                    [7,6,7,7,6,6,6,6,6,6,6,7,7,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,7,7,7,6,6,6,6,6,7],
                    [7,6,6,6,6,6,7,7,7,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,7,7,6,6,6,6,6,6,6,7,7,6,7],
                    [7,6,7,7,6,6,6,6,6,6,6,7,7,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,5,6,6,6,6,6,6,7],
                    [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]
                ],
                warps: [
                    { x: 7, y: 13, targetMap: 'maps/field.json', targetX: 4, targetY: 11 }
                ],
                npcs: [
                    { id: 'villager1', x: 5, y: 4, sprite: 'ğŸ‘¨', type: 'villager', messages: ['ã‚ˆã†ã“ãæˆ‘ãŒè¡—ã¸ï¼', 'æ±ã®æ´çªŸã«ã¯é­”ç‰©ãŒã„ã‚‹ã‚‰ã—ã„ã€‚', 'æ°—ã‚’ã¤ã‘ã¦ãªã€‚'], clearedMessages: ['å¹³å’Œã«ãªã£ãŸãªã‚ï¼', 'ã“ã‚Œã‚‚ã‚ã‚“ãŸã®ãŠã‹ã’ã ï¼', 'ã‚ã‚ŠãŒã¨ã†ã€å‹‡è€…ã•ã¾ï¼'] },
                    { id: 'villager2', x: 10, y: 4, sprite: 'ğŸ‘©', type: 'villager', messages: ['ã‚ã‚‰ã€æ—…ã®æ–¹ï¼Ÿ', 'åŸã®ç‹æ§˜ã«ä¼šã„ã¾ã—ãŸã‹ï¼Ÿ', 'å¤§åˆ‡ãªè©±ãŒã‚ã‚‹ãã†ã§ã™ã‚ˆã€‚'], clearedMessages: ['ã‚ã‚‰ã€å‹‡è€…æ§˜ï¼', 'é­”ç‹ã‚’å€’ã—ãŸã£ã¦æœ¬å½“ï¼Ÿ', 'ã™ã”ã„ã‚ï¼ã‚ã‚ŠãŒã¨ã†ï¼'] },
                    { id: 'innkeeper', x: 12, y: 2, sprite: 'ğŸ¨', type: 'inn', innCost: 10, messages: [] },
                    { id: 'shopkeeper', x: 2, y: 2, sprite: 'âš”ï¸', type: 'shop', messages: [] },
                    { id: 'child', x: 3, y: 11, sprite: 'ğŸ‘¦', type: 'villager', messages: ['ã­ãˆã­ãˆã€å‹‡è€…ã•ã‚“ï¼Ÿ', 'ã¼ãã‚‚å¤§ãããªã£ãŸã‚‰', 'å‹‡è€…ã«ãªã‚ŠãŸã„ãªï¼'], clearedMessages: ['ã‚ã‚ï¼æœ¬ç‰©ã®å‹‡è€…ã ï¼', 'é­”ç‹ã‚’å€’ã—ãŸã‚“ã§ã—ã‚‡ï¼Ÿ', 'ã‹ã£ã“ã„ã„ï½ï¼'] }
                ],
                chests: [
                    { id: 'town_chest1', x: 13, y: 1, itemId: 1, isOpened: false },
                    { id: 'town_chest2', x: 1, y: 12, itemId: 2, isOpened: false }
                ]
            },
            dungeon: {
                mapId: 'dungeon',
                name: 'ç¼ç†±ã®æ´çªŸ',
                type: 'dungeon',
                cols: 12,
                rows: 12,
                encounterRate: 0.12,
                isSafe: false,
                data: [
                    [7,7,7,7,7,7,7,7,7,7,7,7],
                    [7,5,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,7,7,7,6,6,7,7,6,7],
                    [7,6,6,7,6,6,6,6,6,7,6,7],
                    [7,6,6,7,6,7,7,7,6,7,6,7],
                    [7,6,6,6,6,6,6,6,6,6,5,7],
                    [7,7,7,7,6,7,7,7,6,6,6,7],
                    [7,6,6,6,6,6,6,7,6,7,6,7],
                    [7,6,7,7,7,7,6,7,6,7,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,6,7],
                    [7,7,7,7,7,7,7,7,7,7,7,7]
                ],
                warps: [
                    { x: 1, y: 1, targetMap: 'maps/field.json', targetX: 16, targetY: 11 },
                    { x: 10, y: 5, targetMap: 'maps/maou_room.json', targetX: 7, targetY: 12 }
                ],
                npcs: [
                    { id: 'hermit', x: 10, y: 10, sprite: 'ğŸ§™', type: 'hermit', messages: ['ã»ã»ã†ã€ã“ã“ã¾ã§æ¥ãŸã‹ã€‚', 'ã‚ã—ã¯æ˜”ã€å‹‡è€…ã ã£ãŸã€‚', 'ã“ã®å¥¥ã«ã»ã®ãŠã®ã¤ã‚‹ããŒã‚ã‚‹ã€‚', 'æ´çªŸã®ç•ªäººã‚’å€’ã™ã®ã«å¿…è¦ã˜ã‚ƒã€‚', 'å¿ƒã—ã¦é€²ã‚€ãŒã‚ˆã„ã€‚'] }
                ],
                chests: [
                    { id: 'dungeon_chest1', x: 4, y: 3, itemId: 1, isOpened: false },  // è–¬è‰
                    { id: 'dungeon_chest2', x: 1, y: 7, itemId: 14, isOpened: false }  // ã»ã®ãŠã®ã¤ã‚‹ã
                ]
            },
            maouRoom: {
                mapId: 'maouRoom',
                name: 'æš—é»’ã®ç‰åº§',
                type: 'dungeon',
                cols: 11,
                rows: 10,
                encounterRate: 0,
                isSafe: false,
                data: [
                    [7,7,7,7,7,7,7,7,7,7,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,6,6,6,6,6,7],
                    [7,6,6,6,6,5,6,6,6,6,7],
                    [7,7,7,7,7,7,7,7,7,7,7]
                ],
                warps: [
                    { x: 5, y: 8, targetMap: 'maps/dungeon.json', targetX: 23, targetY: 21 }
                ],
                npcs: [
                    { id: 'maou', x: 5, y: 2, sprite: 'ğŸ‘¿', type: 'maou', messages: [] }
                ],
                chests: []
            }
        };

        // ========================================
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        // ========================================
        let currentMapId = 'field';
        let currentMap = maps[currentMapId];
        let isTransitioning = false;

        // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 
        let stepsSinceLastBattle = 0;  // å‰å›ãƒãƒˆãƒ«å¾Œã‹ã‚‰ã®æ­©æ•°
        const SAFE_STEPS = 5;          // ä¸æ„Ÿåœ°å¸¯ï¼ˆã“ã®æ­©æ•°ã¾ã§ã¯ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„ï¼‰
        const ENCOUNTER_RATE_PER_STEP = 0.02;  // æ­©æ•°ã‚ãŸã‚Šã®ç¢ºç‡ä¸Šæ˜‡ç‡ï¼ˆ2%ï¼‰
        const MAX_ENCOUNTER_RATE = 0.95;       // æœ€å¤§ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆç‡

        // é€£ç¶šç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæŠ¼ã—ç¶šã‘ã¦ç§»å‹•ï¼‰
        let moveInterval = null;
        let currentMoveDirection = { dx: 0, dy: 0 };
        const CONTINUOUS_MOVE_DELAY = 150;  // é€£ç¶šç§»å‹•ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰

        // ========================================
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================

        // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createPartyMember(config) {
            return {
                // è­˜åˆ¥æƒ…å ±
                id: config.id || 'hero',
                name: config.name || 'ã‚†ã†ã—ã‚ƒ',
                job: config.job || 'hero',
                sprite: config.sprite || 'ğŸ§™',

                // HP/MP
                hp: config.hp || 50,
                maxHp: config.maxHp || 50,
                mp: config.mp || 20,
                maxMp: config.maxMp || 20,

                // åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
                baseAtk: config.baseAtk || 10,
                baseDef: config.baseDef || 5,
                speed: config.speed || 6,

                // ãƒ¬ãƒ™ãƒ«ãƒ»çµŒé¨“å€¤
                level: config.level || 1,
                exp: config.exp || 0,

                // å‘ªæ–‡
                spells: config.spells || [],

                // è£…å‚™
                equipment: config.equipment || {
                    weapon: null,
                    armor: null
                },

                // è¨ˆç®—æ¸ˆã¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
                actualAtk: config.baseAtk || 10,
                actualDef: config.baseDef || 5,

                // çŠ¶æ…‹ç•°å¸¸ï¼ˆæ®‹ã‚Šã‚¿ãƒ¼ãƒ³æ•°ï¼‰
                status: {
                    sleep: 0,
                    poison: 0,
                    blind: 0
                },

                // æˆ¦é—˜ä¸èƒ½ãƒ•ãƒ©ã‚°
                isAlive: true
            };
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£é…åˆ—ï¼ˆæœ€å¤§4äººï¼‰
        const MAX_PARTY_SIZE = 4;
        const party = [];

        // å‹‡è€…ï¼ˆåˆæœŸãƒ¡ãƒ³ãƒãƒ¼ï¼‰ã‚’ä½œæˆã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã«è¿½åŠ 
        party.push(createPartyMember({
            id: 'hero',
            name: 'ã‚†ã†ã—ã‚ƒ',
            job: 'hero',
            sprite: 'ğŸ¦¸',
            hp: 50,
            maxHp: 50,
            mp: 20,
            maxMp: 20,
            baseAtk: 10,
            baseDef: 5,
            speed: 6,
            level: 1,
            exp: 0,
            spells: ['hoimi', 'mera'],
            equipment: {
                weapon: 10,  // ã“ã‚“ã¼ã†
                armor: 20    // ãŸã³ã³ã¨ã®ãµã
            }
        }));

        // å¾Œæ–¹äº’æ›æ€§ï¼šplayerã¯å¸¸ã«party[0]ã‚’å‚ç…§
        // æ³¨æ„ï¼šplayerã‚’å†ä»£å…¥ã—ãªã„ã“ã¨ï¼ˆconstã§ã¯ãªãletã§å®£è¨€ã—ã€å‚ç…§ã‚’ç¶­æŒï¼‰
        let player = party[0];

        // ãƒ‘ãƒ¼ãƒ†ã‚£å…±æœ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆä½ç½®ã€ã‚´ãƒ¼ãƒ«ãƒ‰ã€ã‚¢ã‚¤ãƒ†ãƒ ï¼‰
        const partyData = {
            x: 3,
            y: 3,
            direction: 'down',
            moving: false,
            moveDelay: 120,
            gold: 0,
            inventory: []
        };

        // ä½ç½®æƒ…å ±ã¨ã‚´ãƒ¼ãƒ«ãƒ‰ãƒ»ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã¯partyDataã‚’ä½¿ç”¨
        // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚playerã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
        // æ³¨æ„: playerå†ä»£å…¥å¾Œã¯å¿…ãšã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨
        function setupPlayerProxy() {
            Object.defineProperties(player, {
                x: {
                    get: () => partyData.x,
                    set: (v) => { partyData.x = v; },
                    configurable: true
                },
                y: {
                    get: () => partyData.y,
                    set: (v) => { partyData.y = v; },
                    configurable: true
                },
                direction: {
                    get: () => partyData.direction,
                    set: (v) => { partyData.direction = v; },
                    configurable: true
                },
                moving: {
                    get: () => partyData.moving,
                    set: (v) => { partyData.moving = v; },
                    configurable: true
                },
                moveDelay: {
                    get: () => partyData.moveDelay,
                    set: (v) => { partyData.moveDelay = v; },
                    configurable: true
                },
                gold: {
                    get: () => partyData.gold,
                    set: (v) => { partyData.gold = v; },
                    configurable: true
                },
                inventory: {
                    get: () => partyData.inventory,
                    set: (v) => { partyData.inventory = v; },
                    configurable: true
                }
            });
        }

        // åˆæœŸåŒ–æ™‚ã«ãƒ—ãƒ­ã‚­ã‚·ã‚’è¨­å®š
        setupPlayerProxy();

        // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function getAlivePartyMembers() {
            return party.filter(m => m.isAlive && m.hp > 0);
        }

        function getPartyMember(index) {
            return party[index] || null;
        }

        function addPartyMember(config) {
            if (party.length >= MAX_PARTY_SIZE) {
                console.warn('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯æœ€å¤§4äººã¾ã§ã§ã™');
                return false;
            }
            const member = createPartyMember(config);
            updateMemberActualStats(member);
            party.push(member);
            return true;
        }

        function isPartyAlive() {
            return party.some(m => m.isAlive && m.hp > 0);
        }

        // æˆ¦é—˜ä¸èƒ½ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
        function getDeadPartyMembers() {
            return party.filter(m => !m.isAlive || m.hp <= 0);
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®HP/MPã‚’å…¨å›å¾©ã—ã€æˆ¦é—˜ä¸èƒ½ã‚‚å¾©æ´»ã•ã›ã‚‹
        function restoreAll() {
            party.forEach(member => {
                member.hp = member.maxHp;
                member.mp = member.maxMp;
                member.isAlive = true;
                member.status = { sleep: 0, poison: 0, blind: 0 };
            });
        }

        // ç‰¹å®šã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’å¾©æ´»ã•ã›ã‚‹ï¼ˆHPåŠåˆ†ã¾ãŸã¯å…¨å›å¾©ï¼‰
        function reviveMember(member, fullHp = false) {
            if (!member) return false;
            member.hp = fullHp ? member.maxHp : Math.floor(member.maxHp / 2);
            member.isAlive = true;
            member.status = { sleep: 0, poison: 0, blind: 0 };
            return true;
        }

        // ãƒ¡ãƒ³ãƒãƒ¼å€‹åˆ¥ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        function updateMemberActualStats(member) {
            const weapon = items[member.equipment.weapon];
            const armor = items[member.equipment.armor];
            member.actualAtk = member.baseAtk + (weapon ? weapon.value : 0);
            member.actualDef = member.baseDef + (armor ? armor.value : 0);
        }

        // æœ€å¾Œã«è¨ªã‚ŒãŸç”ºï¼ˆã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ç”¨ï¼‰
        let lastTown = {
            mapPath: 'maps/town.json',
            x: 9,
            y: 9,
            name: 'ã‚¢ãƒ«ã‚«ãƒ‡ã‚£ã‚¢ã®è¡—'
        };

        // è£…å‚™è¾¼ã¿ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨ˆç®—ã—ã¦æ›´æ–°ï¼ˆå…¨ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ï¼‰
        function updateActualStats(member = null) {
            if (member) {
                updateMemberActualStats(member);
            } else {
                party.forEach(m => updateMemberActualStats(m));
            }
        }

        // è£…å‚™è¾¼ã¿ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
        function getPlayerAtk() {
            return player.actualAtk;
        }

        function getPlayerDef() {
            return player.actualDef;
        }

        // ========================================
        // çŠ¶æ…‹ç•°å¸¸ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================

        // çŠ¶æ…‹ç•°å¸¸ã‚’ä»˜ä¸
        function applyStatusEffect(target, effect) {
            if (effect === 'sleep') {
                const duration = STATUS_EFFECTS.sleep.duration;
                target.status.sleep = duration.min + Math.floor(Math.random() * (duration.max - duration.min + 1));
                return true;
            } else if (effect === 'poison') {
                target.status.poison = 99; // æ¯’ã¯æˆ¦é—˜çµ‚äº†ã¾ã§ç¶™ç¶š
                return true;
            } else if (effect === 'blind') {
                target.status.blind = 99; // å¹»æƒ‘ã¯æˆ¦é—˜çµ‚äº†ã¾ã§ç¶™ç¶š
                return true;
            }
            return false;
        }

        // çŠ¶æ…‹ç•°å¸¸ã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
        function getStatusIcons(target) {
            let icons = '';
            if (target.status.sleep > 0) icons += STATUS_EFFECTS.sleep.icon;
            if (target.status.poison > 0) icons += STATUS_EFFECTS.poison.icon;
            if (target.status.blind > 0) icons += STATUS_EFFECTS.blind.icon;
            return icons;
        }

        // ãƒãƒƒã‚¸å½¢å¼ã®çŠ¶æ…‹ç•°å¸¸è¡¨ç¤ºï¼ˆã€Œçœ ã€ã€Œæ¯’ã€ãªã©ï¼‰
        function getStatusBadges(target) {
            let badges = [];
            if (target.status.sleep > 0) badges.push(STATUS_EFFECTS.sleep.badge);
            if (target.status.poison > 0) badges.push(STATUS_EFFECTS.poison.badge);
            if (target.status.blind > 0) badges.push(STATUS_EFFECTS.blind.badge);
            return badges.length > 0 ? 'ï¼ˆ' + badges.join('') + 'ï¼‰' : '';
        }

        // ãƒãƒ•çŠ¶æ…‹ã®ãƒãƒƒã‚¸ã‚’å–å¾—
        function getBuffBadges() {
            if (!battle.active) return '';
            let badges = [];
            if (battle.buffs.attackUp > 0) badges.push('æ”»â†‘' + (battle.buffs.attackUp > 1 ? 'Ã—2' : ''));
            if (battle.buffs.defenseUp > 0) badges.push('å®ˆâ†‘' + (battle.buffs.defenseUp > 1 ? 'Ã—2' : ''));
            return badges.length > 0 ? '(' + badges.join(' ') + ')' : '';
        }

        // çœ ã‚Šã‹ã‚‰èµ·ãã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ï¼‰
        function checkWakeUp(target, name) {
            if (target.status.sleep > 0) {
                target.status.sleep--;
                if (target.status.sleep <= 0) {
                    return { awake: true, message: `${name} ã¯ ã‚ã‚’ã•ã¾ã—ãŸï¼` };
                } else {
                    return { awake: false, message: `${name} ã¯ ã­ã‚€ã£ã¦ã„ã‚‹...` };
                }
            }
            return { awake: true, message: null };
        }

        // æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å‡¦ç†ï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ï¼‰
        function processPoisonDamage(target, name, maxHp) {
            if (target.status.poison > 0) {
                const damage = Math.max(1, Math.floor(maxHp * STATUS_EFFECTS.poison.damageRate));
                target.hp = Math.max(1, target.hp - damage); // æ¯’ã§ã¯æ­»ãªãªã„
                return { damage, message: `${name} ã¯ ã©ãã® ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ ã†ã‘ãŸï¼ï¼ˆ${damage}ï¼‰` };
            }
            return null;
        }

        // æ”»æ’ƒå‘½ä¸­ç‡ã‚’å–å¾—ï¼ˆå¹»æƒ‘è€ƒæ…®ï¼‰
        function getHitRate(attacker) {
            const baseRate = 0.9; // é€šå¸¸90%
            if (attacker.status && attacker.status.blind > 0) {
                return baseRate * STATUS_EFFECTS.blind.hitRateModifier;
            }
            return baseRate;
        }

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ï¼ˆæ®µéšçš„æˆé•·ï¼‰
        // åºç›¤(~Lv20): ç·©ã‚„ã‹ã€ä¸­ç›¤(~Lv50): ã—ã£ã‹ã‚Šã€çµ‚ç›¤(Lv51~): ã‚„ã‚Šã“ã¿
        function getExpForLevel(level) {
            if (level <= 1) return 0;
            if (level <= 20) return Math.floor(level * level * 8);
            if (level <= 50) return Math.floor(level * level * 15);
            return Math.floor(level * level * 25);
        }

        // ãƒ¬ãƒ™ãƒ«1-99ã®å¿…è¦çµŒé¨“å€¤ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆç´¯ç©ï¼‰
        const MAX_LEVEL = 99;
        const expTable = [];
        let totalExp = 0;
        for (let i = 0; i <= MAX_LEVEL; i++) {
            expTable[i] = totalExp;
            totalExp += getExpForLevel(i + 1);
        }

        // ä¼šè©±çŠ¶æ…‹
        const dialog = {
            active: false,
            messages: [],
            currentIndex: 0,
            displayedText: '',
            charIndex: 0,
            isTyping: false,
            typingSpeed: 50,
            onComplete: null  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°çµ‚äº†æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
        };

        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼çŠ¶æ…‹
        const menu = {
            active: false,
            selectedIndex: 0,
            mode: 'status', // 'status', 'items', 'spells', 'map'
            itemCursor: 0,  // ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆä¸Šã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
            spellCursor: 0, // å‘ªæ–‡ãƒªã‚¹ãƒˆä¸Šã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
            showItemAction: false, // ã‚¢ã‚¤ãƒ†ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤º
            itemActionIndex: 0, // 0: ã¤ã‹ã†/ãã†ã³ã™ã‚‹, 1: ã™ã¦ã‚‹, 2: ã‚„ã‚ã‚‹
            // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼é¸æŠ
            memberCursor: 0, // é¸æŠä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼
            selectingMember: false, // ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼ˆå‘ªæ–‡/ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡é¸æŠï¼‰
            selectingSpellCaster: false, // å‘ªæ–‡è© å”±è€…é¸æŠãƒ¢ãƒ¼ãƒ‰
            selectingEquipMember: false, // è£…å‚™å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰
            selectingItemMember: false, // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰
            targetMemberCursor: 0 // ä½¿ç”¨å¯¾è±¡ã®ãƒ¡ãƒ³ãƒãƒ¼
        };

        // å®¿å±‹çŠ¶æ…‹
        const inn = {
            active: false,
            cost: 0,
            selectedIndex: 0 // 0: ã¯ã„, 1: ã„ã„ãˆ
        };

        // æ•™ä¼šçŠ¶æ…‹
        const church = {
            active: false,
            menuIndex: 0,       // 0: ã„ãã‹ãˆã‚‰ã›ã‚‹, 1: ã©ãã®ã¡ã‚Šã‚‡ã†, 2: ãŠã„ã®ã‚Šã‚’ã™ã‚‹, 3: ã‚„ã‚ã‚‹
            phase: 'menu',      // 'menu', 'selectMember', 'confirm'
            selectedMember: 0,  // å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            confirmIndex: 0     // 0: ã¯ã„, 1: ã„ã„ãˆ
        };

        // ã‚·ãƒ§ãƒƒãƒ—çŠ¶æ…‹
        const shop = {
            active: false,
            mode: 'menu',  // 'menu', 'buy', 'sell'
            phase: 'list', // 'list', 'confirm', 'equip', 'sold'
            menuIndex: 0,  // 0: ã‹ã†, 1: ã†ã‚‹, 2: ã‚„ã‚ã‚‹
            selectedIndex: 0,
            confirmIndex: 0, // 0: ã¯ã„, 1: ã„ã„ãˆ
            equipIndex: 0,   // 0: ã¯ã„, 1: ã„ã„ãˆ
            selectedItem: null,
            sellableItems: [] // å£²å´å¯èƒ½ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆ
        };

        // ãƒãƒˆãƒ«çŠ¶æ…‹
        const battle = {
            active: false,
            enemy: null,              // å¾Œæ–¹äº’æ›ç”¨ï¼ˆå˜ä½“å‚ç…§ï¼‰
            enemies: [],              // è¤‡æ•°æ•µã®é…åˆ—
            currentEnemyIndex: 0,     // æ•µã‚¿ãƒ¼ãƒ³ä¸­ã®å‡¦ç†å¯¾è±¡ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            targetIndex: 0,           // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
            isSelectingTarget: false, // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒ¢ãƒ¼ãƒ‰ä¸­
            phase: 'start', // start, command, partyCommand, target, playerTurn, partyTurn, enemyTurn, result
            commandIndex: 0,
            spellIndex: 0,
            showSpells: false,
            showItems: false,
            itemCursor: 0,
            message: '',
            messageQueue: [],
            animationFrame: 0,
            flashCount: 0,
            result: null, // 'win', 'lose', 'escape'
            pendingAction: null,      // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠå¾Œã«å®Ÿè¡Œã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
            // ãƒãƒ•çŠ¶æ…‹ï¼ˆæˆ¦é—˜ä¸­ã®ã¿æœ‰åŠ¹ï¼‰
            buffs: {
                attackUp: 0,   // ãƒã‚¤ã‚­ãƒ«ãƒˆé‡ã­ãŒã‘å›æ•°ï¼ˆæœ€å¤§2ï¼‰
                defenseUp: 0,  // ã‚¹ã‚¯ãƒ«ãƒˆé‡ã­ãŒã‘å›æ•°ï¼ˆæœ€å¤§2ï¼‰
                speedUp: 0     // ãƒ”ã‚ªãƒªãƒ é‡ã­ãŒã‘å›æ•°ï¼ˆæœ€å¤§2ï¼‰
            },
            // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒãƒˆãƒ«ç”¨
            currentPartyIndex: 0,     // ç¾åœ¨ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼
            partyActions: [],         // å„ãƒ¡ãƒ³ãƒãƒ¼ã®é¸æŠã‚¢ã‚¯ã‚·ãƒ§ãƒ³ [{type, target, spellId, itemId}, ...]
            executingActionIndex: 0,  // å®Ÿè¡Œä¸­ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            // å‘³æ–¹é¸æŠç”¨ï¼ˆå›å¾©å‘ªæ–‡ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãªã©ï¼‰
            isSelectingAlly: false,
            allyTargetIndex: 0,
            // ç´ æ—©ã•ãƒ™ãƒ¼ã‚¹è¡Œå‹•é †ã‚·ã‚¹ãƒ†ãƒ 
            actionQueue: [],           // è¡Œå‹•é †ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é…åˆ— [{type: 'player'/'enemy', index, speed, actor}, ...]
            currentActionIndex: 0,     // ç¾åœ¨ã®è¡Œå‹•è€…ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            turnPhase: 'command'       // 'command' (ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›) / 'execute' (å®Ÿè¡Œä¸­)
        };

        // ãƒãƒ•ã®æœ€å¤§é‡ã­ãŒã‘å›æ•°
        const MAX_BUFF_STACK = 2;

        // æ•µã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆç”¨ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆ
        const ENEMY_SUFFIXES = ['A', 'B', 'C', 'D', 'E', 'F'];

        // ç”Ÿå­˜ã—ã¦ã„ã‚‹æ•µã‚’å–å¾—
        function getAliveEnemies() {
            return battle.enemies.filter(e => e.currentHp > 0);
        }

        // æœ€åˆã®ç”Ÿå­˜æ•µã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        function getFirstAliveEnemyIndex() {
            return battle.enemies.findIndex(e => e.currentHp > 0);
        }

        // æ¬¡ã®ç”Ÿå­˜æ•µã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        // wrap=true: UIã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠç”¨ï¼ˆå¾ªç’°ã™ã‚‹ï¼‰
        // wrap=false: ã‚¿ãƒ¼ãƒ³å‡¦ç†ç”¨ï¼ˆ-1ã‚’è¿”ã™ï¼‰
        function getNextAliveEnemyIndex(currentIndex, wrap = true) {
            for (let i = currentIndex + 1; i < battle.enemies.length; i++) {
                if (battle.enemies[i].currentHp > 0) return i;
            }
            if (!wrap) return -1;  // ã‚¿ãƒ¼ãƒ³å‡¦ç†ç”¨ï¼šæ¬¡ãŒã„ãªã‘ã‚Œã°-1
            for (let i = 0; i < currentIndex; i++) {
                if (battle.enemies[i].currentHp > 0) return i;
            }
            return currentIndex;
        }

        // å‰ã®ç”Ÿå­˜æ•µã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        function getPrevAliveEnemyIndex(currentIndex) {
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (battle.enemies[i].currentHp > 0) return i;
            }
            for (let i = battle.enemies.length - 1; i > currentIndex; i--) {
                if (battle.enemies[i].currentHp > 0) return i;
            }
            return currentIndex;
        }

        // ã‚¨ãƒªã‚¢1ã®ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆå˜ä½“ã®ã¿ï¼‰
        const AREA1_ENCOUNTER_TABLES = ['field', 'forest', 'dungeon'];

        // æ•µã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç”Ÿæˆï¼ˆ1ã€œ4ä½“ï¼‰
        function generateEnemyGroup(encounterTable) {
            const enemies = [];
            const monsterPool = encounterTables[encounterTable] || encounterTables.field;

            // ã‚¨ãƒªã‚¢1ã¯å¸¸ã«1ä½“ã€ã‚¨ãƒªã‚¢2ä»¥é™ã¯è¤‡æ•°å‡ºç¾
            let enemyCount;
            if (AREA1_ENCOUNTER_TABLES.includes(encounterTable)) {
                enemyCount = 1;
            } else {
                // å‡ºç¾æ•°ã‚’æ±ºå®šï¼ˆ1ã€œ4ä½“ã€é‡ã¿ä»˜ã‘ï¼‰
                const countRoll = Math.random();
                if (countRoll < 0.3) enemyCount = 1;       // 30%: 1ä½“
                else if (countRoll < 0.6) enemyCount = 2; // 30%: 2ä½“
                else if (countRoll < 0.85) enemyCount = 3; // 25%: 3ä½“
                else enemyCount = 4;                       // 15%: 4ä½“
            }

            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆåŒç¨®ã®ã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ç”¨ï¼‰
            const monsterCounts = {};

            for (let i = 0; i < enemyCount; i++) {
                const monsterType = monsterPool[Math.floor(Math.random() * monsterPool.length)];
                const monsterData = monsters[monsterType];
                if (!monsterData) continue;

                // åŒç¨®ã‚«ã‚¦ãƒ³ãƒˆ
                if (!monsterCounts[monsterType]) {
                    monsterCounts[monsterType] = 0;
                }
                const suffix = ENEMY_SUFFIXES[monsterCounts[monsterType]];
                monsterCounts[monsterType]++;

                enemies.push({
                    ...monsterData,
                    id: `${monsterType}_${i}`,
                    type: monsterType,
                    displayName: enemyCount > 1 ?
                        `${monsterData.name}${suffix}` : monsterData.name,
                    currentHp: monsterData.hp,
                    currentMp: monsterData.mp || 0,
                    status: { sleep: 0, poison: 0, blind: 0 },
                    index: i
                });
            }

            return enemies;
        }

        // ========================================
        // Canvas & ã‚«ãƒ¡ãƒ©
        // ========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fadeOverlay = document.getElementById('fadeOverlay');
        const mapNameElement = document.getElementById('mapName');
        const mapNameArea = document.getElementById('mapNameArea');

        // ãƒãƒƒãƒ—åã®è‰²ã‚’æ›´æ–°ï¼ˆåœ°åº•ãƒãƒƒãƒ—ã¯ç´«ç³»ã€è’å»ƒã—ãŸä¸–ç•Œã¯ç°è‰²ç³»ï¼‰
        function updateMapNameColor() {
            if (currentMap && currentMap.isUnderworld) {
                mapNameElement.style.color = '#9966ff';
            } else if (currentMap && currentMap.isDesolated) {
                mapNameElement.style.color = '#a0a0a0';
            } else {
                mapNameElement.style.color = 'rgba(255, 255, 255, 0.8)';
            }
        }

        let tileSize = 32;
        let cameraX = 0;
        let cameraY = 0;
        let canvasWidth = 0;
        let canvasHeight = 0;

        function resize() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            tileSize = Math.floor(canvasWidth / VISIBLE_TILES);
            updateCamera();
        }

        function updateCamera() {
            cameraX = player.x * tileSize - canvasWidth / 2 + tileSize / 2;
            cameraY = player.y * tileSize - canvasHeight / 2 + tileSize / 2;
            const mapPixelWidth = currentMap.cols * tileSize;
            const mapPixelHeight = currentMap.rows * tileSize;
            cameraX = Math.max(0, Math.min(cameraX, mapPixelWidth - canvasWidth));
            cameraY = Math.max(0, Math.min(cameraY, mapPixelHeight - canvasHeight));
        }

        // ========================================
        // ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰
        // ========================================
        function saveGame() {
            const chestStates = {};
            for (const mapId in maps) {
                if (maps[mapId].chests) {
                    chestStates[mapId] = maps[mapId].chests.map(c => ({ id: c.id, isOpened: c.isOpened }));
                }
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            const savedParty = party.map(member => ({
                id: member.id,
                name: member.name,
                job: member.job,
                sprite: member.sprite,
                hp: member.hp,
                maxHp: member.maxHp,
                mp: member.mp,
                maxMp: member.maxMp,
                baseAtk: member.baseAtk,
                baseDef: member.baseDef,
                speed: member.speed,
                level: member.level,
                exp: member.exp,
                spells: [...member.spells],
                equipment: { ...member.equipment },
                isAlive: member.isAlive
            }));

            const saveData = {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ ç”¨ï¼ˆæ–°å½¢å¼ï¼‰
                party: savedParty,
                partyData: {
                    x: partyData.x,
                    y: partyData.y,
                    direction: partyData.direction,
                    gold: partyData.gold,
                    inventory: JSON.parse(JSON.stringify(partyData.inventory))
                },
                // å¾Œæ–¹äº’æ›ç”¨ï¼ˆæ—§å½¢å¼ã‚‚ä¿æŒï¼‰
                player: {
                    x: partyData.x, y: partyData.y, direction: partyData.direction,
                    hp: party[0].hp, maxHp: party[0].maxHp, mp: party[0].mp, maxMp: party[0].maxMp,
                    baseAtk: party[0].baseAtk, baseDef: party[0].baseDef, speed: party[0].speed,
                    level: party[0].level, exp: party[0].exp, gold: partyData.gold,
                    inventory: partyData.inventory, spells: party[0].spells,
                    equipment: party[0].equipment
                },
                currentMapId: currentMapId,
                currentMapPath: currentMapPath,
                chestStates: chestStates,
                gameCleared: gameCleared,
                // ã‚²ãƒ¼ãƒ é€²è¡Œãƒ•ãƒ©ã‚°
                gameProgress: {
                    bossDefeated: { ...gameProgress.bossDefeated },
                    storyFlags: { ...gameProgress.storyFlags },
                    areas: { ...gameProgress.areas },
                    quests: JSON.parse(JSON.stringify(gameProgress.quests)),
                    openedPassages: JSON.parse(JSON.stringify(gameProgress.openedPassages)),
                    visitedLocations: JSON.parse(JSON.stringify(gameProgress.visitedLocations)),
                    lastEntrance: gameProgress.lastEntrance ? { ...gameProgress.lastEntrance } : null
                },
                // ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ç”¨ï¼šæœ€å¾Œã«è¨ªã‚ŒãŸç”º
                lastTown: { ...lastTown }
            };

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.error('ã‚»ãƒ¼ãƒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
            }
        }

        async function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) return false;

                const data = JSON.parse(savedData);

                // æ–°å½¢å¼ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ ï¼‰ã®ãƒ­ãƒ¼ãƒ‰
                if (data.party && Array.isArray(data.party)) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£é…åˆ—ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†æ§‹ç¯‰
                    party.length = 0;
                    data.party.forEach(memberData => {
                        const member = createPartyMember({
                            id: memberData.id,
                            name: memberData.name,
                            job: memberData.job,
                            sprite: memberData.sprite,
                            hp: memberData.hp,
                            maxHp: memberData.maxHp,
                            mp: memberData.mp,
                            maxMp: memberData.maxMp,
                            baseAtk: memberData.baseAtk,
                            baseDef: memberData.baseDef,
                            speed: memberData.speed,
                            level: memberData.level,
                            exp: memberData.exp,
                            spells: memberData.spells || [],
                            equipment: memberData.equipment
                        });
                        member.isAlive = memberData.isAlive !== false;
                        party.push(member);
                    });

                    // partyDataã®å¾©å…ƒ
                    if (data.partyData) {
                        partyData.x = data.partyData.x;
                        partyData.y = data.partyData.y;
                        partyData.direction = data.partyData.direction || 'down';
                        partyData.gold = data.partyData.gold || 0;
                        partyData.inventory = data.partyData.inventory || [];
                    }

                    // playerã®å‚ç…§ã‚’æ›´æ–°ã—ã€ãƒ—ãƒ­ã‚­ã‚·ã‚’å†è¨­å®š
                    player = party[0];
                    setupPlayerProxy();

                    // å„ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
                    party.forEach(member => {
                        const weapon = items[member.equipment?.weapon];
                        const armor = items[member.equipment?.armor];
                        member.actualAtk = member.baseAtk + (weapon ? weapon.value : 0);
                        member.actualDef = member.baseDef + (armor ? armor.value : 0);
                    });
                } else {
                    // æ—§å½¢å¼ï¼ˆå˜ä¸€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ã®ãƒ­ãƒ¼ãƒ‰
                    // æ—§ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§ï¼ˆatk/defã‚’baseAtk/baseDefã«å¤‰æ›ï¼‰
                    if (data.player.atk !== undefined && data.player.baseAtk === undefined) {
                        data.player.baseAtk = data.player.atk;
                        delete data.player.atk;
                    }
                    if (data.player.def !== undefined && data.player.baseDef === undefined) {
                        data.player.baseDef = data.player.def;
                        delete data.player.def;
                    }

                    // æ—§è£…å‚™å½¢å¼ã‹ã‚‰ã®å¤‰æ›ï¼ˆequippedWeapon/equippedArmor â†’ equipmentï¼‰
                    if (data.player.equipment === undefined) {
                        data.player.equipment = {
                            weapon: data.player.equippedWeapon || 10,  // ã“ã‚“ã¼ã†
                            armor: data.player.equippedArmor || 20     // ãŸã³ã³ã¨ã®ãµã
                        };
                        delete data.player.equippedWeapon;
                        delete data.player.equippedArmor;
                    }

                    // æ—§ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªå½¢å¼ã‹ã‚‰ã®å¤‰æ›ï¼ˆ[1, 1, 2] â†’ [{ id: 1, quantity: 2 }, { id: 2, quantity: 1 }]ï¼‰
                    if (data.player.inventory && Array.isArray(data.player.inventory) && data.player.inventory.length > 0) {
                        if (typeof data.player.inventory[0] === 'number') {
                            const migrated = [];
                            data.player.inventory.forEach(itemId => {
                                const existing = migrated.find(s => s.id === itemId);
                                if (existing) {
                                    existing.quantity++;
                                } else {
                                    migrated.push({ id: itemId, quantity: 1 });
                                }
                            });
                            data.player.inventory = migrated;
                        }
                    }

                    // å‘ªæ–‡ç¿’å¾—ãƒ¬ãƒ™ãƒ«å¤‰æ›´ã«å¯¾å¿œï¼šç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ä»¥ä¸‹ã§ç¿’å¾—ã™ã¹ãå‘ªæ–‡ã‚’è£œå®Œ
                    if (data.player.spells && data.player.level) {
                        for (const spellId in spells) {
                            const spell = spells[spellId];
                            if (spell.learnLevel <= data.player.level && !data.player.spells.includes(spellId)) {
                                data.player.spells.push(spellId);
                            }
                        }
                    }

                    // æ—§ãƒ‡ãƒ¼ã‚¿ã‚’party[0]ã«å¤‰æ›
                    party.length = 0;
                    const heroData = data.player;
                    const hero = createPartyMember({
                        id: 'hero',
                        name: heroData.name || 'ã‚†ã†ã—ã‚ƒ',
                        job: 'hero',
                        sprite: 'ğŸ§™',
                        hp: heroData.hp,
                        maxHp: heroData.maxHp,
                        mp: heroData.mp,
                        maxMp: heroData.maxMp,
                        baseAtk: heroData.baseAtk,
                        baseDef: heroData.baseDef,
                        speed: heroData.speed || 6,
                        level: heroData.level,
                        exp: heroData.exp,
                        spells: heroData.spells || [],
                        equipment: heroData.equipment
                    });
                    hero.isAlive = heroData.hp > 0;
                    party.push(hero);
                    player = party[0];
                    setupPlayerProxy();

                    // partyDataã®å¾©å…ƒ
                    partyData.x = heroData.x;
                    partyData.y = heroData.y;
                    partyData.direction = heroData.direction || 'down';
                    partyData.gold = heroData.gold || 0;
                    partyData.inventory = heroData.inventory || [];

                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
                    const weapon = items[hero.equipment?.weapon];
                    const armor = items[hero.equipment?.armor];
                    hero.actualAtk = hero.baseAtk + (weapon ? weapon.atk : 0);
                    hero.actualDef = hero.baseDef + (armor ? armor.def : 0);
                }
                currentMapId = data.currentMapId;

                // ãƒãƒƒãƒ—ãƒ‘ã‚¹ã®èª­ã¿è¾¼ã¿ï¼ˆæ–°å½¢å¼å¯¾å¿œï¼‰
                if (data.currentMapPath) {
                    currentMapPath = data.currentMapPath;
                } else {
                    // æ—§ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯IDã‹ã‚‰ãƒ‘ã‚¹ã‚’ç”Ÿæˆ
                    currentMapPath = `maps/${currentMapId}.json`;
                }

                // ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ï¼ˆå¤–éƒ¨JSONã‚’å„ªå…ˆã—ã¦ãƒ­ãƒ¼ãƒ‰ï¼‰
                try {
                    const mapData = await loadMapFromDatabase(currentMapPath);
                    // å¤–éƒ¨JSONãƒãƒƒãƒ—ã§ã‚ã‚‹ã“ã¨ã‚’ãƒãƒ¼ã‚¯
                    mapData._isExternal = true;
                    currentMap = {
                        data: mapData.data.map(row => [...row]),
                        cols: mapData.cols,
                        rows: mapData.rows,
                        npcs: JSON.parse(JSON.stringify(mapData.npcs || [])),
                        chests: JSON.parse(JSON.stringify(mapData.chests || [])),
                        warps: mapData.warps ? [...mapData.warps] : [],
                        portals: mapData.portals ? [...mapData.portals] : [],
                        name: mapData.name,
                        type: mapData.type,
                        encounterRate: mapData.encounterRate,
                        encounterTable: mapData.encounterTable,
                        mapId: mapData.mapId,
                        _isExternal: true
                    };
                    maps[mapData.mapId] = mapData;
                    currentMapId = mapData.mapId;
                } catch (err) {
                    console.error('ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ã€å†…è”µãƒãƒƒãƒ—ã‚’ä½¿ç”¨:', err);
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å†…è”µãƒãƒƒãƒ—ã‚’ä½¿ç”¨
                    if (maps[currentMapId]) {
                        const sourceMap = maps[currentMapId];
                        currentMap = {
                            data: sourceMap.data.map(row => [...row]),
                            cols: sourceMap.cols,
                            rows: sourceMap.rows,
                            npcs: JSON.parse(JSON.stringify(sourceMap.npcs || [])),
                            chests: JSON.parse(JSON.stringify(sourceMap.chests || [])),
                            warps: sourceMap.warps ? [...sourceMap.warps] : [],
                            portals: sourceMap.portals ? [...sourceMap.portals] : [],
                            name: sourceMap.name,
                            type: sourceMap.type,
                            encounterRate: sourceMap.encounterRate,
                            encounterTable: sourceMap.encounterTable
                        };
                    } else {
                        const fieldMap = maps['field'];
                        currentMap = {
                            data: fieldMap.data.map(row => [...row]),
                            cols: fieldMap.cols,
                            rows: fieldMap.rows,
                            npcs: JSON.parse(JSON.stringify(fieldMap.npcs || [])),
                            chests: JSON.parse(JSON.stringify(fieldMap.chests || [])),
                            warps: fieldMap.warps ? [...fieldMap.warps] : [],
                            portals: fieldMap.portals ? [...fieldMap.portals] : [],
                            name: fieldMap.name,
                            type: fieldMap.type,
                            encounterRate: fieldMap.encounterRate,
                            encounterTable: fieldMap.encounterTable
                        };
                        currentMapId = 'field';
                    }
                }
                mapNameElement.textContent = currentMap.name;
                updateMapNameColor();

                if (data.chestStates) {
                    for (const mapId in data.chestStates) {
                        // mapså´ã«å¾©å…ƒ
                        if (maps[mapId] && maps[mapId].chests) {
                            for (const savedChest of data.chestStates[mapId]) {
                                const chest = maps[mapId].chests.find(c => c.id === savedChest.id);
                                if (chest) chest.isOpened = savedChest.isOpened;
                            }
                        }
                        // currentMapå´ã«ã‚‚å¾©å…ƒï¼ˆç¾åœ¨ã®ãƒãƒƒãƒ—ã®å ´åˆï¼‰
                        if (mapId === currentMapId && currentMap && currentMap.chests) {
                            for (const savedChest of data.chestStates[mapId]) {
                                const chest = currentMap.chests.find(c => c.id === savedChest.id);
                                if (chest) chest.isOpened = savedChest.isOpened;
                            }
                        }
                    }
                }

                // é­”ç‹è¨ä¼ãƒ•ãƒ©ã‚°ã®èª­ã¿è¾¼ã¿
                if (data.gameCleared !== undefined) {
                    gameCleared = data.gameCleared;
                }

                // ã‚²ãƒ¼ãƒ é€²è¡Œãƒ•ãƒ©ã‚°ã®èª­ã¿è¾¼ã¿ï¼ˆå¾Œæ–¹äº’æ›æ€§å¯¾å¿œï¼‰
                if (data.gameProgress) {
                    // ä¿å­˜ã•ã‚ŒãŸãƒ•ãƒ©ã‚°ã‚’å¾©å…ƒ
                    if (data.gameProgress.bossDefeated) {
                        Object.assign(gameProgress.bossDefeated, data.gameProgress.bossDefeated);
                    }
                    if (data.gameProgress.storyFlags) {
                        Object.assign(gameProgress.storyFlags, data.gameProgress.storyFlags);
                    }
                    if (data.gameProgress.areas) {
                        gameProgress.areas = { ...data.gameProgress.areas };
                    }
                    // ã‚¯ã‚¨ã‚¹ãƒˆãƒ•ãƒ©ã‚°ã®å¾©å…ƒ
                    if (data.gameProgress.quests) {
                        for (const questName in data.gameProgress.quests) {
                            if (gameProgress.quests[questName]) {
                                Object.assign(gameProgress.quests[questName], data.gameProgress.quests[questName]);
                            }
                        }
                    }
                    // éš ã—é€šè·¯ã®å¾©å…ƒ
                    if (data.gameProgress.openedPassages) {
                        gameProgress.openedPassages = JSON.parse(JSON.stringify(data.gameProgress.openedPassages));
                    }
                    // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šè¨ªå•æ¸ˆã¿æ‹ ç‚¹ã®å¾©å…ƒ
                    if (data.gameProgress.visitedLocations) {
                        gameProgress.visitedLocations = JSON.parse(JSON.stringify(data.gameProgress.visitedLocations));
                    }
                    // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å…¥å£ã®å¾©å…ƒ
                    if (data.gameProgress.lastEntrance) {
                        gameProgress.lastEntrance = { ...data.gameProgress.lastEntrance };
                    }
                } else {
                    // æ—§ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã®ç§»è¡Œï¼šgameClearedã‹ã‚‰maouæ’ƒç ´ãƒ•ãƒ©ã‚°ã‚’æ¨æ¸¬
                    gameProgress.bossDefeated.maou = gameCleared;
                    gameProgress.storyFlags.reportedMidBossDefeat = false;
                    gameProgress.storyFlags.portalRoomUnlocked = false;
                }

                // ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ç”¨ï¼šæœ€å¾Œã«è¨ªã‚ŒãŸç”ºã‚’å¾©å…ƒ
                if (data.lastTown) {
                    lastTown = { ...data.lastTown };
                }

                // æ—¢å­˜ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿æ•‘æ¸ˆï¼šç ‚æ¼ ã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†çŠ¶æ…‹ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                // 3ã¤ã®ã‚¯ã‚¨ã‚¹ãƒˆãŒå®Œäº†ã—ã¦ã„ã‚‹ã®ã«desertCastleUnlockedãŒfalseã®å ´åˆã‚’ä¿®å¾©
                if (isQuestCompleted('waterShortage') &&
                    isQuestCompleted('passportRecovery') &&
                    isQuestCompleted('royalCrest') &&
                    !getStoryFlag('desertCastleUnlocked')) {
                    setStoryFlag('desertCastleUnlocked', true);
                    // ä¿®å¾©å¾Œã«ä¿å­˜ï¼ˆéåŒæœŸã§å®Ÿè¡Œã—ã¦æˆ»ã‚Šå€¤ã«å½±éŸ¿ã‚’ä¸ãˆãªã„ï¼‰
                    setTimeout(() => saveGame(), 0);
                }

                // ãƒ­ãƒ¼ãƒ‰å¾Œã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—
                updateActualStats();
                return true;
            } catch (e) {
                console.error('ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
                return false;
            }
        }

        // ========================================
        // æç”»é–¢æ•°
        // ========================================
        function getTileColor(tile) {
            const mapColors = MAP_TILE_COLORS[currentMap.type];
            if (mapColors && mapColors[tile] !== undefined) return mapColors[tile];
            return DEFAULT_TILE_COLORS[tile] || '#333';
        }

        let drawMapDebugCount = 0;
        function drawMap() {
            // if (drawMapDebugCount < 3) {
            //     console.log('[DEBUG drawMap] tileSize:', tileSize, 'cameraX:', cameraX, 'cameraY:', cameraY);
            //     console.log('[DEBUG drawMap] currentMap.cols:', currentMap.cols, 'currentMap.rows:', currentMap.rows);
            //     drawMapDebugCount++;
            // }

            // tileSizeãŒ0ã®å ´åˆã¯æç”»ã—ãªã„
            if (tileSize <= 0) {
                // console.warn('[DEBUG drawMap] tileSize is 0 or negative!');
                return;
            }

            const startCol = Math.floor(cameraX / tileSize);
            const startRow = Math.floor(cameraY / tileSize);
            const endCol = Math.min(currentMap.cols, startCol + Math.ceil(canvasWidth / tileSize) + 2);
            const endRow = Math.min(currentMap.rows, startRow + Math.ceil(canvasHeight / tileSize) + 2);

            for (let row = Math.max(0, startRow); row < endRow; row++) {
                for (let col = Math.max(0, startCol); col < endCol; col++) {
                    const tile = currentMap.data[row][col];
                    const screenX = col * tileSize - cameraX;
                    const screenY = row * tileSize - cameraY;
                    ctx.fillStyle = getTileColor(tile);
                    ctx.fillRect(screenX, screenY, tileSize + 1, tileSize + 1);
                    drawTileDecoration(tile, screenX, screenY, col, row);
                }
            }

            // åœ°åº•ãƒãƒƒãƒ—ã®æš—é—˜ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
            if (currentMap.isUnderworld && currentMap.darknessLevel) {
                // ç”»é¢å…¨ä½“ã‚’æš—ã
                ctx.fillStyle = `rgba(0, 0, 20, ${currentMap.darknessLevel})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨è¾ºã®æ˜ã‹ã‚Šï¼ˆå††å½¢ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const playerScreenX = (player.x - cameraX) * tileSize + tileSize / 2;
                const playerScreenY = (player.y - cameraY) * tileSize + tileSize / 2;
                const lightRadius = tileSize * 4;

                ctx.globalCompositeOperation = 'destination-out';
                const gradient = ctx.createRadialGradient(
                    playerScreenX, playerScreenY, 0,
                    playerScreenX, playerScreenY, lightRadius
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, lightRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }

            // è’å»ƒã—ãŸä¸–ç•Œã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå¤ã®å¤§åœ°ãªã©ï¼‰
            if (currentMap.isDesolated && currentMap.desolationLevel) {
                const level = currentMap.desolationLevel;

                // ç°ç´«è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã§è’å»ƒæ„Ÿã‚’è¡¨ç¾
                ctx.fillStyle = `rgba(60, 50, 70, ${level * 0.2})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // ãƒ“ãƒãƒƒãƒˆåŠ¹æœï¼ˆå‘¨è¾ºã‚’æš—ãï¼‰
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);

                const vignette = ctx.createRadialGradient(
                    centerX, centerY, maxRadius * 0.5,
                    centerX, centerY, maxRadius
                );
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(1, `rgba(30, 20, 40, ${level * 0.4})`);
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
        }

        function drawTileDecoration(tile, x, y, col, row) {
            ctx.save();
            ctx.font = `${tileSize * 0.7}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (tile === TILE.GRASS) {
                const seed = (col * 7 + row * 13) % 100;
                if (seed < 25) {
                    ctx.font = `${tileSize * 0.3}px serif`;
                    ctx.fillText('ğŸŒ¿', x + tileSize * 0.5, y + tileSize * 0.5);
                }
            } else if (tile === TILE.MOUNTAIN) {
                ctx.fillText('â›°ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.SEA) {
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
                ctx.lineWidth = 2;
                const waveOffset = (Date.now() / 500) % (Math.PI * 2);
                for (let i = 0; i < 3; i++) {
                    const waveY = y + tileSize * (0.3 + i * 0.25);
                    ctx.beginPath();
                    ctx.moveTo(x, waveY);
                    for (let wx = 0; wx <= tileSize; wx += 4) {
                        ctx.lineTo(x + wx, waveY + Math.sin(waveOffset + wx * 0.1 + i) * 2);
                    }
                    ctx.stroke();
                }
            } else if (tile === TILE.CASTLE) {
                ctx.fillText('ğŸ°', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.TOWN) {
                ctx.fillText('ğŸ˜ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.UNDERWORLD_TOWN) {
                ctx.fillText('ğŸ˜ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.STAIRS) {
                ctx.fillText('ğŸªœ', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.FLOOR) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.strokeRect(x + 2, y + 2, tileSize - 4, tileSize - 4);
            } else if (tile === TILE.WALL) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(x, y + tileSize - 4, tileSize, 4);
            } else if (tile === TILE.PORTAL) {
                // æ—…ã®æ‰‰ï¼šæ¸¦å·»ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const time = Date.now() / 500;
                ctx.save();
                ctx.translate(x + tileSize / 2, y + tileSize / 2);
                ctx.rotate(time % (Math.PI * 2));
                ctx.font = `${tileSize * 0.8}px serif`;
                ctx.fillText('ğŸŒ€', 0, 0);
                ctx.restore();
            } else if (tile === TILE.STAIRS_UP) {
                ctx.fillText('â¬†ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.STAIRS_DOWN) {
                ctx.fillText('â¬‡ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.ICE_FLOOR) {
                // æ°·åºŠ: æ»‘ã‚Šã‚„ã™ã•ã‚’è¡¨ç¾
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(x + i * tileSize * 0.3, y + tileSize * 0.2);
                    ctx.lineTo(x + tileSize * 0.2 + i * tileSize * 0.3, y + tileSize * 0.8);
                    ctx.stroke();
                }
            } else if (tile === TILE.ICE_WALL) {
                // æ°·ã®å£
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(x + 2, y + 2, tileSize * 0.4, tileSize * 0.3);
                ctx.font = `${tileSize * 0.5}px serif`;
                ctx.fillText('ğŸ§Š', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.ICE_HOLE) {
                // æ°·ã®ç©´: å±é™ºãªé›°å›²æ°—
                ctx.fillStyle = 'rgba(0, 30, 60, 0.5)';
                ctx.beginPath();
                ctx.ellipse(x + tileSize / 2, y + tileSize / 2, tileSize * 0.35, tileSize * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = `${tileSize * 0.4}px serif`;
                ctx.fillText('âš ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.SNOW) {
                // é›ªåŸ
                const seed = (col * 11 + row * 17) % 100;
                if (seed < 30) {
                    ctx.font = `${tileSize * 0.25}px serif`;
                    ctx.fillText('â„', x + tileSize * 0.3, y + tileSize * 0.3);
                }
            } else if (tile === TILE.TORCH) {
                // ç‡­å°
                const flicker = Math.sin(Date.now() / 100) * 0.15 + 0.85;
                ctx.font = `${tileSize * 0.6 * flicker}px serif`;
                ctx.fillText('ğŸ•¯ï¸', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.ICE_ALTAR) {
                // æ°·ã®ç¥­å£‡
                ctx.font = `${tileSize * 0.6}px serif`;
                ctx.fillText('ğŸ”®', x + tileSize / 2, y + tileSize / 2);
            } else if (tile === TILE.ICE_SWITCH) {
                // åœ§åŠ›ã‚¹ã‚¤ãƒƒãƒ
                const isPressed = switchStates[currentMap?.id]?.[`switch_${col}_${row}`];
                ctx.fillStyle = isPressed ? 'rgba(100, 255, 100, 0.3)' : 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = isPressed ? '#4a8' : '#888';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawChests() {
            if (!currentMap.chests) return;
            for (const chest of currentMap.chests) {
                const screenX = chest.x * tileSize - cameraX;
                const screenY = chest.y * tileSize - cameraY;
                if (screenX < -tileSize || screenX > canvasWidth || screenY < -tileSize || screenY > canvasHeight) continue;
                ctx.font = `${tileSize * 0.7}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(chest.isOpened ? 'ğŸ“¦' : 'ğŸ', screenX + tileSize / 2, screenY + tileSize / 2);
            }
        }

        // æ°·ãƒ–ãƒ­ãƒƒã‚¯æç”»
        function drawIceBlocks() {
            const blocks = pushedIceBlocks[currentMap?.id];
            if (!blocks) return;

            for (const block of blocks) {
                const screenX = block.x * tileSize - cameraX;
                const screenY = block.y * tileSize - cameraY;
                if (screenX < -tileSize || screenX > canvasWidth || screenY < -tileSize || screenY > canvasHeight) continue;

                // æ°·ãƒ–ãƒ­ãƒƒã‚¯ã®æç”»
                ctx.fillStyle = '#88c8e8';
                ctx.fillRect(screenX + 2, screenY + 2, tileSize - 4, tileSize - 4);

                // å…‰æ²¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(screenX + 4, screenY + 4, tileSize * 0.3, tileSize * 0.2);

                // è¼ªéƒ­
                ctx.strokeStyle = '#5898b8';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 2, screenY + 2, tileSize - 4, tileSize - 4);

                // æ°·ã®æ¨¡æ§˜
                ctx.font = `${tileSize * 0.5}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillText('â„', screenX + tileSize / 2, screenY + tileSize / 2);
            }
        }

        function drawNPCs() {
            if (!currentMap.npcs) return;
            for (const npc of currentMap.npcs) {
                const pos = getNpcEffectivePosition(npc);
                const screenX = pos.x * tileSize - cameraX;
                const screenY = pos.y * tileSize - cameraY;
                if (screenX < -tileSize || screenX > canvasWidth || screenY < -tileSize || screenY > canvasHeight) continue;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(screenX + tileSize / 2, screenY + tileSize * 0.9, tileSize * 0.3, tileSize * 0.1, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = `${tileSize * 0.7}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(npc.sprite, screenX + tileSize / 2, screenY + tileSize / 2);
            }
        }

        function drawPlayer() {
            const screenX = player.x * tileSize - cameraX;
            const screenY = player.y * tileSize - cameraY;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX + tileSize / 2, screenY + tileSize * 0.9, tileSize * 0.35, tileSize * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffcc00';
            ctx.fillRect(screenX + tileSize * 0.25, screenY + tileSize * 0.2, tileSize * 0.5, tileSize * 0.6);
            ctx.fillStyle = '#000';
            if (player.direction !== 'up') {
                ctx.fillRect(screenX + tileSize * 0.35, screenY + tileSize * 0.35, tileSize * 0.08, tileSize * 0.08);
                ctx.fillRect(screenX + tileSize * 0.55, screenY + tileSize * 0.35, tileSize * 0.08, tileSize * 0.08);
            }
            ctx.font = `${tileSize * 0.4}px serif`;
            ctx.textAlign = 'center';
            ctx.fillText('âš”ï¸', screenX + tileSize / 2, screenY + tileSize * 0.15);
        }

        function drawMessageWindow() {
            if (!dialog.active) return;
            const padding = 20;
            const textPadding = 20;
            const windowX = padding;
            const windowWidth = canvasWidth - padding * 2;
            const maxTextWidth = windowWidth - textPadding * 2;

            // ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š
            const fontSize = Math.floor(tileSize * 0.42);
            const lineHeight = fontSize * 1.4;
            const font = `${fontSize}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;

            // ãƒ†ã‚­ã‚¹ãƒˆã®è¡Œæ•°ã‚’è¨ˆç®—ã—ã¦ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®é«˜ã•ã‚’å‹•çš„ã«æ±ºå®š
            const lines = wrapText(dialog.displayedText, maxTextWidth, font);
            const minLines = 2;
            const numLines = Math.max(minLines, lines.length);
            const windowHeight = textPadding * 2 + lineHeight * numLines + 10;
            const windowY = canvasHeight - windowHeight - 180;

            drawWindow(windowX, windowY, windowWidth, windowHeight);

            ctx.fillStyle = '#fff';
            ctx.font = font;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            // æŠ˜ã‚Šè¿”ã—ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], windowX + textPadding, windowY + textPadding + i * lineHeight);
            }

            if (!dialog.isTyping && dialog.currentIndex < dialog.messages.length - 1) {
                const blinkAlpha = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${blinkAlpha})`;
                ctx.font = `${tileSize * 0.4}px serif`;
                ctx.textAlign = 'right';
                ctx.fillText('â–¼', windowX + windowWidth - 20, windowY + windowHeight - 25);
            }
        }

        function drawWindow(x, y, w, h) {
            ctx.fillStyle = 'rgba(0, 0, 50, 0.95)';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 8, y + 8, w - 16, h - 16);
        }

        // ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒ‡å®šå¹…ã§æŠ˜ã‚Šè¿”ã—ã¦è¡Œã®é…åˆ—ã‚’è¿”ã™
        function wrapText(text, maxWidth, font) {
            ctx.font = font;
            const words = [];
            // æ—¥æœ¬èªã¯æ–‡å­—å˜ä½ã€è‹±æ•°å­—ã¯å˜èªå˜ä½ã§åˆ†å‰²
            let currentWord = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                // æ—¥æœ¬èªæ–‡å­—åˆ¤å®šï¼ˆã²ã‚‰ãŒãªã€ã‚«ã‚¿ã‚«ãƒŠã€æ¼¢å­—ã€å…¨è§’è¨˜å·ï¼‰
                if (/[\u3000-\u9FFF\uFF00-\uFFEF]/.test(char)) {
                    if (currentWord) {
                        words.push(currentWord);
                        currentWord = '';
                    }
                    words.push(char);
                } else if (char === ' ') {
                    if (currentWord) {
                        words.push(currentWord);
                        currentWord = '';
                    }
                } else {
                    currentWord += char;
                }
            }
            if (currentWord) words.push(currentWord);

            const lines = [];
            let currentLine = '';

            for (const word of words) {
                const testLine = currentLine + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);

            return lines.length > 0 ? lines : [''];
        }

        // è¤‡æ•°è¡Œãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
        function drawWrappedText(text, x, y, maxWidth, lineHeight, font) {
            ctx.font = font;
            const lines = wrapText(text, maxWidth, font);
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], x, y + i * lineHeight);
            }
            return lines.length;
        }

        function drawMenu() {
            if (!menu.active) return;
            const menuWidth = canvasWidth * 0.85;
            const menuHeight = canvasHeight * 0.75;
            const menuX = (canvasWidth - menuWidth) / 2;
            const menuY = (canvasHeight - menuHeight) / 2;

            drawWindow(menuX, menuY, menuWidth, menuHeight);

            // ã‚¿ãƒ–è¡¨ç¤ºï¼ˆ4ã‚¿ãƒ–ï¼šã¤ã‚ˆã•ã€ã˜ã‚…ã‚‚ã‚“ã€ã‚‚ã¡ã‚‚ã®ã€ã¡ãšï¼‰
            const tabY = menuY + 10;
            ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // ã¤ã‚ˆã•ã‚¿ãƒ–
            ctx.fillStyle = menu.mode === 'status' ? '#ffd700' : 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('ã¤ã‚ˆã•', menuX + menuWidth * 0.125, tabY);

            // ã˜ã‚…ã‚‚ã‚“ã‚¿ãƒ–
            ctx.fillStyle = menu.mode === 'spells' ? '#ffd700' : 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('ã˜ã‚…ã‚‚ã‚“', menuX + menuWidth * 0.375, tabY);

            // ã‚‚ã¡ã‚‚ã®ã‚¿ãƒ–
            ctx.fillStyle = menu.mode === 'items' ? '#ffd700' : 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('ã‚‚ã¡ã‚‚ã®', menuX + menuWidth * 0.625, tabY);

            // ã¡ãšã‚¿ãƒ–
            ctx.fillStyle = menu.mode === 'map' ? '#ffd700' : 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('ã¡ãš', menuX + menuWidth * 0.875, tabY);

            // åŒºåˆ‡ã‚Šç·š
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(menuX + 15, tabY + tileSize * 0.5);
            ctx.lineTo(menuX + menuWidth - 15, tabY + tileSize * 0.5);
            ctx.stroke();

            const contentY = tabY + tileSize * 0.7;
            const lineHeight = tileSize * 0.5;

            if (menu.mode === 'status') {
                // ã¤ã‚ˆã•ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ï¼‰
                ctx.fillStyle = '#fff';
                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.textAlign = 'left';

                // è¤‡æ•°ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ã‚‹å ´åˆã¯ãƒ¡ãƒ³ãƒãƒ¼é¸æŠè¡¨ç¤º
                if (party.length > 1) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ï¼ˆå·¦å´ï¼‰
                    const memberListX = menuX + 15;
                    const memberListY = contentY + 5;
                    const memberListWidth = menuWidth * 0.28;

                    ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    party.forEach((member, idx) => {
                        const isSelected = idx === menu.memberCursor;
                        const isDead = !member.isAlive || member.hp <= 0;

                        if (isSelected) {
                            ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                            ctx.fillRect(memberListX - 5, memberListY + idx * lineHeight * 0.9 - 3, memberListWidth, lineHeight * 0.85);
                        }

                        ctx.fillStyle = isSelected ? '#ffd700' : (isDead ? '#888' : '#fff');
                        const cursor = isSelected ? 'â–¶' : ' ';
                        ctx.fillText(`${cursor}${member.name}`, memberListX, memberListY + idx * lineHeight * 0.9);
                    });

                    // åŒºåˆ‡ã‚Šç·š
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(menuX + memberListWidth + 20, contentY);
                    ctx.lineTo(menuX + memberListWidth + 20, menuY + menuHeight - 35);
                    ctx.stroke();
                }

                // é¸æŠä¸­ã®ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
                const selectedMember = party[menu.memberCursor] || party[0];
                const col1X = party.length > 1 ? menuX + menuWidth * 0.32 : menuX + 20;
                const col2X = party.length > 1 ? menuX + menuWidth * 0.75 : menuX + menuWidth * 0.55;
                let y = contentY + 10;

                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.fillStyle = '#ffd700';
                ctx.fillText(selectedMember.name, col1X, y);
                ctx.fillStyle = '#fff';
                ctx.fillText(`Lv ${selectedMember.level}`, col2X, y);
                y += lineHeight * 1.3;

                ctx.fillText(`HP`, col1X, y);
                const hpColor = selectedMember.hp <= selectedMember.maxHp * 0.25 ? '#f44' :
                               selectedMember.hp <= selectedMember.maxHp * 0.5 ? '#ff4' : '#fff';
                ctx.fillStyle = hpColor;
                ctx.fillText(`${selectedMember.hp} / ${selectedMember.maxHp}`, col2X, y);
                ctx.fillStyle = '#fff';
                y += lineHeight;

                ctx.fillText(`MP`, col1X, y);
                ctx.fillText(`${selectedMember.mp} / ${selectedMember.maxMp}`, col2X, y);
                y += lineHeight * 1.3;

                ctx.fillText(`ã¡ã‹ã‚‰`, col1X, y);
                ctx.fillText(`${selectedMember.baseAtk}`, col2X, y);
                y += lineHeight;

                ctx.fillText(`ã¿ã®ã¾ã‚‚ã‚Š`, col1X, y);
                ctx.fillText(`${selectedMember.baseDef}`, col2X, y);
                y += lineHeight;

                ctx.fillText(`ã™ã°ã‚„ã•`, col1X, y);
                ctx.fillText(`${selectedMember.speed}`, col2X, y);
                y += lineHeight;

                // ã“ã†ã’ãåŠ›ãƒ»ã—ã‚…ã³åŠ›ï¼ˆè£…å‚™è¾¼ã¿ï¼‰
                ctx.fillStyle = '#4f4';
                ctx.fillText(`ã“ã†ã’ãåŠ›`, col1X, y);
                ctx.fillText(`${selectedMember.actualAtk}`, col2X, y);
                y += lineHeight;

                ctx.fillText(`ã—ã‚…ã³åŠ›`, col1X, y);
                ctx.fillText(`${selectedMember.actualDef}`, col2X, y);
                ctx.fillStyle = '#fff';
                y += lineHeight * 0.8;

                ctx.fillText(`ã‘ã„ã‘ã‚“ã¡`, col1X, y);
                ctx.fillText(`${selectedMember.exp}`, col2X, y);
                y += lineHeight;

                // æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¾ã§ã®çµŒé¨“å€¤
                const nextLevelExp = selectedMember.level < expTable.length - 1 ? expTable[selectedMember.level + 1] : null;
                if (nextLevelExp !== null) {
                    const needed = nextLevelExp - selectedMember.exp;
                    ctx.fillText(`æ¬¡Lv`, col1X, y);
                    ctx.textAlign = 'right';
                    ctx.fillText(`${needed}`, menuX + menuWidth - 20, y);
                    ctx.textAlign = 'left';
                } else {
                    ctx.fillText(`ã•ã„ã ã„ãƒ¬ãƒ™ãƒ«`, col1X, y);
                }
                y += lineHeight * 1.3;

                ctx.fillStyle = '#ffd700';
                ctx.fillText(`ã‚´ãƒ¼ãƒ«ãƒ‰`, col1X, y);
                ctx.fillStyle = '#fff';
                ctx.fillText(`${partyData.gold} G`, col2X, y);
                y += lineHeight * 1.5;

                // è£…å‚™è¡¨ç¤º
                ctx.fillStyle = '#aaa';
                ctx.fillText('â”€ ãã†ã³ â”€', col1X, y);
                y += lineHeight;

                const weapon = items[selectedMember.equipment?.weapon];
                const armor = items[selectedMember.equipment?.armor];
                ctx.fillStyle = '#fff';
                ctx.fillText(`âš”ï¸ E: ${weapon ? weapon.name : 'ãªã—'}`, col1X, y);
                y += lineHeight;
                ctx.fillText(`ğŸ›¡ï¸ E: ${armor ? armor.name : 'ãªã—'}`, col1X, y);

            } else if (menu.mode === 'spells') {
                // ã˜ã‚…ã‚‚ã‚“ï¼ˆå‘ªæ–‡ç”»é¢ï¼‰
                ctx.fillStyle = '#fff';
                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.textAlign = 'left';

                // è¤‡æ•°ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ã‚‹å ´åˆã¯ãƒ¡ãƒ³ãƒãƒ¼é¸æŠè¡¨ç¤º
                if (party.length > 1) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ï¼ˆå·¦å´ï¼‰
                    const memberListX = menuX + 15;
                    const memberListY = contentY + 5;
                    const memberListWidth = menuWidth * 0.28;

                    ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    party.forEach((member, idx) => {
                        const isSelected = idx === menu.memberCursor;
                        const isDead = !member.isAlive || member.hp <= 0;

                        if (isSelected) {
                            ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                            ctx.fillRect(memberListX - 5, memberListY + idx * lineHeight * 0.9 - 3, memberListWidth, lineHeight * 0.85);
                        }

                        ctx.fillStyle = isSelected ? '#ffd700' : (isDead ? '#888' : '#fff');
                        const cursor = isSelected ? 'â–¶' : ' ';
                        ctx.fillText(`${cursor}${member.name}`, memberListX, memberListY + idx * lineHeight * 0.9);
                    });

                    // åŒºåˆ‡ã‚Šç·š
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(menuX + memberListWidth + 20, contentY);
                    ctx.lineTo(menuX + memberListWidth + 20, menuY + menuHeight - 35);
                    ctx.stroke();
                }

                // é¸æŠä¸­ã®ãƒ¡ãƒ³ãƒãƒ¼ã®å‘ªæ–‡è¡¨ç¤º
                const selectedMember = party[menu.memberCursor] || party[0];
                const spellListX = party.length > 1 ? menuX + menuWidth * 0.32 : menuX + 30;
                const spellStartY = contentY + 10;

                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;

                if (selectedMember.spells.length === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    const centerX = party.length > 1 ? menuX + menuWidth * 0.65 : canvasWidth / 2;
                    ctx.textAlign = 'center';
                    ctx.fillText('å‘ªæ–‡ã‚’è¦šãˆã¦ã„ãªã„', centerX, spellStartY);
                } else {
                    ctx.textAlign = 'left';
                    selectedMember.spells.forEach((spellId, i) => {
                        const spell = spells[spellId];
                        if (spell) {
                            const isSelected = (i === menu.spellCursor);
                            const canUseInField = spell.type === 'heal' || spell.type === 'travel';

                            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ä½¿ãˆãªã„å‘ªæ–‡ã¯æš—ãè¡¨ç¤º
                            if (canUseInField) {
                                ctx.fillStyle = isSelected ? '#ffd700' : '#fff';
                            } else {
                                ctx.fillStyle = isSelected ? '#aa8800' : 'rgba(255, 255, 255, 0.4)';
                            }

                            const cursor = isSelected ? 'â–¶' : 'ãƒ»';
                            ctx.fillText(`${cursor}${spell.name}`, spellListX, spellStartY + i * lineHeight);

                            // MPè¡¨ç¤º
                            ctx.fillStyle = selectedMember.mp >= spell.mp ? '#88f' : '#f44';
                            ctx.fillText(`${spell.mp}MP`, menuX + menuWidth - 70, spellStartY + i * lineHeight);
                        }
                    });

                    // ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰æ™‚ï¼ˆå›å¾©å‘ªæ–‡ã®å¯¾è±¡é¸æŠï¼‰
                    if (menu.selectingMember) {
                        const targetWindowWidth = menuWidth * 0.35;
                        const targetWindowHeight = tileSize * (party.length * 0.6 + 0.5);
                        const targetWindowX = menuX + menuWidth - targetWindowWidth - 15;
                        const targetWindowY = menuY + menuHeight - targetWindowHeight - 40;

                        drawWindow(targetWindowX, targetWindowY, targetWindowWidth, targetWindowHeight);

                        ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.fillText('ã ã‚Œã«ï¼Ÿ', targetWindowX + targetWindowWidth / 2, targetWindowY + 12);

                        ctx.textAlign = 'left';
                        party.forEach((member, idx) => {
                            const isTarget = idx === menu.targetMemberCursor;
                            ctx.fillStyle = isTarget ? '#ffd700' : '#fff';
                            const cursor = isTarget ? 'â–¶' : ' ';
                            ctx.fillText(`${cursor}${member.name}`, targetWindowX + 15, targetWindowY + 35 + idx * lineHeight * 0.8);
                        });
                    }
                }
            } else if (menu.mode === 'items') {
                // ã‚‚ã¡ã‚‚ã®ï¼ˆã‚¢ã‚¤ãƒ†ãƒ ç”»é¢ï¼‰- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ
                ctx.fillStyle = '#fff';
                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.textAlign = 'left';
                const itemStartY = contentY + 10;

                // æœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆéš™é–“é˜²æ­¢ï¼‰
                const validItems = player.inventory.filter(slot => items[slot.id]);
                // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é«˜ã•ã‹ã‚‰åˆ©ç”¨å¯èƒ½ãªè¡Œæ•°ã‚’è¨ˆç®—ï¼ˆçŸ¢å°ç”¨ã®ä½™ç™½ã‚’è€ƒæ…®ï¼‰
                const availableHeight = (menuY + menuHeight) - itemStartY - lineHeight;
                const maxVisibleItems = Math.max(6, Math.floor(availableHeight / lineHeight));

                if (validItems.length === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.textAlign = 'center';
                    ctx.fillText('ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒã£ã¦ã„ãªã„', canvasWidth / 2, itemStartY);
                } else {
                    // ã‚«ãƒ¼ã‚½ãƒ«ãŒæœ‰åŠ¹ç¯„å›²ã‚’è¶…ãˆãªã„ã‚ˆã†èª¿æ•´
                    if (menu.itemCursor >= validItems.length) {
                        menu.itemCursor = Math.max(0, validItems.length - 1);
                    }

                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
                    let itemScrollOffset = 0;
                    if (validItems.length > maxVisibleItems) {
                        if (menu.itemCursor >= maxVisibleItems) {
                            itemScrollOffset = Math.min(
                                menu.itemCursor - maxVisibleItems + 1,
                                validItems.length - maxVisibleItems
                            );
                        }
                    }

                    // ä¸ŠçŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                    if (itemScrollOffset > 0) {
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.fillText('â–²', menuX + menuWidth / 2, itemStartY - 5);
                        ctx.textAlign = 'left';
                    }

                    const visibleCount = Math.min(validItems.length, maxVisibleItems);
                    for (let i = 0; i < visibleCount; i++) {
                        const itemIdx = i + itemScrollOffset;
                        if (itemIdx >= validItems.length) break;

                        const slot = validItems[itemIdx];
                        const item = items[slot.id];
                        const y = itemStartY + i * lineHeight;

                        // é¸æŠä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                        const isSelected = (itemIdx === menu.itemCursor);
                        ctx.fillStyle = isSelected ? '#ffd700' : '#fff';
                        const cursor = isSelected ? 'â–¶' : 'ãƒ»';

                        // å€‹æ•°è¡¨ç¤ºï¼ˆ2å€‹ä»¥ä¸Šã®å ´åˆï¼‰
                        let displayName = item.name;
                        if (slot.quantity > 1) {
                            displayName += ` x ${slot.quantity}`;
                        }
                        ctx.fillText(`${cursor}${displayName}`, menuX + 30, y);

                        // è£…å‚™å“ã«ã¯ã‚¿ã‚¤ãƒ—è¡¨ç¤º
                        if (item.type === 'weapon') {
                            ctx.fillStyle = '#88f';
                            ctx.fillText('âš”ï¸', menuX + menuWidth - 50, y);
                        } else if (item.type === 'armor') {
                            ctx.fillStyle = '#8f8';
                            ctx.fillText('ğŸ›¡ï¸', menuX + menuWidth - 50, y);
                        }
                    }

                    // ä¸‹çŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                    if (itemScrollOffset + maxVisibleItems < validItems.length) {
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.fillText('â–¼', menuX + menuWidth / 2, itemStartY + visibleCount * lineHeight + 5);
                        ctx.textAlign = 'left';
                    }

                    // ã‚¢ã‚¤ãƒ†ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼
                    if (menu.showItemAction && validItems.length > 0) {
                        const slot = validItems[menu.itemCursor];
                        const selectedItemId = slot ? slot.id : null;
                        const selectedItem = selectedItemId ? items[selectedItemId] : null;
                        if (selectedItem) {
                            const subMenuWidth = tileSize * 3.5;
                            const subMenuHeight = tileSize * 2.5;
                            const subMenuX = menuX + menuWidth - subMenuWidth - 20;
                            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’è€ƒæ…®ã—ãŸç”»é¢ä¸Šã®Yåº§æ¨™
                            const visibleCursorPos = menu.itemCursor - itemScrollOffset;
                            const subMenuY = itemStartY + visibleCursorPos * lineHeight - 5;

                            drawWindow(subMenuX, subMenuY, subMenuWidth, subMenuHeight);

                            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                            ctx.textAlign = 'left';

                            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠè‚¢
                            let actions = [];
                            if (selectedItem.type === 'weapon' || selectedItem.type === 'armor') {
                                actions = ['ãã†ã³ã™ã‚‹', 'ã™ã¦ã‚‹', 'ã›ã„ã¨ã‚“', 'ã‚„ã‚ã‚‹'];
                            } else {
                                actions = ['ã¤ã‹ã†', 'ã™ã¦ã‚‹', 'ã›ã„ã¨ã‚“', 'ã‚„ã‚ã‚‹'];
                            }

                            actions.forEach((action, i) => {
                                const isActionSelected = (i === menu.itemActionIndex);
                                ctx.fillStyle = isActionSelected ? '#ffd700' : '#fff';
                                const actionCursor = isActionSelected ? 'â–¶' : ' ';
                                ctx.fillText(`${actionCursor}${action}`, subMenuX + 15, subMenuY + 20 + i * (tileSize * 0.45));
                            });
                        }
                    }

                    // è£…å‚™å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
                    if (menu.selectingEquipMember) {
                        const slot = validItems[menu.itemCursor];
                        const selectedItem = slot ? items[slot.id] : null;
                        if (selectedItem) {
                            const equipMenuWidth = tileSize * 4;
                            const equipMenuHeight = tileSize * 0.5 * party.length + tileSize * 0.8;
                            const equipMenuX = menuX + menuWidth - equipMenuWidth - 20;
                            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’è€ƒæ…®ã—ãŸç”»é¢ä¸Šã®Yåº§æ¨™
                            const visibleCursorPos = menu.itemCursor - itemScrollOffset;
                            const equipMenuY = itemStartY + visibleCursorPos * lineHeight - 5;

                            drawWindow(equipMenuX, equipMenuY, equipMenuWidth, equipMenuHeight);

                            ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                            ctx.textAlign = 'left';
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('ã ã‚Œã«ï¼Ÿ', equipMenuX + 12, equipMenuY + 18);

                            party.forEach((member, i) => {
                                const isSelected = (i === menu.targetMemberCursor);
                                const canEquip = selectedItem.equippable ? selectedItem.equippable.includes(member.job) : true;

                                if (isSelected) {
                                    ctx.fillStyle = canEquip ? '#ffd700' : '#888';
                                } else {
                                    ctx.fillStyle = canEquip ? '#fff' : '#666';
                                }
                                const cursor = isSelected ? 'â–¶' : ' ';
                                const equipMark = canEquip ? '' : 'Ã—';
                                ctx.fillText(`${cursor}${member.name}${equipMark}`, equipMenuX + 12, equipMenuY + 18 + (i + 1) * (tileSize * 0.5));
                            });
                        }
                    }

                    // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
                    if (menu.selectingItemMember) {
                        const slot = validItems[menu.itemCursor];
                        const selectedItem = slot ? items[slot.id] : null;
                        if (selectedItem) {
                            const itemMenuWidth = tileSize * 4;
                            const itemMenuHeight = tileSize * 0.5 * party.length + tileSize * 0.8;
                            const itemMenuX = menuX + menuWidth - itemMenuWidth - 20;
                            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’è€ƒæ…®ã—ãŸç”»é¢ä¸Šã®Yåº§æ¨™
                            const visibleCursorPos = menu.itemCursor - itemScrollOffset;
                            const itemMenuY = itemStartY + visibleCursorPos * lineHeight - 5;

                            drawWindow(itemMenuX, itemMenuY, itemMenuWidth, itemMenuHeight);

                            ctx.font = `${tileSize * 0.32}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                            ctx.textAlign = 'left';
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('ã ã‚Œã«ï¼Ÿ', itemMenuX + 12, itemMenuY + 18);

                            party.forEach((member, i) => {
                                const isSelected = (i === menu.targetMemberCursor);
                                const isDead = !member.isAlive || member.hp <= 0;

                                if (isSelected) {
                                    ctx.fillStyle = isDead ? '#888' : '#ffd700';
                                } else {
                                    ctx.fillStyle = isDead ? '#666' : '#fff';
                                }
                                const cursor = isSelected ? 'â–¶' : ' ';
                                ctx.fillText(`${cursor}${member.name}`, itemMenuX + 12, itemMenuY + 18 + (i + 1) * (tileSize * 0.5));
                            });
                        }
                    }
                }
            } else if (menu.mode === 'map') {
                // ã¡ãšï¼ˆãƒãƒƒãƒ—ç”»é¢ã¸ã®æ¡ˆå†…ï¼‰
                ctx.fillStyle = '#fff';
                ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.textAlign = 'center';

                const mapInfoY = contentY + 30;
                ctx.fillStyle = '#ffd700';
                ctx.fillText(`ğŸ“ ${currentMap.name || 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰'}`, canvasWidth / 2, mapInfoY);

                ctx.fillStyle = '#fff';
                ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.fillText('Aãƒœã‚¿ãƒ³ã§åœ°å›³ã‚’é–‹ã', canvasWidth / 2, mapInfoY + lineHeight * 2);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.fillText('ï¼ˆMã‚­ãƒ¼ã§ã„ã¤ã§ã‚‚é–‹ã‘ã¾ã™ï¼‰', canvasWidth / 2, mapInfoY + lineHeight * 3.5);
            }

            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'center';
            if ((menu.mode === 'items' && player.inventory.length > 0) ||
                (menu.mode === 'spells' && player.spells.length > 0)) {
                if (party.length > 1 && menu.mode === 'spells') {
                    ctx.fillText('â†‘â†“é¸æŠ / åå‰ã‚¿ãƒƒãƒ—ã§åˆ‡æ›¿ / Aæ±ºå®š', canvasWidth / 2, menuY + menuHeight - 25);
                } else {
                    ctx.fillText('â†‘â†“é¸æŠ / Aæ±ºå®š / Bæˆ»ã‚‹', canvasWidth / 2, menuY + menuHeight - 25);
                }
            } else if (menu.mode === 'map') {
                ctx.fillText('Aæ±ºå®š / â† â†’ ã‚¿ãƒ–åˆ‡æ›¿ / Bã§é–‰ã˜ã‚‹', canvasWidth / 2, menuY + menuHeight - 25);
            } else if (menu.mode === 'status' && party.length > 1) {
                ctx.fillText('åå‰ã‚¿ãƒƒãƒ—ã§åˆ‡æ›¿ / â† â†’ ã‚¿ãƒ–åˆ‡æ›¿ / Bã§é–‰ã˜ã‚‹', canvasWidth / 2, menuY + menuHeight - 25);
            } else {
                ctx.fillText('â† â†’ ã‚¿ãƒ–åˆ‡æ›¿ / Bã§é–‰ã˜ã‚‹', canvasWidth / 2, menuY + menuHeight - 25);
            }
        }

        function drawInn() {
            if (!inn.active) return;

            const windowWidth = canvasWidth * 0.8;
            const windowHeight = tileSize * 3.5;
            const windowX = (canvasWidth - windowWidth) / 2;
            const windowY = (canvasHeight - windowHeight) / 2;

            drawWindow(windowX, windowY, windowWidth, windowHeight);

            ctx.fillStyle = '#fff';
            ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            ctx.fillText(`ãŠã¨ã¾ã‚Šã§ã™ã‹ï¼Ÿï¼ˆ${inn.cost}ã‚´ãƒ¼ãƒ«ãƒ‰ï¼‰`, windowX + 20, windowY + 20);

            // é¸æŠè‚¢
            const choiceY = windowY + tileSize * 1.5;
            const choices = ['ã¯ã„', 'ã„ã„ãˆ'];

            choices.forEach((choice, i) => {
                const choiceX = windowX + 40 + i * tileSize * 2.5;
                if (i === inn.selectedIndex) {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                }
                ctx.fillStyle = '#fff';
                ctx.fillText(choice, choiceX, choiceY);
            });

            // æ‰€æŒé‡‘è¡¨ç¤º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.fillText(`æ‰€æŒé‡‘: ${player.gold} G`, windowX + 20, windowY + windowHeight - tileSize * 0.6);
        }

        function drawChurch() {
            if (!church.active) return;

            const windowWidth = canvasWidth * 0.85;
            const windowHeight = tileSize * 5;
            const windowX = (canvasWidth - windowWidth) / 2;
            const windowY = (canvasHeight - windowHeight) / 2;

            drawWindow(windowX, windowY, windowWidth, windowHeight);

            ctx.fillStyle = '#fff';
            ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            if (church.phase === 'menu') {
                ctx.fillText('ç¥ã®ã”åŠ è­·ãŒã‚ã‚Šã¾ã™ã‚ˆã†ã«ã€‚', windowX + 20, windowY + 15);
                ctx.fillText('ã©ã®ã‚ˆã†ãª ã”ç”¨ä»¶ã§ã™ã‹ï¼Ÿ', windowX + 20, windowY + 15 + tileSize * 0.6);

                const menuItems = ['ã„ãã‹ãˆã‚‰ã›ã‚‹', 'ã©ãã®ã¡ã‚Šã‚‡ã†', 'ãŠã„ã®ã‚Šã‚’ã™ã‚‹', 'ã‚„ã‚ã‚‹'];
                const startY = windowY + tileSize * 1.8;

                menuItems.forEach((item, i) => {
                    const y = startY + i * tileSize * 0.7;
                    if (i === church.menuIndex) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('â–¶', windowX + 25, y);
                    }
                    ctx.fillStyle = '#fff';
                    ctx.fillText(item, windowX + 50, y);
                });
            } else if (church.phase === 'selectMember') {
                const actionText = church.menuIndex === 0 ? 'ã„ãã‹ãˆã‚‰ã›ã‚‹' : 'ã©ãã‚’ãªãŠã™';
                ctx.fillText(`ã ã‚Œã‚’ ${actionText}ï¼Ÿ`, windowX + 20, windowY + 15);

                const startY = windowY + tileSize * 1.2;
                party.forEach((member, i) => {
                    const y = startY + i * tileSize * 0.8;
                    const isDead = !member.isAlive || member.hp <= 0;
                    const isPoisoned = member.status && member.status.poison > 0;

                    // é¸æŠã‚«ãƒ¼ã‚½ãƒ«
                    if (i === church.selectedMember) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('â–¶', windowX + 25, y);
                    }

                    // ãƒ¡ãƒ³ãƒãƒ¼åã¨çŠ¶æ…‹
                    ctx.fillStyle = isDead ? '#888' : (isPoisoned ? '#a0f' : '#fff');
                    let statusText = '';
                    if (isDead) statusText = ' [ã—ã‚“ã§ã„ã‚‹]';
                    else if (isPoisoned) statusText = ' [ã©ã]';

                    ctx.fillText(`${member.name} Lv${member.level}${statusText}`, windowX + 50, y);

                    // è²»ç”¨è¡¨ç¤º
                    if (church.menuIndex === 0 && isDead) {
                        ctx.fillStyle = '#ff8';
                        ctx.fillText(`${getReviveCost(member)}G`, windowX + windowWidth - 80, y);
                    } else if (church.menuIndex === 1 && isPoisoned) {
                        ctx.fillStyle = '#ff8';
                        ctx.fillText(`${getCureCost()}G`, windowX + windowWidth - 80, y);
                    }
                });
            } else if (church.phase === 'confirm') {
                const member = party[church.selectedMember];
                const cost = church.menuIndex === 0 ? getReviveCost(member) : getCureCost();
                const actionText = church.menuIndex === 0 ? 'ã„ãã‹ãˆã‚‰ã›ã¾ã™' : 'ã©ãã‚’ãªãŠã—ã¾ã™';

                ctx.fillText(`${member.name} ã‚’ ${actionText}ã€‚`, windowX + 20, windowY + 15);
                ctx.fillText(`${cost}ã‚´ãƒ¼ãƒ«ãƒ‰ ã‹ã‹ã‚Šã¾ã™ãŒ ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`, windowX + 20, windowY + 15 + tileSize * 0.6);

                const choiceY = windowY + tileSize * 2;
                const choices = ['ã¯ã„', 'ã„ã„ãˆ'];

                choices.forEach((choice, i) => {
                    const choiceX = windowX + 50 + i * tileSize * 2.5;
                    if (i === church.confirmIndex) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                    }
                    ctx.fillStyle = '#fff';
                    ctx.fillText(choice, choiceX, choiceY);
                });
            }

            // æ‰€æŒé‡‘è¡¨ç¤º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.fillText(`æ‰€æŒé‡‘: ${partyData.gold} G`, windowX + 20, windowY + windowHeight - tileSize * 0.5);
        }

        function drawPartyJoinConfirm() {
            if (!partyJoinConfirm.active) return;

            const windowWidth = canvasWidth * 0.7;
            const windowHeight = tileSize * 2.5;
            const windowX = (canvasWidth - windowWidth) / 2;
            const windowY = (canvasHeight - windowHeight) / 2;

            drawWindow(windowX, windowY, windowWidth, windowHeight);

            ctx.fillStyle = '#fff';
            ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            ctx.fillText('ä»²é–“ã«ã—ã¾ã™ã‹ï¼Ÿ', windowX + 20, windowY + 20);

            // é¸æŠè‚¢
            const choiceY = windowY + tileSize * 1.3;
            const choices = ['ã¯ã„', 'ã„ã„ãˆ'];

            choices.forEach((choice, i) => {
                const choiceX = windowX + 40 + i * tileSize * 2.5;
                if (i === partyJoinConfirm.selectedIndex) {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                }
                ctx.fillStyle = '#fff';
                ctx.fillText(choice, choiceX, choiceY);
            });
        }

        function drawShop() {
            if (!shop.active) return;

            const windowWidth = canvasWidth * 0.9;
            const windowHeight = canvasHeight * 0.75;
            const windowX = (canvasWidth - windowWidth) / 2;
            const windowY = (canvasHeight - windowHeight) / 2;

            drawWindow(windowX, windowY, windowWidth, windowHeight);

            ctx.fillStyle = '#ffd700';
            ctx.font = `${tileSize * 0.5}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('âš”ï¸ ã¶ãã¼ã†ãã‚„ ğŸ›¡ï¸', canvasWidth / 2, windowY + 15);

            // æ‰€æŒé‡‘è¡¨ç¤º
            ctx.fillStyle = '#fff';
            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'right';
            ctx.fillText(`ğŸ’° ${player.gold} G`, windowX + windowWidth - 20, windowY + 15);

            const listY = windowY + tileSize * 1.2;
            const lineHeight = tileSize * 0.55;

            if (shop.mode === 'menu') {
                // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠ
                ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.textAlign = 'left';
                const menuItems = ['ã‹ã†', 'ã†ã‚‹', 'ã‚„ã‚ã‚‹'];
                menuItems.forEach((menuItem, i) => {
                    const y = listY + i * lineHeight * 1.5;
                    if (i === shop.menuIndex) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('â–¶', windowX + 30, y);
                    }
                    ctx.fillStyle = '#fff';
                    ctx.fillText(menuItem, windowX + 60, y);
                });

            } else if (shop.mode === 'buy') {
                if (shop.phase === 'list') {
                    // è³¼å…¥ãƒªã‚¹ãƒˆ
                    ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';

                    getShopItems().forEach((itemId, i) => {
                        const item = items[itemId];
                        const y = listY + i * lineHeight;

                        if (i === shop.selectedIndex) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('â–¶', windowX + 15, y);
                        }

                        const icon = item.type === 'weapon' ? 'âš”ï¸' : 'ğŸ›¡ï¸';
                        ctx.fillStyle = player.gold >= item.price ? '#fff' : '#666';
                        ctx.fillText(`${icon} ${item.name}`, windowX + 40, y);
                        ctx.fillText(`${item.price} G`, windowX + windowWidth * 0.55, y);

                        if (i === shop.selectedIndex) {
                            const statChange = getStatChangePreview(item);
                            ctx.fillStyle = statChange > 0 ? '#4f4' : (statChange < 0 ? '#f44' : '#fff');
                            const sign = statChange > 0 ? '+' : '';
                            const statLabel = item.type === 'weapon' ? 'ã“ã†ã’ã' : 'ã—ã‚…ã³';
                            ctx.fillText(`${statLabel} ${sign}${statChange}`, windowX + windowWidth * 0.78, y);
                        }
                    });

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('â†‘â†“ é¸æŠ / A è³¼å…¥ / B æˆ»ã‚‹', canvasWidth / 2, windowY + windowHeight - 25);

                } else if (shop.phase === 'confirm') {
                    const item = shop.selectedItem;
                    ctx.fillStyle = '#fff';
                    ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(`${item.name} ã‚’ ã‹ã„ã¾ã™ã‹ï¼Ÿ`, windowX + 30, listY);
                    ctx.fillText(`ï¼ˆ${item.price} ã‚´ãƒ¼ãƒ«ãƒ‰ï¼‰`, windowX + 30, listY + lineHeight);

                    const choiceY = listY + lineHeight * 3;
                    ['ã¯ã„', 'ã„ã„ãˆ'].forEach((choice, i) => {
                        const choiceX = windowX + 50 + i * tileSize * 2.5;
                        if (i === shop.confirmIndex) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                        }
                        ctx.fillStyle = '#fff';
                        ctx.fillText(choice, choiceX, choiceY);
                    });

                } else if (shop.phase === 'equip') {
                    const item = shop.selectedItem;
                    ctx.fillStyle = '#fff';
                    ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(`${item.name} ã‚’ ã¦ã«ã„ã‚ŒãŸï¼`, windowX + 30, listY);
                    ctx.fillText('ãã†ã³ ã—ã¾ã™ã‹ï¼Ÿ', windowX + 30, listY + lineHeight);

                    const choiceY = listY + lineHeight * 3;
                    ['ã¯ã„', 'ã„ã„ãˆ'].forEach((choice, i) => {
                        const choiceX = windowX + 50 + i * tileSize * 2.5;
                        if (i === shop.equipIndex) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                        }
                        ctx.fillStyle = '#fff';
                        ctx.fillText(choice, choiceX, choiceY);
                    });
                }

            } else if (shop.mode === 'sell') {
                if (shop.phase === 'list') {
                    // å£²å´ãƒªã‚¹ãƒˆ
                    ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';

                    if (shop.sellableItems.length === 0) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.textAlign = 'center';
                        ctx.fillText('ã†ã‚Œã‚‹ã‚‚ã®ãŒ ã‚ã‚Šã¾ã›ã‚“', canvasWidth / 2, listY + lineHeight);
                    } else {
                        shop.sellableItems.forEach((slot, i) => {
                            const item = items[slot.id];
                            const y = listY + i * lineHeight;
                            const sellPrice = Math.floor(item.price / 2);

                            if (i === shop.selectedIndex) {
                                ctx.fillStyle = '#ffd700';
                                ctx.fillText('â–¶', windowX + 15, y);
                            }

                            const icon = item.type === 'weapon' ? 'âš”ï¸' : (item.type === 'armor' ? 'ğŸ›¡ï¸' : 'ğŸ“¦');
                            ctx.fillStyle = '#fff';
                            // å€‹æ•°è¡¨ç¤ºï¼ˆ2å€‹ä»¥ä¸Šã®å ´åˆï¼‰
                            let displayName = item.name;
                            if (slot.quantity > 1) {
                                displayName += ` x ${slot.quantity}`;
                            }
                            ctx.fillText(`${icon} ${displayName}`, windowX + 40, y);
                            ctx.fillText(`${sellPrice} G`, windowX + windowWidth * 0.65, y);
                        });
                    }

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('â†‘â†“ é¸æŠ / A å£²å´ / B æˆ»ã‚‹', canvasWidth / 2, windowY + windowHeight - 25);

                } else if (shop.phase === 'confirm') {
                    const item = shop.selectedItem;
                    const sellPrice = Math.floor(item.price / 2);
                    ctx.fillStyle = '#fff';
                    ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(`${item.name} ã‚’ ã†ã‚Šã¾ã™ã‹ï¼Ÿ`, windowX + 30, listY);
                    ctx.fillText(`ï¼ˆ${sellPrice} ã‚´ãƒ¼ãƒ«ãƒ‰ï¼‰`, windowX + 30, listY + lineHeight);

                    const choiceY = listY + lineHeight * 3;
                    ['ã¯ã„', 'ã„ã„ãˆ'].forEach((choice, i) => {
                        const choiceX = windowX + 50 + i * tileSize * 2.5;
                        if (i === shop.confirmIndex) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('â–¶', choiceX - tileSize * 0.5, choiceY);
                        }
                        ctx.fillStyle = '#fff';
                        ctx.fillText(choice, choiceX, choiceY);
                    });

                } else if (shop.phase === 'sold') {
                    const item = shop.selectedItem;
                    const sellPrice = Math.floor(item.price / 2);
                    ctx.fillStyle = '#fff';
                    ctx.font = `${tileSize * 0.45}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(`${item.name} ã‚’ ã†ã‚Šã¾ã—ãŸï¼`, windowX + 30, listY);
                    ctx.fillText(`${sellPrice} ã‚´ãƒ¼ãƒ«ãƒ‰ ã¦ã«ã„ã‚ŒãŸï¼`, windowX + 30, listY + lineHeight);
                }
            }
        }

        // è£…å‚™å¤‰æ›´æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function getStatChangePreview(item) {
            if (item.type === 'weapon') {
                const currentWeapon = items[player.equipment.weapon];
                const currentValue = currentWeapon ? currentWeapon.value : 0;
                return item.value - currentValue;
            } else if (item.type === 'armor') {
                const currentArmor = items[player.equipment.armor];
                const currentValue = currentArmor ? currentArmor.value : 0;
                return item.value - currentValue;
            }
            return 0;
        }

        // ========================================
        // ãƒãƒˆãƒ«æç”»
        // ========================================
        // å‘ªæ–‡ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚’é–‹å§‹
        function startSpellFlash(color, isUltimate = false, spellType = 'attack') {
            // å‘ªæ–‡ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸSE
            if (spellType === 'attack') SE.magicAttack();
            else if (spellType === 'heal' || spellType === 'revive') SE.heal();
            else if (spellType === 'buff') SE.buff();
            else if (spellType === 'status' || spellType === 'debuff') SE.debuff();
            else SE.magicAttack(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

            spellFlash.active = true;
            spellFlash.color = color;
            spellFlash.alpha = 1.0;

            if (isUltimate) {
                // ç©¶æ¥µé­”æ³•ã®è±ªè¯æ¼”å‡ºï¼šè¤‡æ•°å›ç‚¹æ»… + ç”»é¢ã‚·ã‚§ã‚¤ã‚¯
                let flashCount = 0;
                const maxFlashes = 4;

                // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã‚‚ç™ºå‹•
                screenShake.active = true;
                screenShake.intensity = 12;
                screenShake.duration = 30;

                const ultimateFlash = () => {
                    if (flashCount >= maxFlashes) {
                        // æœ€å¾Œã«ç™½ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã§ç· ã‚
                        spellFlash.color = 'rgba(255, 255, 255, 1.0)';
                        spellFlash.alpha = 1.0;

                        const finalFade = () => {
                            spellFlash.alpha -= 0.05;
                            if (spellFlash.alpha <= 0) {
                                spellFlash.active = false;
                                spellFlash.alpha = 0;
                            } else {
                                setTimeout(finalFade, 30);
                            }
                        };
                        setTimeout(finalFade, 150);
                        return;
                    }

                    // ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    spellFlash.alpha = 1.0;
                    setTimeout(() => {
                        spellFlash.alpha = 0.3;
                        setTimeout(() => {
                            flashCount++;
                            ultimateFlash();
                        }, 80);
                    }, 100);
                };
                ultimateFlash();
            } else {
                // é€šå¸¸å‘ªæ–‡ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå‡¦ç†
                const fadeOut = () => {
                    spellFlash.alpha -= 0.1;
                    if (spellFlash.alpha <= 0) {
                        spellFlash.active = false;
                        spellFlash.alpha = 0;
                    } else {
                        setTimeout(fadeOut, 50);
                    }
                };
                setTimeout(fadeOut, 100);
            }
        }

        // ç©¶æ¥µé­”æ³•ã®ãƒªã‚¹ãƒˆ
        const ULTIMATE_SPELLS = ['merazoma', 'gigadein', 'minadein', 'begiragon', 'behomazun'];

        function drawBattle() {
            // èƒŒæ™¯
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // æˆ¦é—˜é–‹å§‹ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            if (battle.flashCount > 0) {
                const alpha = (battle.flashCount % 2 === 0) ? 0.8 : 0;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                return;
            }

            // å‘ªæ–‡ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            if (spellFlash.active && spellFlash.alpha > 0) {
                // è‰²ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’é©ç”¨
                const baseColor = spellFlash.color.replace(/[\d.]+\)$/, `${spellFlash.alpha})`);
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }

            // è¤‡æ•°ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼è¡¨ç¤º
            if (battle.enemies && battle.enemies.length > 0) {
                const enemyCount = battle.enemies.length;
                const spacing = canvasWidth / (enemyCount + 1);
                const spriteSize = enemyCount === 1 ? tileSize * 4 : tileSize * (3 - enemyCount * 0.3);

                battle.enemies.forEach((enemy, idx) => {
                    const x = spacing * (idx + 1);
                    const y = canvasHeight * 0.35;

                    // æ­»äº¡ã—ã¦ã„ã‚‹æ•µã¯è–„ãè¡¨ç¤º
                    const isDead = enemy.currentHp <= 0;
                    if (isDead) {
                        ctx.globalAlpha = 0.3;
                    }

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
                    ctx.font = `${spriteSize}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // è‰²é•ã„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å¯¾å¿œï¼ˆhueRotateãƒ•ã‚£ãƒ«ã‚¿ï¼‰
                    if (enemy.hueRotate) {
                        ctx.save();
                        ctx.filter = `hue-rotate(${enemy.hueRotate}deg)`;
                        ctx.fillText(enemy.sprite, x, y);
                        ctx.restore();
                    } else {
                        ctx.fillText(enemy.sprite, x, y);
                    }

                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠä¸­ã®ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
                    if (battle.isSelectingTarget && idx === battle.targetIndex && !isDead) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = `${tileSize * 0.8}px serif`;
                        ctx.fillText('ğŸ‘†', x, y - spriteSize / 2 - tileSize * 0.3);
                    }

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼åï¼ˆå„æ•µã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä¸‹ã«å€‹åˆ¥è¡¨ç¤ºã€å¥‡æ•°ãƒ»å¶æ•°ã§Yåº§æ¨™ã‚’ãšã‚‰ã™ï¼‰
                    const nameYOffset = idx % 2 === 0 ? 0 : tileSize * 0.5;
                    const nameY = y + spriteSize / 2 + tileSize * 0.4 + nameYOffset;
                    ctx.fillStyle = isDead ? '#888' : '#fff';
                    ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.fillText(enemy.displayName, x, nameY);

                    // å€’ã—ãŸè¡¨ç¤ºï¼ˆHPã¯éè¡¨ç¤ºã§ç·Šå¼µæ„Ÿã‚’æ¼”å‡ºï¼‰
                    if (isDead && (battle.phase === 'command' || battle.phase === 'target')) {
                        ctx.fillStyle = '#888';
                        ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.fillText('å€’ã—ãŸ', x, nameY + tileSize * 0.4);
                    }

                    // çŠ¶æ…‹ç•°å¸¸ãƒãƒƒã‚¸ã‚’åå‰ã®ä¸‹ã«è¡¨ç¤º
                    if (!isDead) {
                        const enemyStatusBadge = getStatusBadges(enemy);
                        if (enemyStatusBadge) {
                            ctx.fillStyle = '#f88';
                            ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                            ctx.fillText(enemyStatusBadge, x, nameY + tileSize * 0.4);
                        }
                    }

                    ctx.globalAlpha = 1.0;
                });
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
            const aliveMembers = getAlivePartyMembers();
            const memberCount = party.length;
            const memberRowH = tileSize * 0.9;
            const statusW = canvasWidth * 0.85;
            const statusH = Math.max(tileSize * 2.5, 20 + memberRowH * memberCount);
            const statusX = 10;
            const statusY = 10;
            drawWindow(statusX, statusY, statusW, statusH);

            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            // å„ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
            party.forEach((member, idx) => {
                const rowY = statusY + 12 + idx * memberRowH;
                const isDead = !member.isAlive || member.hp <= 0;

                // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ä¸­ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                if (battle.phase === 'command' && idx === battle.currentPartyIndex) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fillRect(statusX + 5, rowY - 2, statusW - 10, memberRowH - 2);
                }

                // å‘³æ–¹é¸æŠä¸­ã®ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
                if (battle.isSelectingAlly && idx === battle.allyTargetIndex) {
                    ctx.fillStyle = 'rgba(0, 255, 100, 0.3)';
                    ctx.fillRect(statusX + 5, rowY - 2, statusW - 10, memberRowH - 2);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `${tileSize * 0.4}px serif`;
                    ctx.fillText('â–¶', statusX + 2, rowY);
                }

                // æˆ¦é—˜ä¸èƒ½ã¯æš—ãè¡¨ç¤º
                ctx.fillStyle = isDead ? '#666' : '#fff';

                // åå‰ã¨ãƒ¬ãƒ™ãƒ«
                const nameText = `${member.name} Lv${member.level}`;
                ctx.fillText(nameText, statusX + 12, rowY);

                // HP/MP
                const hpColor = member.hp <= member.maxHp * 0.25 ? '#f44' : (member.hp <= member.maxHp * 0.5 ? '#ff0' : '#8f8');
                const mpColor = member.mp <= member.maxMp * 0.25 ? '#f88' : '#8cf';

                ctx.fillStyle = isDead ? '#444' : hpColor;
                ctx.fillText(`HP:${member.hp}/${member.maxHp}`, statusX + 12 + tileSize * 3.2, rowY);

                ctx.fillStyle = isDead ? '#444' : mpColor;
                ctx.fillText(`MP:${member.mp}/${member.maxMp}`, statusX + 12 + tileSize * 5.5, rowY);

                // çŠ¶æ…‹ç•°å¸¸ãƒãƒƒã‚¸
                const memberBadge = getStatusBadges(member);
                if (memberBadge && !isDead) {
                    ctx.fillStyle = '#f88';
                    ctx.fillText(memberBadge, statusX + statusW - 50, rowY);
                }
            });

            // ãƒãƒ•çŠ¶æ…‹ãƒãƒƒã‚¸ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£å…¨ä½“ï¼‰
            const buffBadges = getBuffBadges();
            if (buffBadges) {
                ctx.fillStyle = '#8f8';
                ctx.font = `${tileSize * 0.3}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                ctx.fillText(buffBadges, statusX + statusW - 80, statusY + statusH - 18);
            }

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
            const msgPadding = 15;
            const msgWindowWidth = canvasWidth - 20;
            const msgMaxTextWidth = msgWindowWidth - msgPadding * 2;
            const msgFontSize = Math.floor(tileSize * 0.42);
            const msgLineHeight = msgFontSize * 1.4;
            const msgFont = `${msgFontSize}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;

            // æŠ˜ã‚Šè¿”ã—è¡Œæ•°ã«å¿œã˜ã¦ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é«˜ã•ã‚’èª¿æ•´
            const msgLines = wrapText(battle.message, msgMaxTextWidth, msgFont);
            const msgNumLines = Math.max(2, msgLines.length);
            const msgH = msgPadding * 2 + msgLineHeight * msgNumLines;
            const msgY = canvasHeight - msgH - 180;
            drawWindow(10, msgY, msgWindowWidth, msgH);

            ctx.fillStyle = '#fff';
            ctx.font = msgFont;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            for (let i = 0; i < msgLines.length; i++) {
                ctx.fillText(msgLines[i], 10 + msgPadding, msgY + msgPadding + i * msgLineHeight);
            }

            // ã‚³ãƒãƒ³ãƒ‰ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
            if (battle.phase === 'command') {
                const cmdW = canvasWidth * 0.45;
                const cmdH = tileSize * 3.7;
                const cmdX = canvasWidth - cmdW - 10;
                const cmdY = canvasHeight - cmdH - 10;
                drawWindow(cmdX, cmdY, cmdW, cmdH);

                const commands = ['ãŸãŸã‹ã†', 'ã˜ã‚…ã‚‚ã‚“', 'ã©ã†ã', 'ã«ã’ã‚‹'];
                ctx.font = `${tileSize * 0.5}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;

                commands.forEach((cmd, i) => {
                    const y = cmdY + 20 + i * tileSize * 0.7;
                    if (i === battle.commandIndex) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('â–¶', cmdX + 15, y);
                    }
                    ctx.fillStyle = '#fff';
                    ctx.fillText(cmd, cmdX + 40, y);
                });

                // å‘ªæ–‡ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‰
                if (battle.showSpells) {
                    const currentMember = getCurrentPartyMember();
                    const validSpells = currentMember.spells.filter(id => spells[id]);
                    const maxVisibleSpells = 5; // æœ€å¤§è¡¨ç¤ºä»¶æ•°
                    const spellW = cmdW * 1.1;
                    const rowHeight = tileSize * 0.6;
                    const visibleCount = Math.min(validSpells.length, maxVisibleSpells);
                    const spellH = rowHeight * visibleCount + 40; // ä¸Šä¸‹ä½™ç™½å«ã‚€
                    const spellX = cmdX - spellW - 10;
                    const spellY = cmdY;
                    drawWindow(spellX, spellY, spellW, spellH);

                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ãŒå¸¸ã«è¡¨ç¤ºç¯„å›²å†…ã«ãªã‚‹ã‚ˆã†èª¿æ•´ï¼‰
                    let scrollOffset = 0;
                    if (validSpells.length > maxVisibleSpells) {
                        // ã‚«ãƒ¼ã‚½ãƒ«ãŒä¸‹ç«¯ã‚’è¶…ãˆãŸã‚‰ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                        if (battle.spellIndex >= maxVisibleSpells) {
                            scrollOffset = Math.min(
                                battle.spellIndex - maxVisibleSpells + 1,
                                validSpells.length - maxVisibleSpells
                            );
                        }
                    }

                    // ä¸ŠçŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                    if (scrollOffset > 0) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText('â–²', spellX + spellW / 2, spellY + 12);
                        ctx.textAlign = 'left';
                    }

                    // å‘ªæ–‡ãƒªã‚¹ãƒˆæç”»
                    for (let i = 0; i < visibleCount; i++) {
                        const spellIdx = i + scrollOffset;
                        if (spellIdx >= validSpells.length) break;

                        const spellId = validSpells[spellIdx];
                        const spell = spells[spellId];
                        const y = spellY + 22 + i * rowHeight;
                        const canUse = currentMember.mp >= spell.mp;

                        // é¸æŠã‚«ãƒ¼ã‚½ãƒ«
                        if (spellIdx === battle.spellIndex) {
                            ctx.fillStyle = canUse ? '#ffd700' : '#888';
                            ctx.fillText('â–¶', spellX + 10, y);
                        }

                        // å‘ªæ–‡åã¨MPï¼ˆMPä¸è¶³ã¯ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆï¼‰
                        ctx.fillStyle = canUse ? '#fff' : '#555';
                        ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.fillText(`${spell.name}`, spellX + 30, y);

                        // MPæ¶ˆè²»é‡
                        ctx.fillStyle = canUse ? '#8cf' : '#444';
                        ctx.fillText(`${spell.mp}`, spellX + spellW - 40, y);
                    }

                    // ä¸‹çŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                    if (scrollOffset + maxVisibleSpells < validSpells.length) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText('â–¼', spellX + spellW / 2, spellY + spellH - 18);
                        ctx.textAlign = 'left';
                    }

                    // æ“ä½œã‚¬ã‚¤ãƒ‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = `${tileSize * 0.25}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.fillText('B:ã‚‚ã©ã‚‹', spellX + 10, spellY + spellH - 8);
                }

                // ã‚¢ã‚¤ãƒ†ãƒ ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‰
                if (battle.showItems) {
                    // æœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆéš™é–“é˜²æ­¢ï¼‰
                    const validItems = player.inventory.filter(slot => items[slot.id]);
                    const maxVisibleItems = 5; // æœ€å¤§è¡¨ç¤ºä»¶æ•°
                    const itemW = cmdW * 1.3;
                    const rowHeight = tileSize * 0.6;
                    const visibleCount = Math.min(validItems.length, maxVisibleItems);
                    const itemH = rowHeight * Math.max(1, visibleCount) + 40;
                    const itemX = cmdX - itemW - 10;
                    const itemY = cmdY;
                    drawWindow(itemX, itemY, itemW, itemH);

                    if (validItems.length === 0) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                        ctx.fillText('ã©ã†ããŒãªã„', itemX + 20, itemY + 30);
                    } else {
                        // ã‚«ãƒ¼ã‚½ãƒ«ãŒæœ‰åŠ¹ç¯„å›²ã‚’è¶…ãˆãªã„ã‚ˆã†èª¿æ•´
                        if (battle.itemCursor >= validItems.length) {
                            battle.itemCursor = Math.max(0, validItems.length - 1);
                        }

                        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
                        let itemScrollOffset = 0;
                        if (validItems.length > maxVisibleItems) {
                            if (battle.itemCursor >= maxVisibleItems) {
                                itemScrollOffset = Math.min(
                                    battle.itemCursor - maxVisibleItems + 1,
                                    validItems.length - maxVisibleItems
                                );
                            }
                        }

                        // ä¸ŠçŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                        if (itemScrollOffset > 0) {
                            ctx.fillStyle = '#ffd700';
                            ctx.textAlign = 'center';
                            ctx.fillText('â–²', itemX + itemW / 2, itemY + 12);
                            ctx.textAlign = 'left';
                        }

                        for (let i = 0; i < visibleCount; i++) {
                            const itemIdx = i + itemScrollOffset;
                            if (itemIdx >= validItems.length) break;

                            const slot = validItems[itemIdx];
                            const item = items[slot.id];
                            const y = itemY + 22 + i * rowHeight;
                            const canUse = item.type !== 'weapon' && item.type !== 'armor';

                            // é¸æŠã‚«ãƒ¼ã‚½ãƒ«
                            if (itemIdx === battle.itemCursor) {
                                ctx.fillStyle = canUse ? '#ffd700' : '#888';
                                ctx.fillText('â–¶', itemX + 10, y);
                            }

                            // ã‚¢ã‚¤ãƒ†ãƒ åï¼ˆè£…å‚™å“ã¯ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆï¼‰
                            ctx.fillStyle = canUse ? '#fff' : '#555';
                            ctx.font = `${tileSize * 0.4}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                            let displayName = item.name;
                            if (slot.quantity > 1) {
                                displayName += ` x ${slot.quantity}`;
                            }
                            ctx.fillText(displayName, itemX + 30, y);

                            // ã‚¿ã‚¤ãƒ—ã‚¢ã‚¤ã‚³ãƒ³
                            if (item.type === 'weapon') {
                                ctx.fillText('âš”ï¸', itemX + itemW - 40, y);
                            } else if (item.type === 'armor') {
                                ctx.fillText('ğŸ›¡ï¸', itemX + itemW - 40, y);
                            }
                        }

                        // ä¸‹çŸ¢å°ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ãªå ´åˆï¼‰
                        if (itemScrollOffset + maxVisibleItems < validItems.length) {
                            ctx.fillStyle = '#ffd700';
                            ctx.textAlign = 'center';
                            ctx.fillText('â–¼', itemX + itemW / 2, itemY + itemH - 18);
                            ctx.textAlign = 'left';
                        }
                    }

                    // æ“ä½œã‚¬ã‚¤ãƒ‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = `${tileSize * 0.25}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
                    ctx.fillText('B:ã‚‚ã©ã‚‹', itemX + 10, itemY + itemH - 10);
                }
            }
        }

        // ========================================
        // ãƒ¡ã‚¤ãƒ³æç”»
        // ========================================
        let drawDebugCount = 0;
        function draw() {
            // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ä¸­ã¯æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
            if (gameMode === MODE.TITLE) {
                return;
            }

            // ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã ã‘ãƒ­ã‚°å‡ºåŠ›
            // if (drawDebugCount < 5) {
            //     console.log('[DEBUG draw] gameMode:', gameMode, 'tileSize:', tileSize, 'canvasWidth:', canvasWidth, 'currentMap.data:', !!currentMap.data);
            //     drawDebugCount++;
            // }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†
            let shakeX = 0, shakeY = 0;
            if (screenShake.active) {
                shakeX = (Math.random() - 0.5) * screenShake.intensity;
                shakeY = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.duration--;
                if (screenShake.duration <= 0) {
                    screenShake.active = false;
                }
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            if (gameMode === MODE.ENDING) {
                drawEnding();
            } else if (gameMode === MODE.BATTLE) {
                drawBattle();
            } else {
                drawMap();
                drawChests();
                drawIceBlocks();
                drawNPCs();
                drawPlayer();
                drawMessageWindow();
                drawMenu();
                drawInn();
                drawChurch();
                drawShop();
                drawPartyJoinConfirm();
                drawRuraSelection();
            }

            ctx.restore();

            // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ•ã‚§ãƒ¼ãƒ‰æç”»ï¼ˆrestoreå¾Œã«æç”»ï¼‰
            if (endingState.fadeAlpha > 0 && endingState.phase !== 'staffroll' && endingState.phase !== 'theend' && endingState.phase !== 'none') {
                ctx.fillStyle = `rgba(0, 0, 0, ${endingState.fadeAlpha})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
        }

        // ========================================
        // ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        function startBattle(monsterTypeOrTable) {
            // æ•µã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆï¼ˆã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«åãŒæ¸¡ã•ã‚ŒãŸå ´åˆã¯ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆï¼‰
            let enemies;
            if (encounterTables[monsterTypeOrTable]) {
                // ãƒ†ãƒ¼ãƒ–ãƒ«åãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
                enemies = generateEnemyGroup(monsterTypeOrTable);
            } else if (monsters[monsterTypeOrTable]) {
                // å˜ä½“ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼åãŒæ¸¡ã•ã‚ŒãŸå ´åˆ
                const monsterData = monsters[monsterTypeOrTable];
                enemies = [{
                    ...monsterData,
                    id: `${monsterTypeOrTable}_0`,
                    type: monsterTypeOrTable,
                    displayName: monsterData.name,
                    currentHp: monsterData.hp,
                    currentMp: monsterData.mp || 0,
                    status: { sleep: 0, poison: 0, blind: 0 },
                    index: 0
                }];
            } else {
                console.error('Unknown monster or table:', monsterTypeOrTable);
                return;
            }

            SE.encounter(); // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆéŸ³
            BGM.play('battle'); // æˆ¦é—˜BGM
            battle.active = true;
            battle.enemies = enemies;
            battle.enemy = enemies[0]; // å¾Œæ–¹äº’æ›ç”¨
            battle.targetIndex = 0;
            battle.currentEnemyIndex = 0;
            battle.isSelectingTarget = false;
            battle.isSelectingAlly = false;
            battle.allyTargetIndex = 0;
            battle.pendingAction = null;
            battle.phase = 'start';
            battle.commandIndex = 0;
            battle.spellIndex = 0;
            battle.showSpells = false;
            battle.showItems = false;
            battle.itemCursor = 0;
            battle.message = '';
            battle.messageQueue = [];
            battle.result = null;
            battle.flashCount = 6;

            // ãƒ‘ãƒ¼ãƒ†ã‚£ãƒãƒˆãƒ«ç”¨ã®åˆæœŸåŒ–
            battle.currentPartyIndex = 0;
            battle.partyActions = [];
            battle.executingActionIndex = 0;

            // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã®çŠ¶æ…‹ç•°å¸¸ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæˆ¦é—˜ã”ã¨ã«ãƒªã‚»ãƒƒãƒˆï¼‰
            party.forEach(member => {
                member.status = { sleep: 0, poison: 0, blind: 0 };
                // æˆ¦é—˜ä¸èƒ½çŠ¶æ…‹ã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼ˆHP > 0 ã§åˆ¤å®šï¼‰
                member.isAlive = member.hp > 0;
            });

            // ãƒãƒ•ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæˆ¦é—˜ã”ã¨ã«ãƒªã‚»ãƒƒãƒˆï¼‰
            battle.buffs = { attackUp: 0, defenseUp: 0, speedUp: 0 };

            gameMode = MODE.BATTLE;

            // ãƒãƒˆãƒ«ä¸­ã¯ãƒãƒƒãƒ—åã‚’éè¡¨ç¤º
            mapNameArea.style.display = 'none';

            // æ•µå‡ºç¾ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            const enemyMessage = generateEnemyAppearMessage(enemies);

            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const flashInterval = setInterval(() => {
                battle.flashCount--;
                if (battle.flashCount <= 0) {
                    clearInterval(flashInterval);
                    showBattleMessage(enemyMessage, () => {
                        // è¡Œå‹•é †ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆã—ã¦æœ€åˆã®è¡Œå‹•è€…ã‹ã‚‰é–‹å§‹
                        startPlayerTurn();
                    });
                }
            }, 100);
        }

        // æ•µå‡ºç¾ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
        function generateEnemyAppearMessage(enemies) {
            if (enemies.length === 1) {
                return `${enemies[0].displayName} ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼`;
            } else {
                // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const names = enemies.map(e => e.displayName);
                if (names.length <= 3) {
                    return `${names.join(' ã¨ ')} ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼`;
                } else {
                    return `${enemies[0].displayName}ãŸã¡ ${enemies.length}åŒ¹ã® ã¾ã‚‚ã®ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼`;
                }
            }
        }

        function showBattleMessage(msg, callback) {
            battle.message = msg;
            setTimeout(() => {
                if (callback) callback();
            }, 1000);
        }

        // æ•µã®è€æ€§ã‚’è€ƒæ…®ã—ãŸæˆåŠŸç‡ã‚’è¨ˆç®—
        function getEffectiveSuccessRate(spell, enemy) {
            const baseRate = spell.successRate;
            const resistance = enemy.resistances ? enemy.resistances[spell.statusEffect] : 1.0;
            return baseRate * resistance;
        }

        function executeBattleCommand() {
            // ç¾åœ¨è¡Œå‹•ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼
            const caster = getCurrentPartyMember();

            if (battle.showSpells) {
                // å‘ªæ–‡å®Ÿè¡Œ
                const spellId = caster.spells[battle.spellIndex];
                const spell = spells[spellId];
                if (caster.mp < spell.mp) {
                    showBattleMessage('MPãŒ ãŸã‚Šãªã„ï¼', () => {
                        battle.phase = 'command';
                        battle.message = `${caster.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                    });
                    return;
                }

                // æ”»æ’ƒå‘ªæ–‡ã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†
                if (spell.type === 'attack') {
                    battle.showSpells = false;

                    if (spell.target === 'single') {
                        // å˜ä½“æ”»æ’ƒå‘ªæ–‡ï¼šè¤‡æ•°æ•µãŒã„ã‚‹å ´åˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
                        const aliveCount = getAliveEnemies().length;
                        if (aliveCount > 1) {
                            startTargetSelection('spell', spellId);
                            battle.message = 'ã ã‚Œã« ã¤ã‹ã†ï¼Ÿ';
                            return;
                        } else {
                            // æ•µãŒ1ä½“ã®å ´åˆã¯ç›´æ¥å®Ÿè¡Œ
                            caster.mp -= spell.mp;
                            executeSpellOnTarget(spellId, getFirstAliveEnemyIndex());
                            return;
                        }
                    } else if (spell.target === 'all') {
                        // å…¨ä½“æ”»æ’ƒå‘ªæ–‡ï¼šå…¨ã¦ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                        caster.mp -= spell.mp;
                        executeSpellOnAll(spellId);
                        return;
                    }
                }

                // å›å¾©å‘ªæ–‡ã®å ´åˆã¯ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ãŒè¤‡æ•°ã„ã‚Œã°å‘³æ–¹é¸æŠ
                if (spell.type === 'heal' && party.length > 1) {
                    battle.showSpells = false;
                    startAllySelection('spell', spellId);
                    battle.message = 'ã ã‚Œã« ã¤ã‹ã†ï¼Ÿ';
                    return;
                }

                caster.mp -= spell.mp;
                battle.showSpells = false;
                battle.phase = 'playerTurn';

                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡ºã‚’é–‹å§‹ï¼ˆç©¶æ¥µé­”æ³•ã¯ç‰¹åˆ¥æ¼”å‡ºï¼‰
                if (spell.flashColor) {
                    const isUltimate = ULTIMATE_SPELLS.includes(spell.id);
                    startSpellFlash(spell.flashColor, isUltimate, spell.type);
                }

                showBattleMessage(`${caster.name} ã¯ ${spell.name} ã‚’ ã¨ãªãˆãŸï¼`, () => {
                    if (spell.type === 'heal') {
                        // å›å¾©å‘ªæ–‡ï¼šè‡ªåˆ†è‡ªèº«ã‚’å›å¾©ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ãŒ1äººã®å ´åˆï¼‰
                        const healAmount = spell.power;
                        caster.hp = Math.min(caster.maxHp, caster.hp + healAmount);
                        showBattleMessage(`${caster.name} ã® HPãŒ ${healAmount} ã‹ã„ãµãã—ãŸï¼`, () => {
                            processTurnEnd();
                        });
                    } else if (spell.type === 'status') {
                        // çŠ¶æ…‹ç•°å¸¸å‘ªæ–‡ï¼ˆæœ€åˆã®ç”Ÿå­˜æ•µã«å¯¾ã—ã¦ä½¿ç”¨ï¼‰
                        const targetEnemy = battle.enemies[getFirstAliveEnemyIndex()];
                        const targetName = targetEnemy.displayName || targetEnemy.name;

                        // æ—¢ã«ãã®çŠ¶æ…‹ç•°å¸¸ã«ã‹ã‹ã£ã¦ã„ã‚‹å ´åˆ
                        if (targetEnemy.status[spell.statusEffect] > 0) {
                            showBattleMessage(`ã—ã‹ã— ${targetName} ã«ã¯ ãã‹ãªã‹ã£ãŸï¼`, () => {
                                processTurnEnd();
                            });
                        } else {
                            // è€æ€§ã‚’è€ƒæ…®ã—ãŸæˆåŠŸç‡
                            const effectiveRate = getEffectiveSuccessRate(spell, targetEnemy);
                            if (effectiveRate <= 0) {
                                // å®Œå…¨è€æ€§
                                showBattleMessage(`ã—ã‹ã— ${targetName} ã«ã¯ ã¾ã£ãŸã ãã‹ãªã‹ã£ãŸï¼`, () => {
                                    processTurnEnd();
                                });
                            } else if (Math.random() < effectiveRate) {
                                // æˆåŠŸ
                                applyStatusEffect(targetEnemy, spell.statusEffect);
                                let successMsg = '';
                                if (spell.statusEffect === 'sleep') {
                                    successMsg = `${targetName} ã¯ ã­ã‚€ã‚Šã«ãŠã¡ãŸï¼`;
                                } else if (spell.statusEffect === 'blind') {
                                    successMsg = `${targetName} ã¯ ã¾ã¼ã‚ã—ã« ã¤ã¤ã¾ã‚ŒãŸï¼`;
                                } else {
                                    const effectName = STATUS_EFFECTS[spell.statusEffect].name;
                                    successMsg = `${targetName} ã¯ ${effectName}çŠ¶æ…‹ã« ãªã£ãŸï¼`;
                                }
                                showBattleMessage(successMsg, () => {
                                    processTurnEnd();
                                });
                            } else {
                                // å¤±æ•—ï¼ˆè€æ€§ã§å¼¾ã‹ã‚ŒãŸï¼‰
                                showBattleMessage(`ã—ã‹ã— ${targetName} ã«ã¯ ãã‹ãªã‹ã£ãŸï¼`, () => {
                                    processTurnEnd();
                                });
                            }
                        }
                    } else if (spell.type === 'buff') {
                        // è£œåŠ©å‘ªæ–‡ï¼ˆãƒãƒ•ï¼‰- ãƒ‘ãƒ¼ãƒ†ã‚£å…¨ä½“ã«åŠ¹æœ
                        if (spell.buffType === 'defense') {
                            // ã‚¹ã‚¯ãƒ«ãƒˆ - é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—
                            if (battle.buffs.defenseUp >= MAX_BUFF_STACK) {
                                showBattleMessage('ã—ã‹ã— ã“ã‚Œä»¥ä¸Š ã—ã‚…ã³åŠ›ã¯ ã‚ãŒã‚‰ãªã„ï¼', () => {
                                    processTurnEnd();
                                });
                            } else {
                                battle.buffs.defenseUp++;
                                showBattleMessage('ãªã‹ã¾ãŸã¡ ã® ã—ã‚…ã³åŠ›ãŒ ã‚ãŒã£ãŸï¼', () => {
                                    processTurnEnd();
                                });
                            }
                        } else if (spell.buffType === 'attack') {
                            // ãƒã‚¤ã‚­ãƒ«ãƒˆ - æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—
                            if (battle.buffs.attackUp >= MAX_BUFF_STACK) {
                                showBattleMessage('ã—ã‹ã— ã“ã‚Œä»¥ä¸Š ã“ã†ã’ãåŠ›ã¯ ã‚ãŒã‚‰ãªã„ï¼', () => {
                                    processTurnEnd();
                                });
                            } else {
                                battle.buffs.attackUp++;
                                showBattleMessage('ãªã‹ã¾ãŸã¡ ã® ã“ã†ã’ãåŠ›ãŒ ã‚ãŒã£ãŸï¼', () => {
                                    processTurnEnd();
                                });
                            }
                        } else if (spell.buffType === 'speed') {
                            // ãƒ”ã‚ªãƒªãƒ  - ç´ æ—©ã•ã‚¢ãƒƒãƒ—
                            if (battle.buffs.speedUp >= MAX_BUFF_STACK) {
                                showBattleMessage('ã—ã‹ã— ã“ã‚Œä»¥ä¸Š ã™ã°ã‚„ã•ã¯ ã‚ãŒã‚‰ãªã„ï¼', () => {
                                    processTurnEnd();
                                });
                            } else {
                                battle.buffs.speedUp++;
                                showBattleMessage('ãªã‹ã¾ãŸã¡ ã® ã™ã°ã‚„ã•ãŒ ã‚ãŒã£ãŸï¼', () => {
                                    processTurnEnd();
                                });
                            }
                        }
                    } else if (spell.type === 'debuff') {
                        // ãƒ‡ãƒãƒ•å‘ªæ–‡ï¼ˆæœ€åˆã®ç”Ÿå­˜æ•µã«å¯¾ã—ã¦ä½¿ç”¨ï¼‰
                        const targetEnemy = battle.enemies[getFirstAliveEnemyIndex()];
                        const targetName = targetEnemy.displayName || targetEnemy.name;

                        // ãƒ‡ãƒãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯åˆæœŸåŒ–
                        if (!targetEnemy.debuffs) {
                            targetEnemy.debuffs = {};
                        }

                        // æ—¢ã«ãã®ãƒ‡ãƒãƒ•ãŒã‹ã‹ã£ã¦ã„ã‚‹å ´åˆ
                        if (targetEnemy.debuffs[spell.debuffType]) {
                            showBattleMessage(`ã—ã‹ã— ${targetName} ã«ã¯ ãã‹ãªã‹ã£ãŸï¼`, () => {
                                processTurnEnd();
                            });
                        } else {
                            // æˆåŠŸåˆ¤å®š
                            if (Math.random() < spell.successRate) {
                                // ãƒ‡ãƒãƒ•é©ç”¨
                                targetEnemy.debuffs[spell.debuffType] = spell.debuffRate;
                                let successMsg = '';
                                if (spell.debuffType === 'defense') {
                                    successMsg = `${targetName} ã® ã—ã‚…ã³åŠ›ãŒ ã•ãŒã£ãŸï¼`;
                                } else {
                                    successMsg = `${targetName} ã« ãƒ‡ãƒãƒ•ãŒ ã‹ã‹ã£ãŸï¼`;
                                }
                                showBattleMessage(successMsg, () => {
                                    processTurnEnd();
                                });
                            } else {
                                // å¤±æ•—
                                showBattleMessage(`ã—ã‹ã— ${targetName} ã«ã¯ ãã‹ãªã‹ã£ãŸï¼`, () => {
                                    processTurnEnd();
                                });
                            }
                        }
                    } else if (spell.type === 'revive') {
                        // å¾©æ´»å‘ªæ–‡ï¼ˆã‚¶ã‚ªãƒ©ãƒ«ï¼‰- æˆ¦é—˜ä¸èƒ½ã®ä»²é–“ã‚’å¾©æ´»
                        const deadMembers = party.filter(m => !m.isAlive || m.hp <= 0);
                        if (deadMembers.length === 0) {
                            showBattleMessage('ã—ã‹ã— ã ã‚Œã‚‚ ãŸãŠã‚Œã¦ã„ãªã„ï¼', () => {
                                processTurnEnd();
                            });
                        } else {
                            // æœ€åˆã®æˆ¦é—˜ä¸èƒ½ãƒ¡ãƒ³ãƒãƒ¼ã‚’å¾©æ´»ï¼ˆ50%æˆåŠŸï¼‰
                            const target = deadMembers[0];
                            if (Math.random() < 0.5) {
                                target.hp = Math.floor(target.maxHp / 2);
                                target.isAlive = true;
                                SE.revive(); // å¾©æ´»SE
                                showBattleMessage(`${target.name} ã¯ ã„ãã‹ãˆã£ãŸï¼`, () => {
                                    processTurnEnd();
                                });
                            } else {
                                showBattleMessage(`ã—ã‹ã— ${target.name} ã¯ ã„ãã‹ãˆã‚‰ãªã‹ã£ãŸ...`, () => {
                                    processTurnEnd();
                                });
                            }
                        }
                    } else if (spell.type === 'escape') {
                        // æˆ¦é—˜ä¸­ã®ãƒªãƒ¬ãƒŸãƒˆã¯ä½¿ç”¨ä¸å¯
                        showBattleMessage('ã—ã‹ã— ã“ã®å ´ã§ã¯ ã¤ã‹ãˆãªã„ï¼', () => {
                            processTurnEnd();
                        });
                    }
                });
            } else if (battle.showItems) {
                // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨
                if (player.inventory.length === 0) {
                    showBattleMessage('ã©ã†ãã‚’ ã‚‚ã£ã¦ã„ãªã„ï¼', () => {
                        battle.showItems = false;
                        battle.phase = 'command';
                        battle.message = `${caster.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                    });
                    return;
                }

                const slot = player.inventory[battle.itemCursor];
                if (!slot) return;

                const item = items[slot.id];
                if (!item) return;

                // è£…å‚™å“ã¯æˆ¦é—˜ä¸­ã«ä½¿ãˆãªã„
                if (item.type === 'weapon' || item.type === 'armor') {
                    showBattleMessage('ãã‚Œã¯ ã“ã“ã§ã¯ ã¤ã‹ãˆãªã„ï¼', () => {
                        battle.phase = 'command';
                        battle.message = `${caster.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                    });
                    return;
                }

                battle.showItems = false;
                battle.phase = 'playerTurn';

                showBattleMessage(`ã‚†ã†ã—ã‚ƒ ã¯ ${item.name} ã‚’ ã¤ã‹ã£ãŸï¼`, () => {
                    let effectMsg = '';
                    let success = false;

                    switch (item.type) {
                        case 'heal':
                            const healAmount = item.value;
                            player.hp = Math.min(player.maxHp, player.hp + healAmount);
                            effectMsg = `HPãŒ ${healAmount} ã‹ã„ãµãã—ãŸï¼`;
                            success = true;
                            break;
                        case 'revive':
                            // ä¸–ç•Œæ¨¹ã®è‘‰ï¼šæˆ¦é—˜ä¸­ã®å¾©æ´»
                            const deadMembers = getDeadPartyMembers();
                            if (deadMembers.length === 0) {
                                effectMsg = 'ã—ã‹ã— ã ã‚Œã‚‚ ãŸãŠã‚Œã¦ã„ãªã„ï¼';
                            } else {
                                // æœ€åˆã®æˆ¦é—˜ä¸èƒ½ãƒ¡ãƒ³ãƒãƒ¼ã‚’å¾©æ´»
                                const reviveTarget = deadMembers[0];
                                reviveMember(reviveTarget, true);
                                effectMsg = `${reviveTarget.name}ã¯ ã„ãã‹ãˆã£ãŸï¼`;
                                success = true;
                            }
                            break;
                        case 'cure':
                            // æ¯’æ¶ˆã—è‰
                            if (player.status && player.status.poison > 0) {
                                player.status.poison = 0;
                                effectMsg = 'ã©ããŒ ãªãŠã£ãŸï¼';
                                success = true;
                            } else {
                                effectMsg = 'ã—ã‹ã— ãªã«ã‚‚ ãŠã“ã‚‰ãªã‹ã£ãŸï¼';
                            }
                            break;
                        default:
                            effectMsg = 'ã—ã‹ã— ãªã«ã‚‚ ãŠã“ã‚‰ãªã‹ã£ãŸï¼';
                            break;
                    }

                    if (success) {
                        removeItem(slot.id, 1);
                        // ã‚«ãƒ¼ã‚½ãƒ«èª¿æ•´ï¼ˆæœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ æ•°ã§ãƒã‚§ãƒƒã‚¯ï¼‰
                        const validItems = player.inventory.filter(slot => items[slot.id]);
                        if (battle.itemCursor >= validItems.length && battle.itemCursor > 0) {
                            battle.itemCursor--;
                        }
                    }

                    showBattleMessage(effectMsg, () => {
                        processTurnEnd();
                    });
                });
            } else {
                switch (battle.commandIndex) {
                    case 0: // ãŸãŸã‹ã†
                        // è¤‡æ•°æ•µãŒã„ã‚‹å ´åˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
                        if (getAliveEnemies().length > 1) {
                            startTargetSelection('attack');
                        } else {
                            playerAttack();
                        }
                        break;
                    case 1: // ã˜ã‚…ã‚‚ã‚“
                        battle.showSpells = true;
                        battle.spellIndex = 0;
                        break;
                    case 2: // ã©ã†ã
                        battle.showItems = true;
                        battle.itemCursor = 0;
                        break;
                    case 3: // ã«ã’ã‚‹
                        tryEscape();
                        break;
                }
            }
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠé–‹å§‹
        function startTargetSelection(actionType, spellId = null) {
            battle.isSelectingTarget = true;
            battle.targetIndex = getFirstAliveEnemyIndex();
            battle.pendingAction = { type: actionType, spellId };
            battle.message = 'ã ã‚Œã‚’ ã“ã†ã’ãã™ã‚‹ï¼Ÿ';
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠç¢ºå®š
        function confirmTargetSelection() {
            battle.isSelectingTarget = false;
            const action = battle.pendingAction;
            battle.pendingAction = null;

            if (action.type === 'attack') {
                playerAttack(battle.targetIndex);
            } else if (action.type === 'spell') {
                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠç¢ºå®šæ™‚ã«MPæ¶ˆè²»
                const spell = spells[action.spellId];
                player.mp -= spell.mp;
                executeSpellOnTarget(action.spellId, battle.targetIndex);
            }
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelTargetSelection() {
            battle.isSelectingTarget = false;
            battle.pendingAction = null;
            battle.message = '';
        }

        // å‘³æ–¹é¸æŠé–‹å§‹ï¼ˆå›å¾©å‘ªæ–‡ãªã©ï¼‰
        function startAllySelection(actionType, spellId = null) {
            battle.isSelectingAlly = true;
            battle.allyTargetIndex = 0;
            battle.pendingAction = { type: actionType, spellId };
        }

        // å‘³æ–¹é¸æŠç¢ºå®š
        function confirmAllySelection() {
            battle.isSelectingAlly = false;
            const action = battle.pendingAction;
            battle.pendingAction = null;

            if (action.type === 'spell') {
                const spell = spells[action.spellId];
                const caster = getCurrentPartyMember();
                const target = party[battle.allyTargetIndex];

                caster.mp -= spell.mp;
                battle.showSpells = false;
                battle.phase = 'playerTurn';

                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
                if (spell.flashColor) {
                    const isUltimate = ULTIMATE_SPELLS.includes(spell.id);
                    startSpellFlash(spell.flashColor, isUltimate, spell.type);
                }

                showBattleMessage(`${caster.name} ã¯ ${spell.name} ã‚’ ã¨ãªãˆãŸï¼`, () => {
                    if (spell.type === 'heal') {
                        const healAmount = spell.power;
                        target.hp = Math.min(target.maxHp, target.hp + healAmount);
                        showBattleMessage(`${target.name} ã® HPãŒ ${healAmount} ã‹ã„ãµãã—ãŸï¼`, () => {
                            processTurnEnd();
                        });
                    }
                });
            }
        }

        // å‘³æ–¹é¸æŠã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelAllySelection() {
            battle.isSelectingAlly = false;
            battle.pendingAction = null;
            battle.showSpells = true;
            battle.message = '';
        }

        // å˜ä½“æ”»æ’ƒå‘ªæ–‡ã‚’ç‰¹å®šã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å®Ÿè¡Œ
        function executeSpellOnTarget(spellId, targetIndex) {
            const spell = spells[spellId];
            const enemy = battle.enemies[targetIndex];
            if (!enemy || enemy.currentHp <= 0) {
                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ—¢ã«å€’ã•ã‚Œã¦ã„ã‚‹å ´åˆã€åˆ¥ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¢ã™
                const newTarget = getFirstAliveEnemyIndex();
                if (newTarget === -1) {
                    checkBattleEnd();
                    return;
                }
                targetIndex = newTarget;
            }
            const target = battle.enemies[targetIndex];
            const targetName = target.displayName || target.name;

            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡ºã‚’é–‹å§‹
            if (spell.flashColor) {
                const isUltimate = ULTIMATE_SPELLS.includes(spell.id);
                startSpellFlash(spell.flashColor, isUltimate, spell.type);
            }

            battle.phase = 'playerTurn';
            showBattleMessage(`ã‚†ã†ã—ã‚ƒ ã¯ ${spell.name} ã‚’ ã¨ãªãˆãŸï¼`, () => {
                // å±æ€§å€ç‡ã‚’è¨ˆç®—
                const { multiplier, effectiveness } = getElementMultiplier(spell, target);
                const baseDamage = spell.power + Math.floor(Math.random() * 5);
                const damage = Math.floor(baseDamage * multiplier);
                target.currentHp -= damage;

                // å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
                const effectMsg = getElementEffectivenessMessage(effectiveness, targetName);

                // ç„¡åŠ¹ã®å ´åˆã¯ç‰¹åˆ¥ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if (effectiveness === 'immune') {
                    showBattleMessage(effectMsg, () => {
                        checkBattleEnd() || processTurnEnd();
                    });
                } else {
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    showBattleMessage(`${targetName} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, () => {
                        // å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚ã‚Œã°è¡¨ç¤º
                        const showEffectMessage = (callback) => {
                            if (effectMsg) {
                                showBattleMessage(effectMsg, callback);
                            } else {
                                callback();
                            }
                        };

                        showEffectMessage(() => {
                            if (target.currentHp <= 0) {
                                target.currentHp = 0;
                                showBattleMessage(`${targetName} ã‚’ ãŸãŠã—ãŸï¼`, () => {
                                    checkBattleEnd() || processTurnEnd();
                                });
                            } else {
                                checkBattleEnd() || processTurnEnd();
                            }
                        });
                    });
                }
            });
        }

        // å…¨ä½“æ”»æ’ƒå‘ªæ–‡ã‚’å®Ÿè¡Œï¼ˆå…¨ã¦ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
        function executeSpellOnAll(spellId) {
            const spell = spells[spellId];
            const aliveEnemies = getAliveEnemies();

            if (aliveEnemies.length === 0) {
                checkBattleEnd();
                return;
            }

            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡ºã‚’é–‹å§‹
            if (spell.flashColor) {
                const isUltimate = ULTIMATE_SPELLS.includes(spell.id);
                startSpellFlash(spell.flashColor, isUltimate, spell.type);
            }

            battle.phase = 'playerTurn';
            showBattleMessage(`ã‚†ã†ã—ã‚ƒ ã¯ ${spell.name} ã‚’ ã¨ãªãˆãŸï¼`, () => {
                // å…¨ã¦ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ï¼ˆé †ç•ªã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºï¼‰
                processAoeDamage(spell, 0);
            });
        }

        // AOEãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é †ç•ªã«å‡¦ç†
        function processAoeDamage(spell, enemyIndex) {
            // æ¬¡ã®ç”Ÿå­˜æ•µã‚’æ¢ã™
            while (enemyIndex < battle.enemies.length && battle.enemies[enemyIndex].currentHp <= 0) {
                enemyIndex++;
            }

            if (enemyIndex >= battle.enemies.length) {
                // å…¨ã¦ã®æ•µã¸ã®æ”»æ’ƒãŒå®Œäº†
                checkBattleEnd() || processTurnEnd();
                return;
            }

            const enemy = battle.enemies[enemyIndex];
            const enemyName = enemy.displayName || enemy.name;

            // å±æ€§å€ç‡ã‚’è¨ˆç®—
            const { multiplier, effectiveness } = getElementMultiplier(spell, enemy);
            const baseDamage = spell.power + Math.floor(Math.random() * 5);
            const damage = Math.floor(baseDamage * multiplier);
            enemy.currentHp -= damage;

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹ç¯‰
            let message;
            if (effectiveness === 'immune') {
                message = `${enemyName} ã«ã¯ ã¾ã£ãŸã ãã‹ãªã‹ã£ãŸï¼`;
            } else {
                // å±æ€§åŠ¹æœã®ç°¡æ˜“è¡¨ç¤ºï¼ˆå¼±ç‚¹/è€æ€§ï¼‰
                let effectSuffix = '';
                if (effectiveness === 'weak') {
                    effectSuffix = ' ã“ã†ã‹ã°ã¤ãã‚“ï¼';
                } else if (effectiveness === 'resistant' || effectiveness === 'resisted') {
                    effectSuffix = ' ã„ã¾ã²ã¨ã¤...';
                }

                if (enemy.currentHp <= 0) {
                    message = `${enemyName} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼${effectSuffix} ${enemyName} ã‚’ ãŸãŠã—ãŸï¼`;
                } else {
                    message = `${enemyName} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼${effectSuffix}`;
                }
            }

            if (enemy.currentHp <= 0) {
                enemy.currentHp = 0;
            }

            showBattleMessage(message, () => {
                // æ¬¡ã®æ•µã¸
                processAoeDamage(spell, enemyIndex + 1);
            });
        }

        // ç¾åœ¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
        function getCurrentPartyMember() {
            return party[battle.currentPartyIndex] || party[0];
        }

        // æ¬¡ã®è¡Œå‹•å¯èƒ½ãªãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        function getNextAlivePartyIndex(currentIndex) {
            for (let i = currentIndex + 1; i < party.length; i++) {
                if (party[i].isAlive && party[i].hp > 0 && party[i].status.sleep === 0) {
                    return i;
                }
            }
            return -1; // å…¨å“¡è¡Œå‹•æ¸ˆã¿
        }

        // ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†ï¼ˆæ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã©ï¼‰
        function processTurnEnd() {
            // ç¾åœ¨ã®ãƒ¡ãƒ³ãƒãƒ¼ã®æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸
            const currentMember = getCurrentPartyMember();
            const poisonResult = processPoisonDamage(currentMember, currentMember.name, currentMember.maxHp);

            const continueAfterPoison = () => {
                // æ¬¡ã®è¡Œå‹•è€…ã¸é€²ã‚€
                battle.currentActionIndex++;
                processNextAction();
            };

            if (poisonResult) {
                showBattleMessage(poisonResult.message, continueAfterPoison);
            } else {
                continueAfterPoison();
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†å¾Œã€æ•µã‚¿ãƒ¼ãƒ³ã¸
        function processPartyPoisonAndEnemyTurn() {
            // æ®‹ã‚Šã®ãƒ¡ãƒ³ãƒãƒ¼ã®æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ï¼ˆç¾åœ¨ã®ãƒ¡ãƒ³ãƒãƒ¼ä»¥å¤–ï¼‰
            let poisonMessages = [];
            party.forEach((member, idx) => {
                if (idx <= battle.currentPartyIndex) return; // æ—¢ã«å‡¦ç†æ¸ˆã¿
                if (!member.isAlive || member.hp <= 0) return;
                const result = processPoisonDamage(member, member.name, member.maxHp);
                if (result) {
                    poisonMessages.push(result.message);
                }
            });

            if (poisonMessages.length > 0) {
                // æ¯’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é †æ¬¡è¡¨ç¤º
                const showNext = (index) => {
                    if (index >= poisonMessages.length) {
                        enemyTurn();
                        return;
                    }
                    showBattleMessage(poisonMessages[index], () => showNext(index + 1));
                };
                showNext(0);
            } else {
                enemyTurn();
            }
        }

        function playerAttack(targetIndex = 0) {
            battle.phase = 'playerTurn';

            // ç¾åœ¨è¡Œå‹•ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
            const attacker = getCurrentPartyMember();

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ—¢ã«å€’ã‚Œã¦ã„ã‚‹å ´åˆã¯åˆ¥ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¢ã™
            if (!battle.enemies[targetIndex] || battle.enemies[targetIndex].currentHp <= 0) {
                const newTarget = getFirstAliveEnemyIndex();
                if (newTarget === -1) {
                    checkBattleEnd();
                    return;
                }
                targetIndex = newTarget;
            }
            const enemy = battle.enemies[targetIndex];

            // å¹»æƒ‘çŠ¶æ…‹ãªã‚‰å‘½ä¸­ç‡ä½ä¸‹
            const hitRate = getHitRate(attacker);
            if (Math.random() > hitRate) {
                SE.miss(); // ãƒŸã‚¹éŸ³
                showBattleMessage(`${attacker.name} ã® ã“ã†ã’ãï¼ ã—ã‹ã— ã“ã†ã’ãã¯ ã¯ãšã‚ŒãŸï¼`, () => {
                    processTurnEnd();
                });
                return;
            }

            const atk = attacker.actualAtk;

            // æ•µã®å®ŸåŠ¹é˜²å¾¡åŠ›ã‚’è¨ˆç®—ï¼ˆãƒ‡ãƒãƒ•è€ƒæ…®ï¼‰
            let effectiveDefense = enemy.def;
            if (enemy.debuffs && enemy.debuffs.defense) {
                effectiveDefense = Math.floor(enemy.def * enemy.debuffs.defense);
            }

            let damage = Math.max(1, Math.floor(atk / 2 - effectiveDefense / 4 + Math.random() * 5));

            // ãƒã‚¤ã‚­ãƒ«ãƒˆã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡é©ç”¨
            if (battle.buffs.attackUp > 0) {
                const attackMultiplier = 1 + battle.buffs.attackUp * 0.5; // 1æ®µéš=1.5å€, 2æ®µéš=2å€
                damage = Math.floor(damage * attackMultiplier);
            }

            enemy.currentHp -= damage;

            // æ•µã®åå‰ï¼ˆã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ãï¼‰ã‚’è¡¨ç¤º
            const enemyName = enemy.displayName || enemy.name;

            SE.attack(); // æ”»æ’ƒéŸ³
            showBattleMessage(`${attacker.name} ã® ã“ã†ã’ãï¼ ${enemyName} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, () => {
                // ã“ã®æ•µã‚’å€’ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                if (enemy.currentHp <= 0) {
                    enemy.currentHp = 0;
                    showBattleMessage(`${enemyName} ã‚’ ãŸãŠã—ãŸï¼`, () => {
                        checkBattleEnd() || processTurnEnd();
                    });
                } else {
                    checkBattleEnd() || processTurnEnd();
                }
            });
        }

        function enemyTurn() {
            battle.phase = 'enemyTurn';
            // æœ€åˆã®ç”Ÿå­˜æ•µã‹ã‚‰è¡Œå‹•é–‹å§‹
            battle.currentEnemyIndex = getFirstAliveEnemyIndex();
            if (battle.currentEnemyIndex === -1) {
                // å…¨ã¦ã®æ•µãŒå€’ã•ã‚Œã¦ã„ã‚‹
                checkBattleEnd();
                return;
            }
            processCurrentEnemyTurn();
        }

        // ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ•µãŒè¡Œå‹•ã™ã‚‹
        function processCurrentEnemyTurn() {
            const enemy = battle.enemies[battle.currentEnemyIndex];
            if (!enemy || enemy.currentHp <= 0) {
                // ã“ã®æ•µã¯æ—¢ã«å€’ã•ã‚Œã¦ã„ã‚‹ã€æ¬¡ã®è¡Œå‹•è€…ã¸
                processCurrentEnemyTurnEnd();
                return;
            }

            // å¾Œæ–¹äº’æ›ç”¨ã«battle.enemyã‚’è¨­å®š
            battle.enemy = enemy;

            // ãƒœã‚¹ã®å ´åˆã¯å°‚ç”¨ã®è¡Œå‹•ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨
            if (enemy.isBoss) {
                maouTurn();
                return;
            }

            // æ•µã®çœ ã‚Šãƒã‚§ãƒƒã‚¯
            const enemyName = enemy.displayName || enemy.name;
            const wakeResult = checkWakeUp(enemy, enemyName);
            if (!wakeResult.awake) {
                showBattleMessage(wakeResult.message, () => {
                    processCurrentEnemyTurnEnd();
                });
                return;
            }
            if (wakeResult.message) {
                // ç›®è¦šã‚ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¦ã‹ã‚‰è¡Œå‹•
                showBattleMessage(wakeResult.message, () => {
                    executeEnemyAttack();
                });
                return;
            }

            executeEnemyAttack();
        }

        // ãƒ©ãƒ³ãƒ€ãƒ ãªç”Ÿå­˜ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
        function getRandomAlivePartyMember() {
            const aliveMembers = getAlivePartyMembers();
            if (aliveMembers.length === 0) return null;
            return aliveMembers[Math.floor(Math.random() * aliveMembers.length)];
        }

        function executeEnemyAttack() {
            const enemy = battle.enemies[battle.currentEnemyIndex];
            const enemyName = enemy.displayName || enemy.name;

            // æ•µã®å¹»æƒ‘çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
            let hitRate = getHitRate(enemy);

            // ãƒ”ã‚ªãƒªãƒ ã«ã‚ˆã‚‹å›é¿ç‡å‘ä¸Šï¼ˆç´ æ—©ã•ã‚¢ãƒƒãƒ—ï¼‰
            if (battle.buffs.speedUp > 0) {
                const dodgeBonus = battle.buffs.speedUp * 0.15; // 1æ®µéš=15%, 2æ®µéš=30%
                hitRate = hitRate * (1 - dodgeBonus);
            }

            if (Math.random() > hitRate) {
                SE.miss(); // ãƒŸã‚¹éŸ³
                showBattleMessage(`${enemyName} ã® ã“ã†ã’ãï¼ ã—ã‹ã— ã“ã†ã’ãã¯ ã¯ãšã‚ŒãŸï¼`, () => {
                    processCurrentEnemyTurnEnd();
                });
                return;
            }

            // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
            const target = getRandomAlivePartyMember();
            if (!target) {
                checkBattleEnd();
                return;
            }

            let def = target.actualDef;

            // ã‚¹ã‚¯ãƒ«ãƒˆã«ã‚ˆã‚‹é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—
            if (battle.buffs.defenseUp > 0) {
                const defenseMultiplier = 1 + battle.buffs.defenseUp * 0.25; // 1æ®µéš=1.25å€, 2æ®µéš=1.5å€
                def = Math.floor(def * defenseMultiplier);
            }

            const damage = Math.max(1, Math.floor(enemy.atk / 2 - def / 4 + Math.random() * 3));
            target.hp -= damage;

            SE.damage(); // ãƒ€ãƒ¡ãƒ¼ã‚¸éŸ³
            showBattleMessage(`${enemyName} ã® ã“ã†ã’ãï¼ ${target.name} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, () => {
                if (target.hp <= 0) {
                    target.hp = 0;
                    target.isAlive = false;
                    showBattleMessage(`${target.name} ã¯ ãŸãŠã‚ŒãŸï¼`, () => {
                        // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨æ»…ãƒã‚§ãƒƒã‚¯
                        if (!isPartyAlive()) {
                            battleLose();
                        } else {
                            processCurrentEnemyTurnEnd();
                        }
                    });
                } else {
                    processCurrentEnemyTurnEnd();
                }
            });
        }

        // ç¾åœ¨ã®æ•µã®ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€æ¬¡ã®æ•µã¸
        function processCurrentEnemyTurnEnd() {
            const enemy = battle.enemies[battle.currentEnemyIndex];
            const enemyName = enemy ? (enemy.displayName || enemy.name) : '';

            // æ•µã®æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸
            if (enemy && enemy.currentHp > 0) {
                const poisonResult = processPoisonDamage(enemy, enemyName, enemy.hp);
                if (poisonResult) {
                    showBattleMessage(poisonResult.message, () => {
                        if (checkBattleEnd()) return;
                        battle.currentActionIndex++;
                        processNextAction();
                    });
                    return;
                }
            }
            battle.currentActionIndex++;
            processNextAction();
        }

        // æ¬¡ã®æ•µã®ã‚¿ãƒ¼ãƒ³ã¸é€²ã‚€
        function nextEnemyTurn() {
            const nextIndex = getNextAliveEnemyIndex(battle.currentEnemyIndex, false);
            if (nextIndex === -1) {
                // å…¨ã¦ã®æ•µãŒè¡Œå‹•å®Œäº†ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ã¸
                startPlayerTurn();
            } else {
                battle.currentEnemyIndex = nextIndex;
                processCurrentEnemyTurn();
            }
        }

        // æ•µã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†ï¼ˆå¾Œæ–¹äº’æ›ç”¨ï¼‰
        function processEnemyTurnEnd() {
            processCurrentEnemyTurnEnd();
        }

        // è¡Œå‹•é †ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆï¼ˆã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã—ï¼‰
        function generateActionQueue() {
            const queue = [];

            // å‘³æ–¹ã‚’è¿½åŠ 
            party.forEach((member, idx) => {
                if (member.isAlive && member.hp > 0) {
                    let speed = member.speed || 6;
                    // ãƒ”ã‚ªãƒªãƒ ãƒœãƒ¼ãƒŠã‚¹ï¼ˆ1æ®µéš=+50%, 2æ®µéš=+100%ï¼‰
                    if (battle.buffs.speedUp > 0) {
                        speed = Math.floor(speed * (1 + battle.buffs.speedUp * 0.5));
                    }
                    // ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ï¼ˆÂ±20%ï¼‰
                    speed = Math.floor(speed * (0.8 + Math.random() * 0.4));
                    queue.push({ type: 'player', index: idx, speed, actor: member });
                }
            });

            // æ•µã‚’è¿½åŠ 
            battle.enemies.forEach((enemy, idx) => {
                if (enemy.currentHp > 0) {
                    let speed = enemy.speed || 5;
                    // ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ï¼ˆÂ±20%ï¼‰
                    speed = Math.floor(speed * (0.8 + Math.random() * 0.4));
                    queue.push({ type: 'enemy', index: idx, speed, actor: enemy });
                }
            });

            // ç´ æ—©ã•é™é †ã§ã‚½ãƒ¼ãƒˆ
            queue.sort((a, b) => b.speed - a.speed);

            battle.actionQueue = queue;
            battle.currentActionIndex = 0;
        }

        // æ¬¡ã®è¡Œå‹•è€…ã‚’å‡¦ç†ã™ã‚‹é–¢æ•°
        function processNextAction() {
            // ã‚­ãƒ¥ãƒ¼ãŒç©ºã¾ãŸã¯å…¨å“¡è¡Œå‹•æ¸ˆã¿ãªã‚‰ã‚¿ãƒ¼ãƒ³çµ‚äº†
            if (battle.currentActionIndex >= battle.actionQueue.length) {
                // æ–°ã—ã„ã‚¿ãƒ¼ãƒ³é–‹å§‹
                startNewTurn();
                return;
            }

            const current = battle.actionQueue[battle.currentActionIndex];

            // æ­»äº¡ãƒã‚§ãƒƒã‚¯
            if (current.type === 'player') {
                const member = party[current.index];
                if (!member.isAlive || member.hp <= 0) {
                    battle.currentActionIndex++;
                    processNextAction();
                    return;
                }
                // çœ ã‚Šãƒã‚§ãƒƒã‚¯
                if (member.status.sleep > 0) {
                    const wakeResult = checkWakeUp(member, member.name);
                    if (!wakeResult.awake) {
                        showBattleMessage(wakeResult.message, () => {
                            battle.currentActionIndex++;
                            processNextAction();
                        });
                        return;
                    }
                    // ç›®è¦šã‚ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚ã‚Œã°è¡¨ç¤ºã—ã¦ã‹ã‚‰è¡Œå‹•
                    if (wakeResult.message) {
                        showBattleMessage(wakeResult.message, () => {
                            // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ã¸
                            battle.currentPartyIndex = current.index;
                            battle.phase = 'command';
                            battle.commandIndex = 0;
                            battle.message = `${member.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                        });
                        return;
                    }
                }
                // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ã¸
                battle.currentPartyIndex = current.index;
                battle.phase = 'command';
                battle.commandIndex = 0;
                battle.showSpells = false;
                battle.showItems = false;
                battle.message = `${member.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
            } else {
                // æ•µã®è¡Œå‹•
                const enemy = battle.enemies[current.index];
                if (enemy.currentHp <= 0) {
                    battle.currentActionIndex++;
                    processNextAction();
                    return;
                }
                battle.currentEnemyIndex = current.index;
                battle.phase = 'enemyTurn';
                processCurrentEnemyTurn();
            }
        }

        // æ–°ã—ã„ã‚¿ãƒ¼ãƒ³é–‹å§‹é–¢æ•°
        function startNewTurn() {
            // ãƒãƒ•æŒç¶šã‚¿ãƒ¼ãƒ³æ¸›å°‘ãªã©ãŒã‚ã‚Œã°ã“ã“ã§
            // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
            startPlayerTurn();
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹
        function startPlayerTurn() {
            // è¡Œå‹•é †ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
            generateActionQueue();
            // æœ€åˆã®è¡Œå‹•è€…ã‹ã‚‰é–‹å§‹
            processNextAction();
        }

        function tryEscape() {
            battle.phase = 'playerTurn';

            // é­”ç‹ã‹ã‚‰ã¯é€ƒã’ã‚‰ã‚Œãªã„
            if (battle.enemy.isBoss) {
                showBattleMessage('é­”ç‹ ã® ã¡ã‹ã‚‰ ãŒ ã‚†ã†ã—ã‚ƒ ã‚’ ã«ãŒã•ãªã„ï¼', () => {
                    processTurnEnd();
                });
                return;
            }

            // ãƒ¬ãƒ™ãƒ«å·®ã«ã‚ˆã‚‹é€ƒèµ°æˆåŠŸç‡ã®è¨ˆç®—
            const enemyLevel = battle.enemy.level || 1;
            const levelDiff = player.level - enemyLevel;

            let escapeChance;
            if (levelDiff >= 5) {
                // 5ãƒ¬ãƒ™ãƒ«ä»¥ä¸Šé«˜ã‘ã‚Œã°ç¢ºå®šé€ƒèµ°
                escapeChance = 1.0;
            } else if (levelDiff >= 3) {
                // 3ãƒ¬ãƒ™ãƒ«ä»¥ä¸Šé«˜ã‘ã‚Œã°é«˜ç¢ºç‡
                escapeChance = 0.9;
            } else if (levelDiff >= 1) {
                // 1~2ãƒ¬ãƒ™ãƒ«é«˜ã‘ã‚Œã°ã‚„ã‚„æœ‰åˆ©
                escapeChance = 0.7;
            } else {
                // åŒãƒ¬ãƒ™ãƒ«ä»¥ä¸‹ã¯ã‚¹ãƒ”ãƒ¼ãƒ‰æ¯”ã§åˆ¤å®š
                escapeChance = player.speed / (player.speed + battle.enemy.speed);
            }

            if (Math.random() < escapeChance) {
                SE.escape(); // é€ƒèµ°æˆåŠŸéŸ³
                showBattleMessage('ã†ã¾ã ã«ã’ãã‚ŒãŸï¼', () => {
                    endBattle('escape');
                });
            } else {
                showBattleMessage('ã—ã‹ã— ã¾ã‚ã‚Šã“ã¾ã‚Œã¦ã—ã¾ã£ãŸï¼', () => {
                    processTurnEnd();
                });
            }
        }

        function checkBattleEnd() {
            // å…¨ã¦ã®æ•µãŒå€’ã•ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯
            const aliveEnemies = getAliveEnemies();
            if (aliveEnemies.length === 0) {
                battleWin();
                return true;
            }
            return false;
        }

        function battleWin() {
            battle.phase = 'result';

            // å…¨æ•µã®å ±é…¬ã‚’åˆç®—
            let totalExp = 0;
            let totalGold = 0;
            let defeatedBoss = null;

            for (const enemy of battle.enemies) {
                totalExp += enemy.exp || 0;
                totalGold += enemy.gold || 0;
                if (enemy.isBoss) {
                    defeatedBoss = enemy;
                }
            }

            // çµŒé¨“å€¤ã‚’ç”Ÿå­˜ãƒ¡ãƒ³ãƒãƒ¼å…¨å“¡ã«ä»˜ä¸
            const aliveMembers = getAlivePartyMembers();
            aliveMembers.forEach(member => {
                member.exp += totalExp;
            });

            // ã‚´ãƒ¼ãƒ«ãƒ‰ã¯ãƒ‘ãƒ¼ãƒ†ã‚£å…±æœ‰
            partyData.gold += totalGold;

            // ãƒœã‚¹æˆ¦åˆ¤å®šï¼ˆå¾Œæ–¹äº’æ›ç”¨ï¼‰
            const isBossDefeat = defeatedBoss !== null;
            const isMaou = defeatedBoss && defeatedBoss.name === 'é­”ç‹';
            const isMidBoss = defeatedBoss && defeatedBoss.name === 'æ´çªŸã®ç•ªäºº';
            const exp = totalExp;
            const gold = totalGold;

            // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            const winMessage = battle.enemies.length === 1
                ? `${battle.enemies[0].displayName || battle.enemies[0].name} ã‚’ ãŸãŠã—ãŸï¼`
                : 'ã¾ã‚‚ã®ãŸã¡ã‚’ ã‚„ã£ã¤ã‘ãŸï¼';

            SE.victory(); // å‹åˆ©ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬
            BGM.play('victory'); // å‹åˆ©BGM
            showBattleMessage(winMessage, () => {
                // é­”ç‹è¨ä¼æ™‚ã¯ç‰¹åˆ¥ãªæ¼”å‡º
                if (isBossDefeat && isMaou) {
                    screenShake.active = true;
                    screenShake.intensity = 15;
                    screenShake.duration = 60;

                    showBattleMessage('ã...ããŠãŠãŠãŠ...ï¼', () => {
                        showBattleMessage('ã¾...ã¾ã•ã‹... ã“ã®ç§ãŒ...', () => {
                            showBattleMessage('é­”ç‹ ã¯ æ¶ˆæ»…ã—ãŸï¼', () => {
                                showBattleMessage(`${exp} ãƒã‚¤ãƒ³ãƒˆã® ã‘ã„ã‘ã‚“ã¡ã‚’ ã‹ãã¨ãï¼`, () => {
                                    checkLevelUp(() => {
                                        gameCleared = true;
                                        setBossDefeated('maou', true);
                                        startEnding();
                                    });
                                });
                            });
                        });
                    });
                } else if (isBossDefeat && isMidBoss) {
                    // ä¸­ãƒœã‚¹æ’ƒç ´æ™‚ã®æ¼”å‡º
                    screenShake.active = true;
                    screenShake.intensity = 10;
                    screenShake.duration = 40;

                    showBattleMessage('ã...ããŠãŠ...ï¼', () => {
                        showBattleMessage('æ´çªŸã®ç•ªäºº ã¯ å´©ã‚Œå»ã£ãŸï¼', () => {
                            showBattleMessage(`${exp} ãƒã‚¤ãƒ³ãƒˆã® ã‘ã„ã‘ã‚“ã¡ã‚’ ã‹ãã¨ãï¼`, () => {
                                showBattleMessage(`${gold} ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ ã¦ã«ã„ã‚ŒãŸï¼`, () => {
                                    checkLevelUp(() => {
                                        setBossDefeated('midBoss', true);
                                        showBattleMessage('ç‹æ§˜ã« å ±å‘Šã—ã‚ˆã†ï¼', () => {
                                            endBattle('win');
                                            saveGame();
                                        });
                                    });
                                });
                            });
                        });
                    });
                } else if (isBossDefeat && defeatedBoss.bossId) {
                    // ç ‚æ¼ ã‚¨ãƒªã‚¢ã®ãƒœã‚¹æ’ƒç ´å‡¦ç†
                    handleDesertBossDefeat(defeatedBoss.bossId, exp, gold);
                } else {
                    showBattleMessage(`${exp} ãƒã‚¤ãƒ³ãƒˆã® ã‘ã„ã‘ã‚“ã¡ã‚’ ã‹ãã¨ãï¼`, () => {
                        showBattleMessage(`${gold} ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ ã¦ã«ã„ã‚ŒãŸï¼`, () => {
                            checkLevelUp(() => {
                                endBattle('win');
                            });
                        });
                    });
                }
            });
        }

        // ç ‚æ¼ ã‚¨ãƒªã‚¢ã®ãƒœã‚¹æ’ƒç ´å‡¦ç†
        function handleDesertBossDefeat(bossId, exp, gold) {
            screenShake.active = true;
            screenShake.intensity = 10;
            screenShake.duration = 40;

            const bossName = battle.enemy.name;

            showBattleMessage('ã...ããŠãŠ...ï¼', () => {
                showBattleMessage(`${bossName} ã‚’ ãŸãŠã—ãŸï¼`, () => {
                    showBattleMessage(`${exp} ãƒã‚¤ãƒ³ãƒˆã® ã‘ã„ã‘ã‚“ã¡ã‚’ ã‹ãã¨ãï¼`, () => {
                        showBattleMessage(`${gold} ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ ã¦ã«ã„ã‚ŒãŸï¼`, () => {
                            checkLevelUp(() => {
                                // ãƒœã‚¹ã”ã¨ã®ã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†
                                setBossDefeated(bossId, true);

                                let questMessage = '';
                                if (bossId === 'quicksandBoss') {
                                    setQuestFlag('waterShortage', 'bossDefeated', true);
                                    questMessage = 'å®ç®±ã‹ã‚‰ æ¸…ã‚‰ã‹ãªæ°´ ã‚’æ‰‹ã«å…¥ã‚Œã‚ˆã†ï¼';
                                } else if (bossId === 'banditKing') {
                                    setQuestFlag('passportRecovery', 'bossDefeated', true);
                                    setQuestFlag('passportRecovery', 'completed', true);
                                    setStoryFlag('bazaarUnlocked', true);
                                    questMessage = 'ãƒã‚¶ãƒ¼ãƒ«ã®ç”ºã¸ã® é€šè¡Œæ‰‹å½¢ ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'pyramidGuardian') {
                                    setQuestFlag('royalCrest', 'bossDefeated', true);
                                    setQuestFlag('royalCrest', 'completed', true);
                                    questMessage = 'ç‹å®¶ã®ç´‹ç«  ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'desertGuardian') {
                                    setStoryFlag('desertPortalUnlocked', true);
                                    questMessage = 'ç ‚æ¼ ã®ç‹ã«å ±å‘Šã—ã‚ˆã†ï¼';
                                } else if (bossId === 'shadowGuardian') {
                                    setStoryFlag('shadowGuardianDefeated', true);
                                    setStoryFlag('area3Completed', true);
                                    setStoryFlag('northPathOpened', true);  // ã‚¨ãƒªã‚¢4ã¸ã®é“ãŒé–‹ã
                                    questMessage = 'é—‡ã®å®ˆè­·è€…ãŒ å…‰ã‚’å–ã‚Šæˆ»ã—ãŸ...';
                                } else if (bossId === 'wedgeGuardian_north') {
                                    collectWedge('wedge_north', true);
                                    questMessage = 'åŒ—ã®æ¥” ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'wedgeGuardian_east') {
                                    collectWedge('wedge_east', true);
                                    questMessage = 'æ±ã®æ¥” ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'wedgeGuardian_south') {
                                    collectWedge('wedge_south', true);
                                    questMessage = 'å—ã®æ¥” ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'wedgeGuardian_west') {
                                    collectWedge('wedge_west', true);
                                    questMessage = 'è¥¿ã®æ¥” ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼';
                                } else if (bossId === 'libraryGuardian') {
                                    setBossDefeated('libraryGuardian', true);
                                    questMessage = 'å›³æ›¸å®¤ã®å°å°ãŒè§£ã‹ã‚ŒãŸ...';
                                } else if (bossId === 'iceGolem') {
                                    setStoryFlag('iceGolemDefeated', true);
                                    setQuestFlag('glacioJoin', 'iceGolemDefeated', true);
                                    questMessage = 'æ°·ã®æ´çªŸã®å®ˆè­·è€…ãŒå€’ã‚ŒãŸ...æ°·ã®ç¥æ®¿ã¸ã®é“ãŒé–‹ã‹ã‚ŒãŸï¼';
                                } else if (bossId === 'iceQueen') {
                                    setStoryFlag('iceQueenDefeated', true);
                                    setStoryFlag('area4Completed', true);
                                    setStoryFlag('auroraOrbObtained', true);
                                    addItem(96);  // æ¥µå…‰ã®å®ç 
                                    questMessage = '...å¥³ç‹ã®ä¸­ã®é—‡ãŒæ¶ˆãˆã¦ã„ã...';
                                }

                                if (questMessage) {
                                    showBattleMessage(questMessage, () => {
                                        endBattle('win');
                                        saveGame();
                                    });
                                } else {
                                    endBattle('win');
                                    saveGame();
                                }
                            });
                        });
                    });
                });
            });
        }

        // ã“ã®ãƒ¬ãƒ™ãƒ«ã§ç¿’å¾—ã™ã‚‹å‘ªæ–‡ã‚’ãƒã‚§ãƒƒã‚¯
        function checkNewSpells(level) {
            const newSpells = [];
            for (const spellId in spells) {
                const spell = spells[spellId];
                // ã‚¸ãƒ§ãƒ–ã«å¿œã˜ãŸå‘ªæ–‡ç¿’å¾—ãƒã‚§ãƒƒã‚¯
                const canLearn = spell.learnableBy && spell.learnableBy.includes(player.job);
                if (spell.learnLevel === level && canLearn && !player.spells.includes(spellId)) {
                    newSpells.push(spellId);
                }
            }
            return newSpells;
        }

        // å‘ªæ–‡ç¿’å¾—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        function showSpellLearnMessages(spellList, callback) {
            if (spellList.length === 0) {
                callback();
                return;
            }
            const spellId = spellList.shift();
            const spell = spells[spellId];
            player.spells.push(spellId);
            showBattleMessage(`${spell.name} ã‚’ ãŠã¼ãˆãŸï¼`, () => {
                showSpellLearnMessages(spellList, callback);
            });
        }

        // å€‹åˆ¥ãƒ¡ãƒ³ãƒãƒ¼ã®ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å‡¦ç†
        function checkMemberLevelUp(member, callback) {
            if (member.level < expTable.length - 1 && member.exp >= expTable[member.level + 1]) {
                member.level++;

                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä¸Šæ˜‡ã‚’ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ è¾¼ã¿ã§è¨ˆç®—
                const hpUp = 3 + Math.floor(Math.random() * 5); // 3-7
                const mpUp = 1 + Math.floor(Math.random() * 3); // 1-3
                const atkUp = 1 + Math.floor(Math.random() * 2); // 1-2
                const defUp = 1 + Math.floor(Math.random() * 2); // 1-2
                const spdUp = Math.floor(Math.random() * 2); // 0-1

                member.maxHp += hpUp;
                member.maxMp += mpUp;
                member.baseAtk += atkUp;
                member.baseDef += defUp;
                member.speed += spdUp;
                // HP/MPã¯å…¨å›å¾©ã—ãªã„ï¼ˆå®¿å±‹ã®é‡è¦æ€§ã‚’é«˜ã‚ã‚‹ï¼‰

                // åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒä¸ŠãŒã£ãŸã®ã§ã“ã†ã’ãåŠ›ãƒ»ã—ã‚…ã³åŠ›ã‚’å†è¨ˆç®—
                updateMemberActualStats(member);

                // ã“ã®ãƒ¬ãƒ™ãƒ«ã§ç¿’å¾—ã™ã‚‹å‘ªæ–‡ã‚’ãƒã‚§ãƒƒã‚¯
                const newSpells = checkMemberNewSpells(member, member.level);

                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é †ç•ªã«è¡¨ç¤º
                SE.levelUp(); // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—éŸ³
                showBattleMessage(`${member.name} ã¯ ãƒ¬ãƒ™ãƒ«ãŒ ã‚ãŒã£ãŸï¼ Lv${member.level} ã«ãªã£ãŸï¼`, () => {
                    showBattleMessage(`ã•ã„ã ã„HP ãŒ ${hpUp} ã‚ãŒã£ãŸï¼`, () => {
                        showBattleMessage(`ã•ã„ã ã„MP ãŒ ${mpUp} ã‚ãŒã£ãŸï¼`, () => {
                            const afterStats = () => {
                                // å‘ªæ–‡ç¿’å¾—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                                showMemberSpellLearnMessages(member, newSpells, () => {
                                    checkMemberLevelUp(member, callback); // è¤‡æ•°ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å¯¾å¿œ
                                });
                            };
                            afterStats();
                        });
                    });
                });
            } else {
                callback();
            }
        }

        // ãƒ¡ãƒ³ãƒãƒ¼ã®å‘ªæ–‡ç¿’å¾—ãƒã‚§ãƒƒã‚¯
        function checkMemberNewSpells(member, level) {
            const newSpells = [];
            for (const spellId in spells) {
                const spell = spells[spellId];
                // ã‚¸ãƒ§ãƒ–ã«å¿œã˜ãŸå‘ªæ–‡ç¿’å¾—ãƒã‚§ãƒƒã‚¯
                const canLearn = spell.learnableBy && spell.learnableBy.includes(member.job);
                if (spell.learnLevel === level && canLearn && !member.spells.includes(spellId)) {
                    member.spells.push(spellId);
                    newSpells.push(spell);
                }
            }
            return newSpells;
        }

        // ãƒ¡ãƒ³ãƒãƒ¼ã®å‘ªæ–‡ç¿’å¾—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        function showMemberSpellLearnMessages(member, spellList, callback) {
            if (spellList.length === 0) {
                callback();
                return;
            }
            const spell = spellList.shift();
            showBattleMessage(`${member.name} ã¯ ${spell.name} ã‚’ ãŠã¼ãˆãŸï¼`, () => {
                showMemberSpellLearnMessages(member, spellList, callback);
            });
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
        function checkLevelUp(callback) {
            const aliveMembers = getAlivePartyMembers();
            let memberIndex = 0;

            const checkNext = () => {
                if (memberIndex >= aliveMembers.length) {
                    callback();
                    return;
                }
                const member = aliveMembers[memberIndex];
                memberIndex++;
                checkMemberLevelUp(member, checkNext);
            };

            checkNext();
        }

        function battleLose() {
            battle.phase = 'result';
            SE.defeat(); // æ•—åŒ—éŸ³
            showBattleMessage('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯ ãœã‚“ã‚ã¤ã—ãŸ...', () => {
                showBattleMessage('ãŠã†ã•ã¾ã€ŒããªãŸãŸã¡ã« ã‚‚ã†ä¸€åº¦ ãƒãƒ£ãƒ³ã‚¹ã‚’ ã‚„ã‚ã†ã€', () => {
                    // ã‚´ãƒ¼ãƒ«ãƒ‰åŠæ¸›
                    partyData.gold = Math.floor(partyData.gold / 2);
                    // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã‚’å¾©æ´»
                    party.forEach(member => {
                        member.hp = member.maxHp;
                        member.mp = member.maxMp;
                        member.isAlive = true;
                        member.status = { sleep: 0, poison: 0, blind: 0 };
                    });
                    partyData.x = 7;
                    partyData.y = 11;
                    currentMapId = 'castle';
                    currentMap = maps[currentMapId];
                    mapNameElement.textContent = currentMap.name;
                    updateMapNameColor();
                    endBattle('lose');
                });
            });
        }

        function endBattle(result) {
            battle.result = result;
            // ãƒãƒˆãƒ«çµ‚äº†æ™‚ã«æ­©æ•°ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
            stepsSinceLastBattle = 0;
            setTimeout(() => {
                gameMode = MODE.FIELD;
                battle.active = false;
                // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰BGMã«æˆ»ã™
                initAudio();
                BGM.play(BGM.getBgmTypeForMap(currentMap));
                // ãƒãƒƒãƒ—åã‚’å†è¡¨ç¤º
                mapNameArea.style.display = 'flex';
                updateCamera();
                saveGame();
            }, 500);
        }

        // ========================================
        // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        let endingState = {
            phase: 'none',      // none, fadeout, castle, talk, staffroll, theend
            fadeAlpha: 0,
            scrollY: 0,
            staffRollComplete: false
        };

        const staffRollText = [
            '',
            '',
            '~ CONGRATULATIONS! ~',
            '',
            '',
            'é­”ç‹ã‚’ å€’ã—',
            'ä¸–ç•Œã« å¹³å’ŒãŒ æˆ»ã£ãŸ',
            '',
            '',
            '',
            '-- STAFF --',
            '',
            'ã‚²ãƒ¼ãƒ ãƒ‡ã‚¶ã‚¤ãƒ³',
            '  ã‚ãªãŸ',
            '',
            'ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°',
            '  ã‚ãªãŸ',
            '',
            'ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯',
            '  ã‚ãªãŸ',
            '',
            '',
            '-- SPECIAL THANKS --',
            '',
            'æœ€å¾Œã¾ã§ ãƒ—ãƒ¬ã‚¤ã—ã¦ãã‚ŒãŸ',
            'ã‚ãªãŸã« æ„Ÿè¬ï¼',
            '',
            '',
            '',
            '',
            'THANK YOU FOR PLAYING!',
            '',
            '',
            '',
            '',
            '~ THE END ~',
            '',
            '',
            ''
        ];

        function startEnding() {
            endingState.phase = 'fadeout';
            endingState.fadeAlpha = 0;
            battle.active = false;
            BGM.play('ending'); // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°BGM

            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
            const fadeInterval = setInterval(() => {
                endingState.fadeAlpha += 0.02;
                if (endingState.fadeAlpha >= 1) {
                    clearInterval(fadeInterval);
                    // åŸã«ç§»å‹•
                    currentMapId = 'castle';
                    currentMap = maps[currentMapId];
                    player.x = 7;
                    player.y = 9;
                    mapNameElement.textContent = currentMap.name;
                    updateMapNameColor();

                    endingState.phase = 'castle';
                    gameMode = MODE.FIELD;

                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                    const fadeInInterval = setInterval(() => {
                        endingState.fadeAlpha -= 0.02;
                        if (endingState.fadeAlpha <= 0) {
                            endingState.fadeAlpha = 0;
                            clearInterval(fadeInInterval);
                            // å‡±æ—‹ã‚¤ãƒ™ãƒ³ãƒˆé–‹å§‹
                            setTimeout(() => {
                                startTriumphEvent();
                            }, 500);
                        }
                    }, 30);
                }
            }, 30);
        }

        function startTriumphEvent() {
            endingState.phase = 'talk';
            startDialog([
                'ãŠãŠ ã‚†ã†ã—ã‚ƒã‚ˆï¼',
                'ã‚ˆãã é­”ç‹ã‚’ ãŸãŠã—ã¦ãã‚ŒãŸï¼',
                'ã“ã‚Œã§ ä¸–ç•Œã« å¹³å’ŒãŒ ã‚‚ã©ã£ãŸï¼',
                'ããªãŸã® ã„ã•ãŠã—ã¯ ãªãŒã èªã‚Šç¶™ãŒã‚Œã‚‹ã§ã‚ã‚ã†',
                'ã‚ã‚ŠãŒã¨ã† ã‚†ã†ã—ã‚ƒã‚ˆï¼',
                '...ä¸–ç•Œã¯ å¹³å’Œã«ãªã£ãŸ...'
            ], () => {
                // ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«ã¸
                setTimeout(() => {
                    startStaffRoll();
                }, 1000);
            });
        }

        function startStaffRoll() {
            endingState.phase = 'staffroll';
            endingState.scrollY = canvasHeight;
            endingState.staffRollComplete = false;
            gameMode = MODE.ENDING;
        }

        function updateStaffRoll() {
            if (endingState.phase !== 'staffroll') return;

            endingState.scrollY -= 1;

            const textHeight = staffRollText.length * 30 + canvasHeight;
            if (endingState.scrollY < -textHeight + canvasHeight / 2) {
                endingState.phase = 'theend';
                endingState.fadeAlpha = 0;
            }
        }

        function drawEnding() {
            // ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«æç”»
            if (endingState.phase === 'staffroll') {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '20px "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif';

                for (let i = 0; i < staffRollText.length; i++) {
                    const y = endingState.scrollY + i * 30;
                    if (y > -30 && y < canvasHeight + 30) {
                        ctx.fillText(staffRollText[i], canvasWidth / 2, y);
                    }
                }

                ctx.textAlign = 'left';
            }

            // THE END è¡¨ç¤º
            if (endingState.phase === 'theend') {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                endingState.fadeAlpha = Math.min(1, endingState.fadeAlpha + 0.01);

                ctx.fillStyle = `rgba(255, 215, 0, ${endingState.fadeAlpha})`;
                ctx.textAlign = 'center';
                ctx.font = 'bold 48px "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif';
                ctx.fillText('THE END', canvasWidth / 2, canvasHeight / 2);

                ctx.font = '16px "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif';
                ctx.fillStyle = `rgba(255, 255, 255, ${endingState.fadeAlpha * 0.7})`;
                ctx.fillText('Press any key to return to title', canvasWidth / 2, canvasHeight / 2 + 60);

                ctx.textAlign = 'left';
            }
        }

        function handleEndingInput() {
            if (endingState.phase === 'theend' && endingState.fadeAlpha >= 1) {
                // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆï¼ˆã‚¿ã‚¤ãƒˆãƒ«ã¸ï¼‰
                resetGame();
            }
        }

        function resetGame() {
            // ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
            gameCleared = false;
            resetGameProgress();
            endingState.phase = 'none';
            endingState.fadeAlpha = 0;
            endingState.scrollY = 0;

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸåŒ–
            player.hp = 30;
            player.maxHp = 30;
            player.mp = 10;
            player.maxMp = 10;
            player.baseAtk = 8;
            player.baseDef = 5;
            player.atk = 8;
            player.def = 5;
            player.speed = 5;
            player.level = 1;
            player.exp = 0;
            player.gold = 100;
            player.x = 7;
            player.y = 11;
            player.dir = 0;
            player.inventory = [];
            player.equipment = { weapon: null, armor: null };
            player.spells = [];
            player.status = { sleep: 0, poison: 0, blind: 0 };

            openedChests = [];
            currentMapId = 'castle';
            currentMap = maps[currentMapId];
            mapNameElement.textContent = currentMap.name;
            updateMapNameColor();

            gameMode = MODE.FIELD;
            localStorage.removeItem('dragonQuestSave');
        }

        function checkRandomEncounter() {
            // å®‰å…¨åœ°å¸¯ã§ã¯ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„
            if (currentMap.isSafe === true) {
                // å®‰å…¨åœ°å¸¯ã«å…¥ã£ãŸã‚‰æ­©æ•°ãƒªã‚»ãƒƒãƒˆ
                if (stepsSinceLastBattle > 0) {
                    stepsSinceLastBattle = 0;
                }
                return;
            }

            // encounterRate=0ã®ãƒãƒƒãƒ—ã‚‚ã‚¹ã‚­ãƒƒãƒ—ï¼ˆisSafeæœªå®šç¾©ã®æ—§ãƒãƒƒãƒ—äº’æ›ï¼‰
            if (currentMap.encounterRate <= 0) return;

            // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚¿ã‚¤ãƒ«ä»¥å¤–ã¯ã‚¹ã‚­ãƒƒãƒ—
            const tile = currentMap.data[player.y][player.x];
            if (!ENCOUNTER_TILES.includes(tile)) return;

            // æ­©æ•°ã‚«ã‚¦ãƒ³ãƒˆ
            stepsSinceLastBattle++;

            // ä¸æ„Ÿåœ°å¸¯ã®åˆ¤å®šï¼ˆsafeStepsä»¥ä¸‹ã¯ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„ï¼‰
            if (stepsSinceLastBattle <= SAFE_STEPS) {
                // console.log(`[DEBUG] ä¸æ„Ÿåœ°å¸¯: ${stepsSinceLastBattle}/${SAFE_STEPS}æ­©`);
                return;
            }

            // ç¢ºç‡ã®è¨ˆç®—ï¼ˆæ­©ãã»ã©ä¸Šæ˜‡ï¼‰
            const stepsOverSafe = stepsSinceLastBattle - SAFE_STEPS;
            const currentEncounterRate = Math.min(
                stepsOverSafe * ENCOUNTER_RATE_PER_STEP,
                MAX_ENCOUNTER_RATE
            );

            // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã§ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
            // console.log(`[DEBUG] æ­©æ•°: ${stepsSinceLastBattle}, ç¢ºç‡: ${(currentEncounterRate * 100).toFixed(1)}%`);

            // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆåˆ¤å®š
            if (Math.random() < currentEncounterRate) {
                // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ã‚’é¸æŠï¼ˆå„ªå…ˆé †ä½ï¼‰
                // 1. ãƒãƒƒãƒ—ã«ç›´æ¥æŒ‡å®šã•ã‚ŒãŸencounterTable
                // 2. mapIdãƒ™ãƒ¼ã‚¹
                // 3. typeãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                const mapId = currentMap.mapId || '';
                let tableKey = currentMap.encounterTable || mapId;
                if (!encounterTables[tableKey]) {
                    // mapIdã§è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°typeã§æ¢ã™
                    tableKey = encounterTableFallback[currentMap.type] || 'field';
                }
                // tableKeyã‚’æ¸¡ã—ã¦ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
                startBattle(tableKey);
            }
        }

        // ç¾åœ¨ã®ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆç¢ºç‡ã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºç”¨ï¼‰
        function getCurrentEncounterRate() {
            if (currentMap.encounterRate <= 0) return 0;
            if (stepsSinceLastBattle <= SAFE_STEPS) return 0;
            const stepsOverSafe = stepsSinceLastBattle - SAFE_STEPS;
            return Math.min(stepsOverSafe * ENCOUNTER_RATE_PER_STEP, MAX_ENCOUNTER_RATE);
        }

        // ========================================
        // NPCãƒ»å®ç®±
        // ========================================

        // NPCã®æœ‰åŠ¹ãªä½ç½®ã‚’å–å¾—ï¼ˆã‚¹ãƒˆãƒ¼ãƒªãƒ¼é€²è¡Œã§ç§»å‹•ã™ã‚‹NPCå¯¾å¿œï¼‰
        function getNpcEffectivePosition(npc) {
            let x = npc.x;
            let y = npc.y;

            // portal_guardã‚¿ã‚¤ãƒ—: æ—…ã®æ‰‰ãŒé–‹æ”¾ã•ã‚ŒãŸã‚‰æ¨ªã«ã©ã
            if (npc.type === 'portal_guard' && getStoryFlag('portalRoomUnlocked')) {
                x = npc.x + 1;  // å³ã«1ãƒã‚¹ç§»å‹•
            }

            // desert_portal_guardã®å ´åˆï¼ˆç ‚æ¼ ã‚¨ãƒªã‚¢ç”¨ï¼‰
            if (npc.id === 'desert_portal_guard' && isBossDefeated('desertGuardian')) {
                x = npc.x + 1;
            }

            return { x, y };
        }

        function getNpcAt(x, y) {
            if (!currentMap.npcs) return null;
            return currentMap.npcs.find(npc => {
                const pos = getNpcEffectivePosition(npc);
                return pos.x === x && pos.y === y;
            }) || null;
        }

        function getChestAt(x, y) {
            if (!currentMap.chests) return null;
            return currentMap.chests.find(chest => chest.x === x && chest.y === y) || null;
        }

        function isNpcBlocking(x, y) { return getNpcAt(x, y) !== null; }
        function isChestBlocking(x, y) { return getChestAt(x, y) !== null; }

        // ========================================
        // ä¼šè©±ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        function startDialog(messages) {
            dialog.active = true;
            dialog.messages = Array.isArray(messages) ? messages : [messages];
            dialog.currentIndex = 0;
            dialog.displayedText = '';
            dialog.charIndex = 0;
            dialog.isTyping = true;
            typeNextChar();
        }

        function typeNextChar() {
            if (!dialog.active) return;
            const currentMessage = dialog.messages[dialog.currentIndex];
            if (dialog.charIndex < currentMessage.length) {
                dialog.displayedText += currentMessage[dialog.charIndex];
                dialog.charIndex++;
                setTimeout(typeNextChar, dialog.typingSpeed);
            } else {
                dialog.isTyping = false;
            }
        }

        function advanceDialog() {
            if (!dialog.active) return;
            if (dialog.isTyping) {
                dialog.displayedText = dialog.messages[dialog.currentIndex];
                dialog.charIndex = dialog.messages[dialog.currentIndex].length;
                dialog.isTyping = false;
            } else if (dialog.currentIndex < dialog.messages.length - 1) {
                dialog.currentIndex++;
                dialog.displayedText = '';
                dialog.charIndex = 0;
                dialog.isTyping = true;
                typeNextChar();
            } else {
                closeDialog();
            }
        }

        function closeDialog() {
            const callback = dialog.onComplete;
            dialog.active = false;
            dialog.messages = [];
            dialog.currentIndex = 0;
            dialog.displayedText = '';
            dialog.onComplete = null;
            // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒã‚ã‚Œã°å®Ÿè¡Œ
            if (callback) {
                callback();
            }
        }

        // ========================================
        // å®ç®±ãƒ»ãƒ¡ãƒ‹ãƒ¥ãƒ¼
        // ========================================
        function openChest(chest) {
            if (chest.isOpened) {
                startDialog(['å®ç®±ã¯ ã‹ã‚‰ã£ã½ã ã€‚']);
            } else {
                const item = items[chest.itemId];
                if (item) {
                    SE.chest(); // å®ç®±SE
                    chest.isOpened = true;
                    // mapsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®ç®±ã‚‚åŒæœŸï¼ˆã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã«åæ˜ ã•ã›ã‚‹ãŸã‚ï¼‰
                    if (maps[currentMapId] && maps[currentMapId].chests) {
                        const mapChest = maps[currentMapId].chests.find(c => c.id === chest.id);
                        if (mapChest) mapChest.isOpened = true;
                    }
                    addItem(item.id, 1);
                    startDialog(['å®ç®±ã‚’ã‚ã‘ãŸï¼', `${item.name} ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`]);
                    saveGame();
                }
            }
        }

        function openMenu() {
            if (dialog.active || isTransitioning || gameMode === MODE.BATTLE || inn.active || partyJoinConfirm.active) return;
            SE.confirm(); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹ãSE
            menu.active = true;
            menu.mode = 'status'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢
        }

        function closeMenu() {
            SE.cancel(); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‰ã˜ã‚‹SE
            menu.active = false;
            menu.showItemAction = false;
            menu.itemActionIndex = 0;
            menu.selectingMember = false;
            menu.selectingEquipMember = false;
            menu.selectingItemMember = false;
            menu.memberCursor = 0;
            menu.targetMemberCursor = 0;
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        function executeItemAction() {
            if (player.inventory.length === 0) return;

            // validItemsã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆè¡¨ç¤ºã¨åŒã˜ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰
            const validItems = player.inventory.filter(slot => items[slot.id]);
            if (validItems.length === 0) return;

            const slot = validItems[menu.itemCursor];
            if (!slot) return;
            const selectedItemId = slot.id;
            const selectedItem = items[selectedItemId];
            if (!selectedItem) return;

            const isEquipment = (selectedItem.type === 'weapon' || selectedItem.type === 'armor');

            switch (menu.itemActionIndex) {
                case 0: // ã¤ã‹ã† or ãã†ã³ã™ã‚‹
                    if (isEquipment) {
                        // ãƒ‘ãƒ¼ãƒ†ã‚£ãŒè¤‡æ•°ã„ã‚‹å ´åˆã¯è£…å‚™å¯¾è±¡ã‚’é¸æŠ
                        if (party.length > 1) {
                            menu.selectingEquipMember = true;
                            menu.targetMemberCursor = 0;
                            menu.showItemAction = false;
                        } else {
                            // è£…å‚™ã™ã‚‹ï¼ˆ1äººã®å ´åˆã¯ç›´æ¥ï¼‰
                            const result = equipItem(selectedItemId);
                            closeMenu();
                            if (result) {
                                startDialog([`${selectedItem.name}ã‚’ ãã†ã³ã—ãŸï¼`]);
                            } else {
                                startDialog([`${player.name}ã¯ ${selectedItem.name}ã‚’ ãã†ã³ã§ããªã„ï¼`]);
                            }
                        }
                    } else {
                        // ä½¿ã† - å¯¾è±¡é¸æŠãŒå¿…è¦ãªã‚¢ã‚¤ãƒ†ãƒ ã‹ãƒã‚§ãƒƒã‚¯
                        const needsTarget = (selectedItem.type === 'heal' || selectedItem.type === 'cure');
                        if (needsTarget && party.length > 1) {
                            menu.selectingItemMember = true;
                            menu.targetMemberCursor = 0;
                            menu.showItemAction = false;
                        } else {
                            useItem(selectedItemId);
                        }
                    }
                    break;

                case 1: // ã™ã¦ã‚‹
                    removeItem(selectedItemId, 1);
                    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®èª¿æ•´ï¼ˆæœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ æ•°ã§ãƒã‚§ãƒƒã‚¯ï¼‰
                    {
                        const validItems = player.inventory.filter(slot => items[slot.id]);
                        if (menu.itemCursor >= validItems.length && menu.itemCursor > 0) {
                            menu.itemCursor--;
                        }
                    }
                    menu.showItemAction = false;
                    if (player.inventory.length === 0) {
                        closeMenu();
                        startDialog([`${selectedItem.name}ã‚’ ã™ã¦ãŸã€‚`]);
                    }
                    break;

                case 2: // ã›ã„ã¨ã‚“
                    organizeInventory();
                    menu.itemCursor = 0;
                    menu.showItemAction = false;
                    break;

                case 3: // ã‚„ã‚ã‚‹
                    menu.showItemAction = false;
                    break;
            }
        }

        // è£…å‚™å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼ç¢ºå®š
        function confirmEquipMember() {
            // validItemsã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆè¡¨ç¤ºã¨åŒã˜ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰
            const validItems = player.inventory.filter(slot => items[slot.id]);
            const slot = validItems[menu.itemCursor];
            if (!slot) return;
            const selectedItemId = slot.id;
            const selectedItem = items[selectedItemId];
            if (!selectedItem) return;

            const targetMember = party[menu.targetMemberCursor];
            const result = equipItem(selectedItemId, targetMember);
            menu.selectingEquipMember = false;
            closeMenu();

            if (result) {
                startDialog([`${targetMember.name}ã¯ ${selectedItem.name}ã‚’ ãã†ã³ã—ãŸï¼`]);
            } else {
                startDialog([`${targetMember.name}ã¯ ${selectedItem.name}ã‚’ ãã†ã³ã§ããªã„ï¼`]);
            }
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼ç¢ºå®š
        function confirmItemMember() {
            // validItemsã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆè¡¨ç¤ºã¨åŒã˜ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰
            const validItems = player.inventory.filter(slot => items[slot.id]);
            const slot = validItems[menu.itemCursor];
            if (!slot) return;
            const selectedItemId = slot.id;
            const selectedItem = items[selectedItemId];
            if (!selectedItem) return;

            const targetMember = party[menu.targetMemberCursor];
            menu.selectingItemMember = false;
            useItem(selectedItemId, targetMember);
        }

        // ========================================
        // å®¿å±‹ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        function openInn(cost) {
            inn.active = true;
            inn.cost = cost;
            inn.selectedIndex = 0;
        }

        function closeInn() {
            inn.active = false;
        }

        function confirmInn() {
            if (inn.selectedIndex === 0) {
                // ã¯ã„
                if (player.gold >= inn.cost) {
                    player.gold -= inn.cost;
                    closeInn();
                    // æš—è»¢æ¼”å‡º
                    fadeOverlay.classList.add('active');
                    setTimeout(() => {
                        // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®HP/MPå…¨å›å¾©ï¼‹æˆ¦é—˜ä¸èƒ½å¾©æ´»
                        restoreAll();
                        saveGame();
                        setTimeout(() => {
                            fadeOverlay.classList.remove('active');
                            SE.inn(); // å®¿å±‹å›å¾©SE
                            startDialog(['ã‚†ã£ãã‚Š ãŠã‚„ã™ã¿ãã ã•ã„...', 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼', 'ã¿ã‚“ãªã® HPã¨MPãŒ ã‹ã„ãµãã—ã¾ã—ãŸï¼']);
                        }, 500);
                    }, 500);
                } else {
                    closeInn();
                    startDialog(['ãŠé‡‘ãŒ ãŸã‚Šãªã„ã‚ˆã†ã§ã™...']);
                }
            } else {
                // ã„ã„ãˆ
                closeInn();
                startDialog(['ã¾ãŸã®ãŠè¶Šã—ã‚’ ãŠã¾ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚']);
            }
        }

        // ========================================
        // æ•™ä¼šã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        function openChurch() {
            church.active = true;
            church.menuIndex = 0;
            church.phase = 'menu';
            church.selectedMember = 0;
            church.confirmIndex = 0;
        }

        function closeChurch() {
            church.active = false;
            church.phase = 'menu';
        }

        // å¾©æ´»ã®è²»ç”¨ã‚’è¨ˆç®—ï¼ˆãƒ¬ãƒ™ãƒ« Ã— 10ã‚´ãƒ¼ãƒ«ãƒ‰ï¼‰
        function getReviveCost(member) {
            return member.level * 10;
        }

        // æ¯’æ²»ç™‚ã®è²»ç”¨ï¼ˆå›ºå®šï¼‰
        function getCureCost() {
            return 5;
        }

        // æ•™ä¼šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é¸æŠè‚¢ã«å¿œã˜ãŸå‡¦ç†
        function selectChurchMenu() {
            switch (church.menuIndex) {
                case 0: // ã„ãã‹ãˆã‚‰ã›ã‚‹
                    const deadMembers = getDeadPartyMembers();
                    if (deadMembers.length === 0) {
                        startDialog(['ãŠãŠã€ã¿ãªã•ã‚“ ã”ç„¡äº‹ã®ã‚ˆã†ã§ã™ã­ã€‚', 'ã„ãã‹ãˆã‚‰ã›ã‚‹ ã²ã¤ã‚ˆã†ã¯ ã‚ã‚Šã¾ã›ã‚“ã€‚']);
                        closeChurch();
                    } else {
                        church.phase = 'selectMember';
                        church.selectedMember = party.findIndex(m => !m.isAlive || m.hp <= 0);
                    }
                    break;
                case 1: // ã©ãã®ã¡ã‚Šã‚‡ã†
                    const poisonedMembers = party.filter(m => m.status && m.status.poison > 0);
                    if (poisonedMembers.length === 0) {
                        startDialog(['ã©ãã« ãŠã‹ã•ã‚Œã¦ã„ã‚‹æ–¹ã¯ ã„ã‚‰ã£ã—ã‚ƒã„ã¾ã›ã‚“ã­ã€‚']);
                        closeChurch();
                    } else {
                        church.phase = 'selectMember';
                        church.selectedMember = party.findIndex(m => m.status && m.status.poison > 0);
                    }
                    break;
                case 2: // ãŠã„ã®ã‚Šã‚’ã™ã‚‹ï¼ˆã‚»ãƒ¼ãƒ–ï¼‰
                    saveGame();
                    SE.save(); // ã‚»ãƒ¼ãƒ–éŸ³
                    startDialog(['ãŠã„ã®ã‚Šã‚’ ã•ã•ã’ã¾ã—ãŸã€‚', 'ã¼ã†ã‘ã‚“ã®ã—ã‚‡ã« ãã‚ãã—ã¾ã—ãŸã€‚']);
                    closeChurch();
                    break;
                case 3: // ã‚„ã‚ã‚‹
                    startDialog(['ã¾ãŸ ã„ã¤ã§ã‚‚ ãŠã“ã—ãã ã•ã„ã€‚']);
                    closeChurch();
                    break;
            }
        }

        // ãƒ¡ãƒ³ãƒãƒ¼é¸æŠã®æ±ºå®š
        function confirmChurchMember() {
            const member = party[church.selectedMember];
            if (!member) {
                closeChurch();
                return;
            }

            if (church.menuIndex === 0) {
                // å¾©æ´»ã®ç¢ºèª
                if (member.isAlive && member.hp > 0) {
                    // ç”Ÿãã¦ã„ã‚‹ãƒ¡ãƒ³ãƒãƒ¼ã‚’é¸ã‚“ã 
                    startDialog([`${member.name} ã¯ ãŸãŠã‚Œã¦ã„ã¾ã›ã‚“ã€‚`]);
                    church.phase = 'menu';
                } else {
                    const cost = getReviveCost(member);
                    church.phase = 'confirm';
                    // ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æç”»ã§è¡¨ç¤º
                }
            } else if (church.menuIndex === 1) {
                // æ¯’æ²»ç™‚ã®ç¢ºèª
                if (!member.status || member.status.poison <= 0) {
                    startDialog([`${member.name} ã¯ ã©ãã« ãŠã‹ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`]);
                    church.phase = 'menu';
                } else {
                    church.phase = 'confirm';
                }
            }
        }

        // å¾©æ´»ãƒ»æ²»ç™‚ã®æœ€çµ‚ç¢ºèª
        function confirmChurchAction() {
            const member = party[church.selectedMember];
            if (!member) {
                closeChurch();
                return;
            }

            if (church.confirmIndex === 0) {
                // ã¯ã„
                if (church.menuIndex === 0) {
                    // å¾©æ´»
                    const cost = getReviveCost(member);
                    if (partyData.gold >= cost) {
                        partyData.gold -= cost;
                        reviveMember(member, true); // å…¨å›å¾©ã§å¾©æ´»
                        saveGame();
                        SE.revive(); // å¾©æ´»SE
                        startDialog([`${member.name} ã¯ ã„ãã‹ãˆã£ãŸï¼`]);
                    } else {
                        startDialog(['ãŠé‡‘ãŒ ãŸã‚Šãªã„ã‚ˆã†ã§ã™...']);
                    }
                } else if (church.menuIndex === 1) {
                    // æ¯’æ²»ç™‚
                    const cost = getCureCost();
                    if (partyData.gold >= cost) {
                        partyData.gold -= cost;
                        member.status.poison = 0;
                        saveGame();
                        startDialog([`${member.name} ã® ã©ãã‚’ ãªãŠã—ã¾ã—ãŸï¼`]);
                    } else {
                        startDialog(['ãŠé‡‘ãŒ ãŸã‚Šãªã„ã‚ˆã†ã§ã™...']);
                    }
                }
            } else {
                // ã„ã„ãˆ
                startDialog(['ãã†ã§ã™ã‹...']);
            }
            closeChurch();
        }

        // ========================================
        // ã‚·ãƒ§ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        function openShop(shopId = 'default') {
            currentShopId = shopId;
            shop.active = true;
            shop.mode = 'menu';
            shop.phase = 'list';
            shop.menuIndex = 0;
            shop.selectedIndex = 0;
            shop.confirmIndex = 0;
            shop.equipIndex = 0;
            shop.selectedItem = null;
            shop.sellableItems = [];
        }

        // å£²å´å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’ä½œæˆï¼ˆè£…å‚™ä¸­ã®ã‚‚ã®ã¯é™¤å¤–ï¼‰
        function updateSellableItems() {
            shop.sellableItems = player.inventory.filter(slot => {
                const item = items[slot.id];
                // ä¾¡æ ¼ãŒ0ã®ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆä¼èª¬ã®å‰£ãªã©ï¼‰ã¯å£²ã‚Œãªã„
                if (!item || item.price === 0) return false;
                return true;
            });
        }

        function closeShop() {
            shop.active = false;
            startDialog(['ã¾ãŸã®ãŠè¶Šã—ã‚’ ãŠã¾ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚']);
        }

        function handleShopInput(action) {
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‹ã†/ã†ã‚‹/ã‚„ã‚ã‚‹ï¼‰
            if (shop.mode === 'menu') {
                if (action === 'up') {
                    shop.menuIndex = Math.max(0, shop.menuIndex - 1);
                } else if (action === 'down') {
                    shop.menuIndex = Math.min(2, shop.menuIndex + 1);
                } else if (action === 'confirm') {
                    if (shop.menuIndex === 0) {
                        // ã‹ã†
                        shop.mode = 'buy';
                        shop.phase = 'list';
                        shop.selectedIndex = 0;
                    } else if (shop.menuIndex === 1) {
                        // ã†ã‚‹
                        updateSellableItems();
                        shop.mode = 'sell';
                        shop.phase = 'list';
                        shop.selectedIndex = 0;
                    } else {
                        // ã‚„ã‚ã‚‹
                        closeShop();
                    }
                } else if (action === 'cancel') {
                    closeShop();
                }
                return;
            }

            // è³¼å…¥ãƒ¢ãƒ¼ãƒ‰
            if (shop.mode === 'buy') {
                if (shop.phase === 'list') {
                    if (action === 'up') {
                        shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    } else if (action === 'down') {
                        shop.selectedIndex = Math.min(getShopItems().length - 1, shop.selectedIndex + 1);
                    } else if (action === 'confirm') {
                        const itemId = getShopItems()[shop.selectedIndex];
                        const item = items[itemId];
                        if (player.gold >= item.price) {
                            shop.selectedItem = item;
                            shop.phase = 'confirm';
                            shop.confirmIndex = 0;
                        }
                    } else if (action === 'cancel') {
                        shop.mode = 'menu';
                        shop.menuIndex = 0;
                    }
                } else if (shop.phase === 'confirm') {
                    if (action === 'left') {
                        shop.confirmIndex = 0;
                    } else if (action === 'right') {
                        shop.confirmIndex = 1;
                    } else if (action === 'confirm') {
                        if (shop.confirmIndex === 0) {
                            // è³¼å…¥
                            SE.buy(); // è³¼å…¥SE
                            player.gold -= shop.selectedItem.price;
                            addItem(shop.selectedItem.id, 1);
                            shop.phase = 'equip';
                            shop.equipIndex = 0;
                        } else {
                            shop.phase = 'list';
                        }
                    } else if (action === 'cancel') {
                        shop.phase = 'list';
                    }
                } else if (shop.phase === 'equip') {
                    if (action === 'left') {
                        shop.equipIndex = 0;
                    } else if (action === 'right') {
                        shop.equipIndex = 1;
                    } else if (action === 'confirm') {
                        if (shop.equipIndex === 0) {
                            equipItem(shop.selectedItem.id);
                        }
                        saveGame();
                        shop.phase = 'list';
                    } else if (action === 'cancel') {
                        saveGame();
                        shop.phase = 'list';
                    }
                }
                return;
            }

            // å£²å´ãƒ¢ãƒ¼ãƒ‰
            if (shop.mode === 'sell') {
                if (shop.phase === 'list') {
                    if (action === 'up') {
                        shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    } else if (action === 'down') {
                        shop.selectedIndex = Math.min(Math.max(0, shop.sellableItems.length - 1), shop.selectedIndex + 1);
                    } else if (action === 'confirm') {
                        if (shop.sellableItems.length > 0) {
                            const slot = shop.sellableItems[shop.selectedIndex];
                            shop.selectedItem = items[slot.id];
                            shop.phase = 'confirm';
                            shop.confirmIndex = 0;
                        }
                    } else if (action === 'cancel') {
                        shop.mode = 'menu';
                        shop.menuIndex = 1;
                    }
                } else if (shop.phase === 'confirm') {
                    if (action === 'left') {
                        shop.confirmIndex = 0;
                    } else if (action === 'right') {
                        shop.confirmIndex = 1;
                    } else if (action === 'confirm') {
                        if (shop.confirmIndex === 0) {
                            // å£²å´å®Ÿè¡Œ
                            const sellPrice = Math.floor(shop.selectedItem.price / 2);
                            player.gold += sellPrice;
                            // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
                            removeItem(shop.selectedItem.id, 1);
                            shop.phase = 'sold';
                        } else {
                            shop.phase = 'list';
                        }
                    } else if (action === 'cancel') {
                        shop.phase = 'list';
                    }
                } else if (shop.phase === 'sold') {
                    // å£²å´å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¾Œ
                    if (action === 'confirm' || action === 'cancel') {
                        updateSellableItems();
                        shop.selectedIndex = Math.min(shop.selectedIndex, Math.max(0, shop.sellableItems.length - 1));
                        shop.phase = 'list';
                        saveGame();
                    }
                }
            }
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨
        function useItem(itemId, targetMember = null) {
            const item = items[itemId];
            if (!item) return false;

            // è£…å‚™ã‚¢ã‚¤ãƒ†ãƒ ã¯ä½¿ç”¨ã§ããªã„ï¼ˆè£…å‚™ã™ã‚‹ã‚’é¸ã¶å¿…è¦ãŒã‚ã‚‹ï¼‰
            if (item.type === 'weapon' || item.type === 'armor') {
                return false;
            }

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            const target = targetMember || player;
            let message = '';
            let success = false;

            switch (item.type) {
                case 'heal':
                    // HPå›å¾©ã‚¢ã‚¤ãƒ†ãƒ 
                    // æˆ¦é—˜ä¸èƒ½è€…ã«ã¯ä½¿ç”¨ã§ããªã„
                    if (!target.isAlive || target.hp <= 0) {
                        message = `${target.name}ã¯ ãŸãŠã‚Œã¦ã„ã‚‹ï¼`;
                    } else if (target.hp >= target.maxHp) {
                        message = `${target.name}ã® HPã¯ ã¾ã‚“ãŸã‚“ã ï¼`;
                    } else {
                        const healAmount = Math.min(item.value, target.maxHp - target.hp);
                        target.hp += healAmount;
                        message = `${target.name}ã« ${item.name}ã‚’ä½¿ã£ãŸï¼\nHPãŒ ${healAmount} å›å¾©ã—ãŸï¼`;
                        success = true;
                    }
                    break;

                case 'revive':
                    // ä¸–ç•Œæ¨¹ã®è‘‰ï¼šæˆ¦é—˜ä¸èƒ½ã‹ã‚‰å¾©æ´»
                    if (target.isAlive && target.hp > 0) {
                        message = `${target.name}ã¯ ãŸãŠã‚Œã¦ã„ãªã„ï¼`;
                    } else {
                        reviveMember(target, true); // HPå…¨å›å¾©ã§å¾©æ´»
                        message = `${target.name}ã« ${item.name}ã‚’ä½¿ã£ãŸï¼\n${target.name}ã¯ ã„ãã‹ãˆã£ãŸï¼`;
                        success = true;
                        saveGame();
                    }
                    break;

                case 'cure':
                    // çŠ¶æ…‹ç•°å¸¸å›å¾©ï¼ˆæ¯’ãªã©ï¼‰
                    if (target.status && target.status.poison > 0) {
                        target.status.poison = 0;
                        message = `${target.name}ã« ${item.name}ã‚’ä½¿ã£ãŸï¼\næ¯’ãŒ æ²»ã£ãŸï¼`;
                        success = true;
                    } else {
                        message = `${target.name}ã¯ æ¯’ã« ã‹ã‹ã£ã¦ã„ãªã„ï¼`;
                    }
                    break;

                case 'holy':
                    // è–æ°´ï¼šã—ã°ã‚‰ãã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„åŠ¹æœ
                    message = `${item.name}ã‚’ä½¿ã£ãŸï¼\nã—ã°ã‚‰ã é­”ç‰©ãŒ ã‚ˆã‚Šã¤ã‹ãªã„ï¼`;
                    stepsSinceLastBattle = -10; // æ­©æ•°ã‚’ãƒã‚¤ãƒŠã‚¹ã«ã—ã¦ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆå›é¿
                    success = true;
                    break;

                case 'escape':
                    // ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ï¼šç”ºã«æˆ»ã‚‹
                    if (currentMap.type === 'town' || currentMap.type === 'castle') {
                        message = 'ã“ã“ã§ã¯ ä½¿ãˆãªã„ï¼';
                    } else {
                        // ã‚¢ã‚¤ãƒ†ãƒ æ¶ˆè²»
                        removeItem(itemId, 1);
                        {
                            const validItems = player.inventory.filter(slot => items[slot.id]);
                            if (menu.itemCursor >= validItems.length && menu.itemCursor > 0) {
                                menu.itemCursor--;
                            }
                        }
                        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã¦ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤ºã€å®Œäº†å¾Œã«ãƒ¯ãƒ¼ãƒ—
                        closeMenu();
                        startDialogWithCallback(
                            [`${item.name}ã‚’ä½¿ã£ãŸï¼`, `${lastTown.name}ã« é£›ã‚“ã§ã„ã...`],
                            () => {
                                performMapWarp(lastTown.mapPath, lastTown.x, lastTown.y);
                            }
                        );
                        return true;
                    }
                    break;

                case 'key':
                    // éµï¼šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã¯ä½¿ãˆãªã„
                    message = 'ã“ã“ã§ã¯ ä½¿ãˆãªã„ï¼';
                    break;

                default:
                    message = 'ã“ã“ã§ã¯ ä½¿ãˆãªã„ï¼';
                    break;
            }

            // ä½¿ç”¨æˆåŠŸæ™‚ã€ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
            if (success) {
                removeItem(itemId, 1);
                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®èª¿æ•´ï¼ˆæœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ æ•°ã§ãƒã‚§ãƒƒã‚¯ï¼‰
                const validItems = player.inventory.filter(slot => items[slot.id]);
                if (menu.itemCursor >= validItems.length && menu.itemCursor > 0) {
                    menu.itemCursor--;
                }
            }

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã¦ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
            closeMenu();
            startDialog(message.split('\n'));
            return success;
        }

        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å‘ªæ–‡ã‚’ä½¿ç”¨
        function useSpellInField() {
            const caster = party[menu.memberCursor] || party[0];
            if (caster.spells.length === 0) return;

            // æˆ¦é—˜ä¸èƒ½ãƒã‚§ãƒƒã‚¯
            if (!caster.isAlive || caster.hp <= 0) {
                closeMenu();
                startDialog([`${caster.name}ã¯ ãŸãŠã‚Œã¦ã„ã‚‹ï¼`]);
                return;
            }

            const spellId = caster.spells[menu.spellCursor];
            const spell = spells[spellId];
            if (!spell) return;

            // MPä¸è¶³ãƒã‚§ãƒƒã‚¯
            if (caster.mp < spell.mp) {
                closeMenu();
                startDialog(['MPãŒ è¶³ã‚Šãªã„ï¼']);
                return;
            }

            // å‘ªæ–‡ã‚¿ã‚¤ãƒ—åˆ¥å‡¦ç†
            if (spell.type === 'heal') {
                // å›å¾©å‘ªæ–‡ - ãƒ‘ãƒ¼ãƒ†ã‚£ãŒã„ã‚‹å ´åˆã¯å¯¾è±¡é¸æŠ
                if (party.length > 1) {
                    menu.selectingMember = true;
                    menu.targetMemberCursor = 0;
                } else {
                    // ã‚½ãƒ­ãƒ—ãƒ¬ã‚¤æ™‚ã¯è‡ªåˆ†ã«ä½¿ã†
                    if (caster.hp >= caster.maxHp) {
                        closeMenu();
                        startDialog(['HPã¯ ã¾ã‚“ãŸã‚“ã ï¼']);
                        return;
                    }

                    caster.mp -= spell.mp;
                    const healAmount = Math.min(spell.power, caster.maxHp - caster.hp);
                    caster.hp += healAmount;

                    closeMenu();
                    startDialog([
                        `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                        `HPãŒ ${healAmount} å›å¾©ã—ãŸï¼`
                    ]);
                }

            } else if (spell.type === 'warp') {
                // ãƒ«ãƒ¼ãƒ©ï¼ˆæ‹ ç‚¹ãƒ¯ãƒ¼ãƒ—ï¼‰
                useRura();

            } else if (spell.type === 'escape') {
                // ãƒªãƒ¬ãƒŸãƒˆï¼ˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³è„±å‡ºï¼‰
                useRiremito();

            } else if (spell.type === 'revive') {
                // ã‚¶ã‚ªãƒ©ãƒ«ï¼ˆå¾©æ´»å‘ªæ–‡ï¼‰- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ä½¿ç”¨
                const deadMembers = getDeadPartyMembers();
                if (deadMembers.length === 0) {
                    closeMenu();
                    startDialog(['ã ã‚Œã‚‚ ãŸãŠã‚Œã¦ã„ãªã„ï¼']);
                    return;
                }
                // ãƒ‘ãƒ¼ãƒ†ã‚£ãŒè¤‡æ•°ãªã‚‰å¯¾è±¡é¸æŠ
                if (party.length > 1) {
                    menu.selectingMember = true;
                    menu.targetMemberCursor = party.findIndex(m => !m.isAlive || m.hp <= 0);
                } else {
                    closeMenu();
                    startDialog(['ã ã‚Œã‚‚ ãŸãŠã‚Œã¦ã„ãªã„ï¼']);
                }

            } else {
                closeMenu();
                startDialog(['ã“ã“ã§ã¯ ä½¿ãˆãªã„ï¼']);
            }
        }

        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å‘ªæ–‡ã‚’å¯¾è±¡ã«ä½¿ç”¨
        function executeFieldSpellOnTarget() {
            const caster = party[menu.memberCursor] || party[0];
            const target = party[menu.targetMemberCursor];
            if (!target) {
                menu.selectingMember = false;
                return;
            }

            const spellId = caster.spells[menu.spellCursor];
            const spell = spells[spellId];
            if (!spell) {
                menu.selectingMember = false;
                return;
            }

            // å›å¾©å‘ªæ–‡ã®å‡¦ç†
            if (spell.type === 'heal') {
                // æˆ¦é—˜ä¸èƒ½è€…ã«ã¯å›å¾©å‘ªæ–‡ã¯åŠ¹ã‹ãªã„
                if (!target.isAlive || target.hp <= 0) {
                    menu.selectingMember = false;
                    closeMenu();
                    startDialog([`${target.name}ã¯ ãŸãŠã‚Œã¦ã„ã‚‹ï¼`]);
                    return;
                }
                if (target.hp >= target.maxHp) {
                    menu.selectingMember = false;
                    closeMenu();
                    startDialog([`${target.name}ã® HPã¯ ã¾ã‚“ãŸã‚“ã ï¼`]);
                    return;
                }

                caster.mp -= spell.mp;
                const healAmount = Math.min(spell.power, target.maxHp - target.hp);
                target.hp += healAmount;

                menu.selectingMember = false;
                closeMenu();

                if (caster === target) {
                    startDialog([
                        `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                        `HPãŒ ${healAmount} å›å¾©ã—ãŸï¼`
                    ]);
                } else {
                    startDialog([
                        `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                        `${target.name}ã® HPãŒ ${healAmount} å›å¾©ã—ãŸï¼`
                    ]);
                }
            } else if (spell.type === 'revive') {
                // å¾©æ´»å‘ªæ–‡ï¼ˆã‚¶ã‚ªãƒ©ãƒ«ï¼‰ã®å‡¦ç†
                if (target.isAlive && target.hp > 0) {
                    menu.selectingMember = false;
                    closeMenu();
                    startDialog([`${target.name}ã¯ ãŸãŠã‚Œã¦ã„ãªã„ï¼`]);
                    return;
                }

                caster.mp -= spell.mp;
                menu.selectingMember = false;
                closeMenu();

                // 50%ã®æˆåŠŸç‡
                const successRate = spell.successRate || 0.5;
                if (Math.random() < successRate) {
                    reviveMember(target, false); // HPåŠåˆ†ã§å¾©æ´»
                    saveGame();
                    startDialog([
                        `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                        `${target.name}ã¯ ã„ãã‹ãˆã£ãŸï¼`
                    ]);
                } else {
                    startDialog([
                        `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                        `ã—ã‹ã— ${target.name}ã¯ ã„ãã‹ãˆã‚‰ãªã‹ã£ãŸ...`
                    ]);
                }
            }
        }

        // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šæ‹ ç‚¹é¸æŠçŠ¶æ…‹
        let ruraState = {
            active: false,
            cursor: 0,
            casterIndex: 0 // å‘ªæ–‡ã‚’å”±ãˆã‚‹ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
        };

        // ãƒ«ãƒ¼ãƒ©ã‚’ä½¿ç”¨ï¼ˆæ‹ ç‚¹é¸æŠUIã‚’è¡¨ç¤ºï¼‰
        function useRura() {
            const caster = party[menu.memberCursor] || party[0];
            const spell = spells.rura;

            // å¤©äº•åˆ¤å®šï¼šå±‹å†…ã§ã¯ä½¿ãˆãªã„
            if (currentMap.isOutdoor === false) {
                caster.mp -= spell.mp;
                closeMenu();
                startDialog([
                    `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                    'ã—ã‹ã— å¤©äº•ã« é ­ã‚’ ã¶ã¤ã‘ã¦ã—ã¾ã£ãŸï¼'
                ]);
                return;
            }

            // ã‚¨ãƒªã‚¢åˆ¶é™å¯¾å¿œï¼šåˆ©ç”¨å¯èƒ½ãªæ‹ ç‚¹ã‚’å–å¾—
            const availableLocations = getAvailableRuraLocations();

            // è¨ªå•æ¸ˆã¿æ‹ ç‚¹ãŒãªã„å ´åˆ
            if (availableLocations.length === 0) {
                closeMenu();
                if (currentMap.area === 'area3') {
                    startDialog(['ã“ã®å¤§é™¸ã§ã¯ ã¾ã  ã©ã“ã«ã‚‚ è¡Œã£ãŸã“ã¨ãŒãªã„ï¼']);
                } else {
                    startDialog(['ã¾ã  ã©ã“ã«ã‚‚ è¡Œã£ãŸã“ã¨ãŒãªã„ï¼']);
                }
                return;
            }

            // æ‹ ç‚¹é¸æŠUIã‚’è¡¨ç¤ºï¼ˆè© å”±è€…ã‚’è¨˜æ†¶ï¼‰
            ruraState.active = true;
            ruraState.cursor = 0;
            ruraState.casterIndex = menu.memberCursor;
            closeMenu();
        }

        // ãƒ«ãƒ¼ãƒ©å®Ÿè¡Œï¼ˆæ‹ ç‚¹ã‚’é¸æŠã—ã¦ç§»å‹•ï¼‰
        async function executeRura(locationIndex) {
            const spell = spells.rura;

            // ã‚¨ãƒªã‚¢åˆ¶é™å¯¾å¿œï¼šåˆ©ç”¨å¯èƒ½ãªæ‹ ç‚¹ã‹ã‚‰é¸æŠ
            const availableLocations = getAvailableRuraLocations();
            const location = availableLocations[locationIndex];
            if (!location) return;

            const caster = party[ruraState.casterIndex] || party[0];
            caster.mp -= spell.mp;
            ruraState.active = false;

            // ãƒ«ãƒ¼ãƒ©æ¼”å‡ºï¼ˆç™½ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‰
            await playRuraAnimation();

            // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¦ãƒ¯ãƒ¼ãƒ—
            startDialogWithCallback(
                [`${location.displayName}ã¸ å‘ã‹ã£ã¦ é£›ã³ç«‹ã£ãŸï¼`],
                () => {
                    const mapPath = `maps/${location.mapId}.json`;
                    performWarp(mapPath, location.arrivalX, location.arrivalY);
                }
            );
        }

        // ãƒ«ãƒ¼ãƒ©æ¼”å‡º
        async function playRuraAnimation() {
            return new Promise(resolve => {
                // ç™½ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                spellFlash.active = true;
                spellFlash.color = 'rgba(100, 200, 255, 0.8)';
                spellFlash.alpha = 1.0;

                setTimeout(() => {
                    spellFlash.active = false;
                    resolve();
                }, 500);
            });
        }

        // ãƒªãƒ¬ãƒŸãƒˆã‚’ä½¿ç”¨ï¼ˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³è„±å‡ºï¼‰
        function useRiremito() {
            const caster = party[menu.memberCursor] || party[0];
            const spell = spells.riremito;

            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã¯ä½¿ãˆãªã„
            if (currentMap.isOutdoor === true) {
                closeMenu();
                startDialog([
                    `${caster.name}ã¯ ${spell.name}ã‚’ ã¨ãªãˆãŸï¼`,
                    'ã—ã‹ã— ã“ã“ã§ã¯ æ„å‘³ãŒãªã„ï¼'
                ]);
                return;
            }

            // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å…¥å£æƒ…å ±ãŒãªã„å ´åˆ
            const entrance = getLastEntrance();
            if (!entrance) {
                closeMenu();
                startDialog(['è„±å‡ºå…ˆãŒ è¦‹ã¤ã‹ã‚‰ãªã„ï¼']);
                return;
            }

            caster.mp -= spell.mp;
            closeMenu();

            // ãƒªãƒ¬ãƒŸãƒˆæ¼”å‡ºï¼ˆç™½ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‰
            playRiremitoAnimation().then(() => {
                startDialogWithCallback(
                    [`${caster.name}ã¯ å‘ªæ–‡ã‚’ ã¨ãªãˆã¦ è„±å‡ºã—ãŸï¼`],
                    () => {
                        performWarp(entrance.mapPath, entrance.x, entrance.y);
                    }
                );
            });
        }

        // ãƒªãƒ¬ãƒŸãƒˆæ¼”å‡º
        async function playRiremitoAnimation() {
            return new Promise(resolve => {
                spellFlash.active = true;
                spellFlash.color = 'rgba(200, 200, 255, 0.8)';
                spellFlash.alpha = 1.0;

                setTimeout(() => {
                    spellFlash.active = false;
                    resolve();
                }, 400);
            });
        }

        // ãƒ«ãƒ¼ãƒ©æ‹ ç‚¹é¸æŠUIã®æç”»
        function drawRuraSelection() {
            if (!ruraState.active) return;

            // ã‚¨ãƒªã‚¢åˆ¶é™å¯¾å¿œï¼šåˆ©ç”¨å¯èƒ½ãªæ‹ ç‚¹ã®ã¿è¡¨ç¤º
            const locations = getAvailableRuraLocations();
            if (locations.length === 0) return;

            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºè¨ˆç®—
            const lineHeight = tileSize * 0.5;
            const windowWidth = canvasWidth * 0.6;
            const windowHeight = lineHeight * (locations.length + 2) + 40;
            const windowX = (canvasWidth - windowWidth) / 2;
            const windowY = (canvasHeight - windowHeight) / 2;

            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æç”»
            drawWindow(windowX, windowY, windowWidth, windowHeight);

            // ã‚¿ã‚¤ãƒˆãƒ«
            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('ã©ã“ã¸ ã„ãã¾ã™ã‹ï¼Ÿ', canvasWidth / 2, windowY + 15);

            // åŒºåˆ‡ã‚Šç·š
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(windowX + 20, windowY + 40);
            ctx.lineTo(windowX + windowWidth - 20, windowY + 40);
            ctx.stroke();

            // æ‹ ç‚¹ãƒªã‚¹ãƒˆ
            ctx.textAlign = 'left';
            ctx.font = `${tileSize * 0.35}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            const listStartY = windowY + 55;

            for (let i = 0; i < locations.length; i++) {
                const y = listStartY + i * lineHeight;

                // ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
                if (i === ruraState.cursor) {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('â–¶', windowX + 25, y);
                }

                // æ‹ ç‚¹å
                ctx.fillStyle = i === ruraState.cursor ? '#fff' : 'rgba(255, 255, 255, 0.7)';
                ctx.fillText(locations[i].displayName, windowX + 50, y);
            }

            // æ“ä½œèª¬æ˜
            ctx.font = `${tileSize * 0.25}px 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillText('â†‘â†“:é¸æŠ  Enter:æ±ºå®š  Esc:ã‚­ãƒ£ãƒ³ã‚»ãƒ«', canvasWidth / 2, windowY + windowHeight - 20);
        }

        // ãƒ«ãƒ¼ãƒ©é¸æŠã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelRuraSelection() {
            ruraState.active = false;
        }

        function equipItem(itemId, member = null) {
            const item = items[itemId];
            if (!item) return false;

            // æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒ³ãƒãƒ¼ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯player
            const target = member || player;

            // è£…å‚™å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if (item.equippable && !item.equippable.includes(target.job)) {
                return false; // ã“ã®ã‚¸ãƒ§ãƒ–ã¯è£…å‚™ã§ããªã„
            }

            if (item.type === 'weapon') {
                // ç¾åœ¨ã®æ­¦å™¨ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã™ï¼ˆåˆæœŸè£…å‚™ã§ãªã„å ´åˆï¼‰
                if (target.equipment.weapon && target.equipment.weapon !== 10) {
                    addItem(target.equipment.weapon, 1);
                }
                // æ–°ã—ã„æ­¦å™¨ã‚’è£…å‚™
                target.equipment.weapon = itemId;
                // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
                removeItem(itemId, 1);
            } else if (item.type === 'armor') {
                // ç¾åœ¨ã®é˜²å…·ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã™ï¼ˆåˆæœŸè£…å‚™ã§ãªã„å ´åˆï¼‰
                if (target.equipment.armor && target.equipment.armor !== 20) {
                    addItem(target.equipment.armor, 1);
                }
                // æ–°ã—ã„é˜²å…·ã‚’è£…å‚™
                target.equipment.armor = itemId;
                // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
                removeItem(itemId, 1);
            }
            // è£…å‚™å¤‰æ›´å¾Œã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—
            updateActualStats(target);
            return true;
        }

        // ========================================
        // ãƒãƒƒãƒ—é·ç§»ï¼ˆãƒãƒ«ãƒãƒãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œï¼‰
        // ========================================

        // éåŒæœŸãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆå®Ÿéš›ã®fetchã§JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ï¼‰
        async function loadMapFromDatabase(mapPath) {
            try {
                // å®Ÿéš›ã®JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’fetch
                const response = await fetch(mapPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const mapData = await response.json();
                // console.log(`ãƒãƒƒãƒ—ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ: ${mapPath}`);
                return mapData;
            } catch (error) {
                console.error(`ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ (${mapPath}):`, error);

                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—§å½¢å¼ã®ãƒãƒƒãƒ—IDã«å¤‰æ›ã‚’è©¦ã¿ã‚‹
                const mapIdMatch = mapPath.match(/maps\/(.+)\.json/);
                if (mapIdMatch) {
                    const mapId = mapIdMatch[1].replace('_', '');
                    const normalizedId = mapId === 'maou_room' ? 'maouRoom' : mapId;
                    if (maps[normalizedId]) {
                        console.log(`ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å†…è”µãƒãƒƒãƒ— ${normalizedId} ã‚’ä½¿ç”¨`);
                        return {
                            ...maps[normalizedId],
                            mapId: normalizedId
                        };
                    }
                }

                throw error;
            }
        }

        // ãƒãƒƒãƒ—ãƒ‘ã‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        function isMapPath(target) {
            return target.startsWith('maps/') || target.endsWith('.json');
        }

        // ãƒãƒƒãƒ—ãƒ‘ã‚¹ã‹ã‚‰æ—§å½¢å¼IDã¸ã®å¤‰æ›
        function getMapIdFromPath(mapPath) {
            const match = mapPath.match(/maps\/(.+)\.json/);
            if (match) {
                const id = match[1].replace('_', '');
                return id === 'maou_room' ? 'maouRoom' : id;
            }
            return mapPath;
        }

        // æ—§å½¢å¼IDã‹ã‚‰ãƒãƒƒãƒ—ãƒ‘ã‚¹ã¸ã®å¤‰æ›
        function getMapPathFromId(mapId) {
            if (mapId === 'maouRoom') return 'maps/maou_room.json';
            return `maps/${mapId}.json`;
        }

        function checkWarp() {
            // æ—…ã®æ‰‰ãƒã‚§ãƒƒã‚¯ï¼ˆå…ˆã«ãƒã‚§ãƒƒã‚¯ã€ç‰¹åˆ¥æ¼”å‡ºã‚ã‚Šï¼‰
            if (currentMap.portals) {
                for (const portal of currentMap.portals) {
                    if (player.x === portal.x && player.y === portal.y) {
                        performPortalWarp(portal);
                        return;
                    }
                }
            }

            // ç©´ã‚¿ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯ï¼ˆåº§æ¨™é€£å‹•ãƒ¯ãƒ¼ãƒ—ï¼‰
            const currentTile = currentMap.data[player.y][player.x];
            if (currentTile === TILE.HOLE && currentMap.linkedUnderworld) {
                performHoleWarp(currentMap.linkedUnderworld, player.x, player.y);
                return;
            }

            // é€šå¸¸ãƒ¯ãƒ¼ãƒ—ãƒã‚§ãƒƒã‚¯
            if (!currentMap.warps) return;
            for (const warp of currentMap.warps) {
                if (player.x === warp.x && player.y === warp.y) {
                    // é€šè¡Œæ¡ä»¶ãƒã‚§ãƒƒã‚¯
                    if (warp.requiresFlag && !getStoryFlag(warp.requiresFlag)) {
                        startDialog(['ã“ã®å…ˆã¸ã¯ ã¾ã  è¡Œã‘ãªã„ã‚ˆã†ã ...']);
                        return;
                    }

                    // éšæ®µã‚¿ã‚¤ãƒ—ã®å‡¦ç†ï¼ˆstairType: 'up' | 'down'ï¼‰
                    if (warp.stairType) {
                        performStairWarp(warp);
                    } else {
                        performWarp(warp.targetMap, warp.targetX, warp.targetY);
                    }
                    return;
                }
            }
        }

        // éšæ®µãƒ¯ãƒ¼ãƒ—ï¼ˆéšå±¤ç§»å‹•ç”¨ï¼‰
        async function performStairWarp(stairWarp) {
            if (isTransitioning) return;
            isTransitioning = true;

            // éšæ®µã®æ–¹å‘ã«å¿œã˜ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            const direction = stairWarp.stairType === 'up' ? 'ä¸Š' : 'ä¸‹';

            // çŸ­ã„ãƒ•ã‚§ãƒ¼ãƒ‰æ¼”å‡º
            fadeOverlay.classList.add('active');
            await new Promise(resolve => setTimeout(resolve, 200));

            // é€šå¸¸ã®ãƒ¯ãƒ¼ãƒ—å‡¦ç†ã‚’å®Ÿè¡Œ
            isTransitioning = false;
            await performWarp(stairWarp.targetMap, stairWarp.targetX, stairWarp.targetY);
        }

        // ç©´ã¸ã®è½ä¸‹ãƒ¯ãƒ¼ãƒ—ï¼ˆè½ä¸‹æ¼”å‡ºä»˜ãï¼‰
        async function performHoleWarp(targetMap, x, y) {
            if (isTransitioning) return;
            isTransitioning = true;

            // ç”»é¢ã‚’æš—ãã™ã‚‹æ¼”å‡º
            const duration = 600; // 0.6ç§’
            const startTime = Date.now();

            await new Promise(resolve => {
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // é»’ããƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                    fadeOverlay.style.background = `rgba(0, 0, 0, ${progress})`;
                    fadeOverlay.classList.add('active');

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        resolve();
                    }
                }
                animate();
            });

            // é€šå¸¸ã®ãƒ¯ãƒ¼ãƒ—å‡¦ç†ã‚’å®Ÿè¡Œ
            isTransitioning = false;
            await performWarp(targetMap, x, y);
        }

        // æ—…ã®æ‰‰ãƒ¯ãƒ¼ãƒ—ï¼ˆç‰¹åˆ¥æ¼”å‡ºä»˜ãï¼‰
        async function performPortalWarp(portal) {
            if (isTransitioning) return;

            // é€šè¡Œæ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (portal.requiresFlag && !getStoryFlag(portal.requiresFlag)) {
                startDialog(['ã“ã®æ‰‰ã¯ ã¾ã  é–‹ã‹ãªã„...', 'ç‰¹åˆ¥ãªè¨±å¯ãŒ å¿…è¦ãªã‚ˆã†ã ã€‚']);
                return;
            }

            isTransitioning = true;

            // å°å°ã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œï¼ˆã‚¨ãƒªã‚¢3ã¸ã®ç§»è¡Œï¼‰
            if (portal.sealEvent) {
                await playPortalAnimation();
                await playSealAnimation();

                // ãƒ•ãƒ©ã‚°è¨­å®š
                setStoryFlag('area3Entered', true);
                setStoryFlag('area3SealActivated', true);
                saveGame();

                // é€šå¸¸ã®ãƒ¯ãƒ¼ãƒ—å‡¦ç†ã‚’å®Ÿè¡Œ
                isTransitioning = false;
                await performWarp(portal.targetMap, portal.targetX, portal.targetY);

                // ãƒ¯ãƒ¼ãƒ—å¾Œã«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
                setTimeout(() => {
                    startDialog([
                        'æ‰‰ãŒæ¿€ã—ãè¼ãå§‹ã‚ãŸï¼',
                        'å¤ã®å°å°ãŒç™ºå‹•ã—ãŸ...',
                        'ã‚‚ã†ã“ã®æ‰‰ã¯äºŒåº¦ã¨é–‹ã‹ãªã„...'
                    ]);
                }, 500);
                return;
            }

            // æ¸¦å·»ãï¼‹ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            await playPortalAnimation();

            // é€šå¸¸ã®ãƒ¯ãƒ¼ãƒ—å‡¦ç†ã‚’å®Ÿè¡Œ
            isTransitioning = false;  // performWarpå†…ã§å†è¨­å®šã•ã‚Œã‚‹ã®ã§ä¸€æ—¦è§£é™¤
            await performWarp(portal.targetMap, portal.targetX, portal.targetY);
        }

        // å°å°ç™ºå‹•æ¼”å‡º
        async function playSealAnimation() {
            return new Promise(resolve => {
                const duration = 1500;
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // èµ¤ã„é–ƒå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆè„ˆå‹•ï¼‰
                    const intensity = Math.sin(progress * Math.PI * 4) * 0.6;
                    fadeOverlay.style.background = `rgba(255, 50, 50, ${Math.abs(intensity)})`;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // æœ€å¾Œã«æš—è»¢
                        fadeOverlay.style.background = 'rgba(0, 0, 0, 0.8)';
                        resolve();
                    }
                }
                animate();
            });
        }

        // æ—…ã®æ‰‰æ¼”å‡º
        async function playPortalAnimation() {
            const duration = 800; // 0.8ç§’
            const startTime = Date.now();

            // ç”»é¢ã‚’ç´«ã«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã—ãªãŒã‚‰æ¸¦å·»ã
            return new Promise(resolve => {
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ç´«ã«
                    fadeOverlay.style.background = `rgba(100, 50, 150, ${progress * 0.8})`;
                    fadeOverlay.classList.add('active');

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ç™½ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã§ç· ã‚
                        fadeOverlay.style.background = '#fff';
                        setTimeout(() => {
                            fadeOverlay.style.background = '#000';
                            resolve();
                        }, 100);
                    }
                }
                animate();
            });
        }

        async function performWarp(targetMap, targetX, targetY) {
            if (isTransitioning) return;

            // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šé€²å…¥å‰ã®ãƒãƒƒãƒ—æƒ…å ±ã‚’ä¿å­˜
            const prevMapData = currentMap;
            const prevX = player.x;
            const prevY = player.y;
            const prevMapPath = currentMapPath;

            // æ–°å½¢å¼ï¼ˆmaps/*.jsonï¼‰ã‹æ—§å½¢å¼ï¼ˆmapIdï¼‰ã‹ã‚’åˆ¤å®š
            const isNewFormat = isMapPath(targetMap);
            const targetMapPath = isNewFormat ? targetMap : getMapPathFromId(targetMap);
            const targetMapId = isNewFormat ? getMapIdFromPath(targetMap) : targetMap;

            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿ã®å¤–éƒ¨JSONãƒãƒƒãƒ—ãŒã‚ã‚Œã°å†åˆ©ç”¨ï¼ˆå®ç®±çŠ¶æ…‹ä¿æŒã®ãŸã‚ï¼‰
            if (maps[targetMapId] && maps[targetMapId]._isExternal) {
                performLegacyWarp(targetMapId, targetX, targetY);
                return;
            }

            // æ—§å½¢å¼ï¼ˆå†…è”µãƒãƒƒãƒ—ï¼‰ã‚’ç›´æ¥å‚ç…§ã§ãã‚‹ã‹ç¢ºèª
            if (!isNewFormat && maps[targetMapId]) {
                performLegacyWarp(targetMapId, targetX, targetY);
                return;
            }

            // æ–°å½¢å¼ã®ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            isTransitioning = true;
            mapLoadState.loading = true;
            fadeOverlay.classList.add('active');

            try {
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ã‚’å¾…ã¤
                await new Promise(resolve => setTimeout(resolve, 300));

                // ãƒãƒƒãƒ—ã‚’ãƒ­ãƒ¼ãƒ‰
                const mapData = await loadMapFromDatabase(targetMapPath);

                // å¤–éƒ¨JSONãƒãƒƒãƒ—ã§ã‚ã‚‹ã“ã¨ã‚’ãƒãƒ¼ã‚¯
                mapData._isExternal = true;

                // ãƒãƒƒãƒ—ã‚’mapsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰
                maps[mapData.mapId] = mapData;

                // ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚’æ›´æ–°
                currentMapId = mapData.mapId;
                currentMapPath = targetMapPath;
                currentMap = mapData;
                player.x = targetX;
                player.y = targetY;
                mapNameElement.textContent = currentMap.name;
                updateMapNameColor();

                // BGMåˆ‡ã‚Šæ›¿ãˆ
                initAudio();
                BGM.play(BGM.getBgmTypeForMap(currentMap));

                // ç™ºè¦‹æ¸ˆã¿éš ã—é€šè·¯ã‚’é©ç”¨
                applyOpenedPassages(currentMap);

                // æ°·ãƒ–ãƒ­ãƒƒã‚¯ã®åˆæœŸåŒ–
                initIceBlocks();

                // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å®ç®±ã®é–‹å°çŠ¶æ…‹ã‚’å¾©å…ƒ
                try {
                    const savedData = localStorage.getItem(SAVE_KEY);
                    if (savedData) {
                        const data = JSON.parse(savedData);
                        if (data.chestStates && data.chestStates[currentMapId] && currentMap.chests) {
                            for (const savedChest of data.chestStates[currentMapId]) {
                                const chest = currentMap.chests.find(c => c.id === savedChest.id);
                                if (chest) chest.isOpened = savedChest.isOpened;
                            }
                        }
                    }
                } catch (e) {
                    console.error('å®ç®±çŠ¶æ…‹ã®å¾©å…ƒã«å¤±æ•—:', e);
                }
                updateMapPinVisibility();
                updateFloorDisplay();
                updateCamera();
                saveGame();

                // å®‰å…¨ãªãƒãƒƒãƒ—ï¼ˆè¡—ãƒ»åŸãªã©ï¼‰ã«å…¥ã£ãŸã‚‰æ­©æ•°ãƒªã‚»ãƒƒãƒˆ
                if (currentMap.encounterRate <= 0) {
                    stepsSinceLastBattle = 0;
                }

                // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šæ‹ ç‚¹ã®ç™»éŒ²
                registerVisitedLocation(currentMap);

                // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é€²å…¥æ™‚ã«å…¥å£ã‚’è¨˜æ†¶
                if (currentMap.isOutdoor === false && prevMapData) {
                    recordDungeonEntrance(prevMapData, prevX, prevY, prevMapPath);
                }

                // ç”ºãƒ»åŸã«å…¥ã£ãŸã‚‰ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ç”¨ã«è¨˜éŒ²
                if (currentMap.type === 'town' || currentMap.type === 'castle') {
                    lastTown = {
                        mapPath: targetMapPath,
                        x: targetX,
                        y: targetY,
                        name: currentMap.name
                    };
                }

                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                await new Promise(resolve => setTimeout(resolve, 100));
                fadeOverlay.classList.remove('active');
                await new Promise(resolve => setTimeout(resolve, 300));

            } catch (error) {
                console.error('ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—§å½¢å¼ã‚’è©¦ã™
                if (maps[targetMapId]) {
                    currentMapId = targetMapId;
                    currentMap = maps[targetMapId];
                    player.x = targetX;
                    player.y = targetY;
                    mapNameElement.textContent = currentMap.name;
                    updateMapNameColor();
                    updateMapPinVisibility();
                    updateFloorDisplay();
                    updateCamera();
                }
                fadeOverlay.classList.remove('active');
            } finally {
                mapLoadState.loading = false;
                isTransitioning = false;
            }
        }

        // æ—§å½¢å¼ã®ãƒ¯ãƒ¼ãƒ—å‡¦ç†ï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
        function performLegacyWarp(targetMapId, targetX, targetY) {
            if (isTransitioning || !maps[targetMapId]) return;

            // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šé€²å…¥å‰ã®ãƒãƒƒãƒ—æƒ…å ±ã‚’ä¿å­˜
            const prevMapData = currentMap;
            const prevX = player.x;
            const prevY = player.y;
            const prevMapPath = currentMapPath;

            isTransitioning = true;
            fadeOverlay.classList.add('active');

            setTimeout(() => {
                currentMapId = targetMapId;
                currentMapPath = getMapPathFromId(targetMapId);
                currentMap = maps[targetMapId];
                player.x = targetX;
                player.y = targetY;
                mapNameElement.textContent = currentMap.name;
                updateMapNameColor();

                // BGMåˆ‡ã‚Šæ›¿ãˆ
                initAudio();
                BGM.play(BGM.getBgmTypeForMap(currentMap));

                applyOpenedPassages(currentMap);
                updateMapPinVisibility();
                updateFloorDisplay();
                updateCamera();
                saveGame();

                // å®‰å…¨ãªãƒãƒƒãƒ—ï¼ˆè¡—ãƒ»åŸãªã©ï¼‰ã«å…¥ã£ãŸã‚‰æ­©æ•°ãƒªã‚»ãƒƒãƒˆ
                if (currentMap.encounterRate <= 0) {
                    stepsSinceLastBattle = 0;
                }

                // ãƒ«ãƒ¼ãƒ©ç”¨ï¼šæ‹ ç‚¹ã®ç™»éŒ²
                registerVisitedLocation(currentMap);

                // ãƒªãƒ¬ãƒŸãƒˆç”¨ï¼šãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é€²å…¥æ™‚ã«å…¥å£ã‚’è¨˜æ†¶
                if (currentMap.isOutdoor === false && prevMapData) {
                    recordDungeonEntrance(prevMapData, prevX, prevY, prevMapPath);
                }

                // ç”ºãƒ»åŸã«å…¥ã£ãŸã‚‰ã‚­ãƒ¡ãƒ©ã®ã¤ã°ã•ç”¨ã«è¨˜éŒ²
                if (currentMap.type === 'town' || currentMap.type === 'castle') {
                    lastTown = {
                        mapPath: currentMapPath,
                        x: targetX,
                        y: targetY,
                        name: currentMap.name
                    };
                }

                setTimeout(() => {
                    fadeOverlay.classList.remove('active');
                    setTimeout(() => { isTransitioning = false; }, 300);
                }, 100);
            }, 300);
        }

        // ========================================
        // ç§»å‹•
        // ========================================
        function canMove(x, y) {
            if (x < 0 || x >= currentMap.cols || y < 0 || y >= currentMap.rows) return false;
            const tile = currentMap.data[y][x];
            if (!WALKABLE_TILES.includes(tile)) return false;
            if (isNpcBlocking(x, y) || isChestBlocking(x, y)) return false;
            // æ°·ãƒ–ãƒ­ãƒƒã‚¯åˆ¤å®šï¼ˆæŠ¼ã›ã‚‹å ´åˆã¯ç§»å‹•å¯èƒ½ï¼‰
            if (getIceBlockAt(x, y)) return false;
            return true;
        }

        // æ°·ãƒ–ãƒ­ãƒƒã‚¯åˆ¤å®šï¼ˆåˆæœŸåŒ–å‰ã§ã‚‚å®‰å…¨ã«å‘¼ã¹ã‚‹ã‚ˆã†ã«ï¼‰
        function getIceBlockAt(x, y) {
            if (!currentMap) return null;
            const blocks = pushedIceBlocks[currentMap.id];
            if (!blocks) return null;
            return blocks.find(b => b.x === x && b.y === y);
        }

        // æ°·åºŠãƒ‘ã‚ºãƒ«: æ»‘ã‚Šå§‹ã‚ä½ç½®ã‚’è¨˜éŒ²
        let icePuzzleEntrance = null;

        function movePlayer(dx, dy) {
            if (player.moving || isTransitioning || dialog.active || menu.active || inn.active || shop.active || partyJoinConfirm.active || gameMode === MODE.BATTLE) return;

            if (dy < 0) player.direction = 'up';
            else if (dy > 0) player.direction = 'down';
            else if (dx < 0) player.direction = 'left';
            else if (dx > 0) player.direction = 'right';

            const newX = player.x + dx;
            const newY = player.y + dy;

            // æ°·ãƒ–ãƒ­ãƒƒã‚¯æŠ¼ã—å‡¦ç†
            const iceBlock = getIceBlockAt(newX, newY);
            if (iceBlock) {
                if (pushIceBlock(newX, newY, dx, dy)) {
                    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ¼ã—ãŸã‚‰è‡ªåˆ†ã‚‚ç§»å‹•
                    player.moving = true;
                    player.x = newX;
                    player.y = newY;
                    updateCamera();

                    setTimeout(() => {
                        player.moving = false;
                        // æ°·åºŠæ»‘ã‚Šå‡¦ç†ï¼ˆãƒ–ãƒ­ãƒƒã‚¯æŠ¼ã—å¾Œã‚‚æ»‘ã‚‹ï¼‰
                        handleIceFloorSlide(dx, dy);
                    }, player.moveDelay);
                }
                return;
            }

            if (canMove(newX, newY)) {
                player.moving = true;
                player.x = newX;
                player.y = newY;
                updateCamera();

                setTimeout(() => {
                    checkWarp();
                    if (gameMode === MODE.FIELD) {
                        checkRandomEncounter();
                    }
                    player.moving = false;

                    // æ°·åºŠæ»‘ã‚Šå‡¦ç†
                    handleIceFloorSlide(dx, dy);
                }, player.moveDelay);
            }
        }

        // æ°·åºŠæ»‘ã‚Šå‡¦ç†
        function handleIceFloorSlide(dx, dy) {
            if (player.moving || isTransitioning || dialog.active) return;

            const currentTile = currentMap.data[player.y][player.x];

            // æ°·ã®ç©´ãƒã‚§ãƒƒã‚¯
            if (currentTile === TILE.ICE_HOLE) {
                handleIceHoleFall();
                return;
            }

            // æ°·åºŠã§ãªã‘ã‚Œã°æ»‘ã‚‰ãªã„
            if (currentTile !== TILE.ICE_FLOOR) {
                icePuzzleEntrance = null; // æ°·åºŠã‹ã‚‰å‡ºãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                return;
            }

            // æ°·åºŠã«ä¹—ã£ãŸæœ€åˆã®ä½ç½®ã‚’è¨˜éŒ²
            if (!icePuzzleEntrance) {
                icePuzzleEntrance = { x: player.x - dx, y: player.y - dy, mapId: currentMap.id };
            }

            // æ¬¡ã®ä½ç½®ã‚’ç¢ºèª
            const nextX = player.x + dx;
            const nextY = player.y + dy;

            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            if (nextX < 0 || nextX >= currentMap.cols || nextY < 0 || nextY >= currentMap.rows) {
                return; // å£ã«ã¶ã¤ã‹ã£ã¦æ­¢ã¾ã‚‹
            }

            const nextTile = currentMap.data[nextY][nextX];

            // æ°·ã®å£ãƒ»é€šå¸¸ã®å£ã§æ­¢ã¾ã‚‹
            if (nextTile === TILE.ICE_WALL || !WALKABLE_TILES.includes(nextTile)) {
                return;
            }

            // NPCãŒã„ãŸã‚‰æ­¢ã¾ã‚‹
            if (isNpcBlocking(nextX, nextY)) {
                return;
            }

            // æ»‘ã‚Šç¶šã‘ã‚‹
            player.moving = true;
            player.x = nextX;
            player.y = nextY;
            updateCamera();

            setTimeout(() => {
                player.moving = false;
                handleIceFloorSlide(dx, dy); // å†å¸°çš„ã«æ»‘ã‚Šç¶šã‘ã‚‹
            }, 80); // æ»‘ã‚Šã¯é€šå¸¸ç§»å‹•ã‚ˆã‚Šé€Ÿã„
        }

        // æ°·ã®ç©´ã«è½ã¡ãŸæ™‚ã®å‡¦ç†
        function handleIceHoleFall() {
            player.moving = true;

            startDialogWithCallback(['æ°·ãŒå‰²ã‚Œã¦è½ã¡ã¦ã—ã¾ã£ãŸï¼'], () => {
                if (icePuzzleEntrance && icePuzzleEntrance.mapId === currentMap.id) {
                    // ãƒ‘ã‚ºãƒ«å…¥å£ã«æˆ»ã‚‹
                    player.x = icePuzzleEntrance.x;
                    player.y = icePuzzleEntrance.y;
                } else {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å¯„ã‚Šã®å®‰å…¨ãªå ´æ‰€ï¼ˆãƒ¯ãƒ¼ãƒ—å‡ºå£ãªã©ï¼‰
                    if (currentMap.warps && currentMap.warps.length > 0) {
                        const warp = currentMap.warps.find(w => w.fromX !== undefined);
                        if (warp) {
                            player.x = warp.fromX;
                            player.y = warp.fromY;
                        } else {
                            // fromXãŒãªã„å ´åˆã¯æœ€åˆã®ãƒ¯ãƒ¼ãƒ—ä½ç½®ã‚’ä½¿ç”¨
                            player.x = currentMap.warps[0].x;
                            player.y = currentMap.warps[0].y;
                        }
                    }
                }
                updateCamera();
                player.moving = false;
                icePuzzleEntrance = null;
            });
        }

        // ========================================
        // åœ§åŠ›ã‚¹ã‚¤ãƒƒãƒãƒ»æ°·ãƒ–ãƒ­ãƒƒã‚¯ãƒ‘ã‚ºãƒ«ã‚·ã‚¹ãƒ†ãƒ 
        // ========================================

        // æŠ¼ã•ã‚ŒãŸæ°·ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã‚’è¨˜éŒ² { mapId: [ {x, y}, ... ] }
        const pushedIceBlocks = {};

        // ã‚¹ã‚¤ãƒƒãƒçŠ¶æ…‹ã‚’è¨˜éŒ² { mapId: { switchId: boolean } }
        const switchStates = {};

        // æ°·ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ¼ã™å‡¦ç†
        function pushIceBlock(blockX, blockY, dx, dy) {
            const newX = blockX + dx;
            const newY = blockY + dy;

            // æŠ¼ã™å…ˆãŒæœ‰åŠ¹ã‹ç¢ºèª
            if (newX < 0 || newX >= currentMap.cols || newY < 0 || newY >= currentMap.rows) {
                return false;
            }

            const targetTile = currentMap.data[newY][newX];

            // æŠ¼ã›ãªã„å ´æ‰€ï¼ˆå£ã€æ°·ã®å£ã€ç©´ãªã©ï¼‰
            if (!WALKABLE_TILES.includes(targetTile) || targetTile === TILE.ICE_HOLE) {
                return false;
            }

            // ä»–ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Œã°æŠ¼ã›ãªã„
            if (getIceBlockAt(newX, newY)) {
                return false;
            }

            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç§»å‹•
            if (!pushedIceBlocks[currentMap.id]) {
                pushedIceBlocks[currentMap.id] = [];
            }

            // å…ƒã®ä½ç½®ã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤
            const blocks = pushedIceBlocks[currentMap.id];
            const blockIndex = blocks.findIndex(b => b.x === blockX && b.y === blockY);
            if (blockIndex >= 0) {
                blocks.splice(blockIndex, 1);
            }

            // æ–°ã—ã„ä½ç½®ã«ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ 
            blocks.push({ x: newX, y: newY });

            // ã‚¹ã‚¤ãƒƒãƒãƒã‚§ãƒƒã‚¯
            checkIceSwitches();

            return true;
        }

        // åœ§åŠ›ã‚¹ã‚¤ãƒƒãƒã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
        function checkIceSwitches() {
            if (!currentMap.iceSwitches) return;

            if (!switchStates[currentMap.id]) {
                switchStates[currentMap.id] = {};
            }

            let allPressed = true;
            currentMap.iceSwitches.forEach(sw => {
                const blockOnSwitch = getIceBlockAt(sw.x, sw.y);
                const isPressed = !!blockOnSwitch;
                switchStates[currentMap.id][sw.id] = isPressed;
                if (!isPressed) allPressed = false;
            });

            // å…¨ã‚¹ã‚¤ãƒƒãƒæŠ¼ä¸‹æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆ
            if (allPressed && currentMap.iceSwitches.length > 0 && currentMap.onAllSwitchesPressed) {
                currentMap.onAllSwitchesPressed();
            }
        }

        // ãƒãƒƒãƒ—åˆæœŸåŒ–æ™‚ã«æ°·ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®
        function initIceBlocks() {
            if (!currentMap.iceBlocks) return;

            pushedIceBlocks[currentMap.id] = currentMap.iceBlocks.map(b => ({
                x: b.x,
                y: b.y
            }));
        }

        function getFrontPosition() {
            let fx = player.x, fy = player.y;
            switch (player.direction) {
                case 'up': fy--; break;
                case 'down': fy++; break;
                case 'left': fx--; break;
                case 'right': fx++; break;
            }
            return { x: fx, y: fy };
        }

        function interact() {
            if (menu.active || gameMode === MODE.BATTLE || inn.active || church.active || shop.active || partyJoinConfirm.active) return;
            if (dialog.active) { advanceDialog(); return; }

            const front = getFrontPosition();
            const npc = getNpcAt(front.x, front.y);
            if (npc) {
                if (npc.type === 'inn' || npc.type === 'innkeeper') {
                    openInn(npc.innCost || npc.price);
                } else if (npc.type === 'church' || npc.type === 'priest') {
                    openChurch();
                } else if (npc.type === 'shop' || npc.type === 'shopkeeper') {
                    openShop(npc.shopId || 'default');
                } else if (npc.type === 'maou') {
                    // é­”ç‹æˆ¦é–‹å§‹
                    if (gameCleared) {
                        // æ—¢ã«ã‚¯ãƒªã‚¢æ¸ˆã¿
                        startDialog(['......ã€‚', 'ï¼ˆé­”ç‹ã®å§¿ã¯ã‚‚ã†ãªã„ï¼‰']);
                    } else {
                        startMaouBattle();
                    }
                } else if (npc.type === 'king') {
                    // ç‹æ§˜ã¨ã®ä¼šè©±ï¼ˆæ¡ä»¶åˆ†å²ï¼‰
                    handleKingDialog(npc);
                } else if (npc.type === 'boss' && npc.bossId) {
                    // ãƒœã‚¹NPCæˆ¦
                    handleBossNpc(npc);
                } else if (npc.type === 'quest_giver') {
                    // ã‚¯ã‚¨ã‚¹ãƒˆNPC
                    handleQuestGiver(npc);
                } else if (npc.type === 'party_join') {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥NPC
                    handlePartyJoinNpc(npc);
                } else if (npc.type === 'party_join_seren') {
                    // ã‚»ãƒ¬ãƒ³åŠ å…¥NPCï¼ˆæ®µéšçš„ãªä¼šè©±ãƒ•ãƒ­ãƒ¼ï¼‰
                    handleSerenJoinNpc(npc);
                } else if (npc.type === 'party_join_glacio') {
                    // ã‚°ãƒ©ã‚·ã‚ªåŠ å…¥NPC
                    handleGlacioJoinNpc(npc);
                } else if (npc.type === 'portal_guard') {
                    // æ—…ã®æ‰‰ã®ç•ªå…µ - NPCã”ã¨ã«ç•°ãªã‚‹ãƒ•ãƒ©ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
                    let isUnlocked = false;
                    if (npc.id === 'desert_portal_guard') {
                        isUnlocked = getStoryFlag('desertPortalUnlocked');
                    } else {
                        isUnlocked = getStoryFlag('portalRoomUnlocked');
                    }

                    if (isUnlocked && npc.clearedMessages) {
                        startDialog(npc.clearedMessages);
                    } else {
                        startDialog(npc.messages);
                    }
                } else if (npc.type === 'healer') {
                    // ãƒ’ãƒ¼ãƒ©ãƒ¼NPC - HP/MPå…¨å›å¾©
                    handleHealerNpc(npc);
                } else if (npc.type === 'quest_ancient_spell') {
                    // å¤ä»£å‘ªæ–‡ã‚¯ã‚¨ã‚¹ãƒˆNPC
                    handleAncientSpellQuest(npc);
                } else {
                    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å¾Œã¯NPCã®ã‚»ãƒªãƒ•ãŒå¤‰ã‚ã‚‹
                    if (gameCleared && npc.clearedMessages) {
                        startDialog(npc.clearedMessages);
                    } else {
                        startDialog(npc.messages);
                    }
                }
                return;
            }

            const chest = getChestAt(front.x, front.y);
            if (chest) { openChest(chest); return; }

            // æ¥”ã®ç¥­å£‡ãƒã‚§ãƒƒã‚¯
            const frontTile = currentMap.data[front.y]?.[front.x];
            if (frontTile === TILE.WEDGE_ALTAR) {
                handleWedgeAltar(front.x, front.y);
                return;
            }

            // éš ã—å£ã®ãƒã‚§ãƒƒã‚¯
            checkHiddenWall(front.x, front.y);
        }

        // æ¥”ã®ç¥­å£‡ã¨ã®ç›¸äº’ä½œç”¨
        function handleWedgeAltar(x, y) {
            // åº§æ¨™ã‹ã‚‰æ¥”ã®ç¨®é¡ã‚’åˆ¤å®š
            let wedgeId = null;
            let dungeonMap = null;
            if (y < 50 && Math.abs(x - 50) < 10) {
                wedgeId = 'wedge_north';
                dungeonMap = 'maps/wedge_dungeon_north_b1.json';
            } else if (y > 50 && Math.abs(x - 50) < 10) {
                wedgeId = 'wedge_south';
                dungeonMap = 'maps/wedge_dungeon_south_b1.json';
            } else if (x < 50 && Math.abs(y - 50) < 10) {
                wedgeId = 'wedge_west';
                dungeonMap = 'maps/wedge_dungeon_west_b1.json';
            } else if (x > 50 && Math.abs(y - 50) < 10) {
                wedgeId = 'wedge_east';
                dungeonMap = 'maps/wedge_dungeon_east_b1.json';
            }

            if (!wedgeId) {
                startDialog(['å¤ä»£ã®ç¥­å£‡ã ...']);
                return;
            }

            if (gameProgress.quests.wedges[wedgeId]) {
                startDialog(['ã“ã“ã«ã¯æ—¢ã«æ¥”ãŒãªã„...', 'å®ˆè­·è€…ã‚’å€’ã—ãŸè·¡ãŒæ®‹ã£ã¦ã„ã‚‹ã€‚']);
            } else {
                // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã¸ã®ãƒ¯ãƒ¼ãƒ—ç¢ºèª
                startDialogWithCallback([
                    'å¤ä»£ã®ç¥­å£‡ã ...',
                    'åœ°ä¸‹ã¸ç¶šãéšæ®µãŒã‚ã‚‹ã€‚',
                    'é™ã‚Šã¾ã™ã‹ï¼Ÿ'
                ], () => {
                    // ã¯ã„/ã„ã„ãˆé¸æŠã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¸
                    // ãƒ¯ãƒ¼ãƒ—å‡¦ç†ã¯æ—¢å­˜ã®warpsã§è¡Œã‚ã‚Œã‚‹ãŸã‚ã€ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®ã¿
                    loadMap(dungeonMap, 12, 23);
                });
            }
        }

        // æ¥”ã‚’åé›†ã™ã‚‹
        // skipDialog: trueã®å ´åˆã¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒœã‚¹æˆ¦å¾Œã®å‘¼ã³å‡ºã—ç”¨ï¼‰
        function collectWedge(wedgeId, skipDialog = false) {
            // wedgeId: 'wedge_north', 'wedge_east', 'wedge_south', 'wedge_west'
            if (gameProgress.quests.wedges[wedgeId]) return; // æ—¢ã«å–å¾—æ¸ˆã¿

            gameProgress.quests.wedges[wedgeId] = true;
            setBossDefeated('wedgeGuardian_' + wedgeId.replace('wedge_', ''), true);

            const wedgeNames = {
                wedge_north: 'åŒ—ã®æ¥”',
                wedge_east: 'æ±ã®æ¥”',
                wedge_south: 'å—ã®æ¥”',
                wedge_west: 'è¥¿ã®æ¥”'
            };

            // æ¥”ã«åˆ»ã¾ã‚ŒãŸè¨˜æ†¶ï¼ˆã‚¹ãƒˆãƒ¼ãƒªãƒ¼æ¼”å‡ºï¼‰
            const wedgeMemories = {
                wedge_north: [
                    `${wedgeNames[wedgeId]}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`,
                    'æ¥”ã«è§¦ã‚ŒãŸç¬é–“ã€é ­ã«æ˜ åƒãŒæµã‚Œè¾¼ã‚€...',
                    'â€•â€•100å¹´å‰ã®è¨˜æ†¶â€•â€•',
                    'æ˜Ÿèª­ã¿ã®é•·è€ï¼šã€Œæ˜ŸãŒ...é»’ãæŸ“ã¾ã£ã¦ã„ã...ã€',
                    'é•·è€ï¼šã€Œã‚ã¨7æ—¥ã§ã€å½±ãŒç›®è¦šã‚ã‚‹...ã€',
                    'é•·è€ï¼šã€Œæ€¥ã’ï¼ å°å°ã®æº–å‚™ã‚’ï¼ã€',
                    '...è¨˜æ†¶ãŒé€”åˆ‡ã‚ŒãŸã€‚'
                ],
                wedge_east: [
                    `${wedgeNames[wedgeId]}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`,
                    'æ¥”ã‹ã‚‰åˆ¥ã®è¨˜æ†¶ãŒæµã‚Œè¾¼ã‚€...',
                    'â€•â€•è¨˜æ†¶â€•â€•',
                    'æ˜Ÿèª­ã¿ã®å¥³æ€§ï¼šã€Œå°å°ã¯å®Œç’§ã˜ã‚ƒãªã„...ã€',
                    'å¥³æ€§ï¼šã€Œã„ã¤ã‹å¿…ãšã€èª°ã‹ãŒçœŸå®Ÿã«è¾¿ã‚Šç€ãã€‚ã€',
                    'å¥³æ€§ï¼šã€Œãã®æ™‚ã€å½±ã®...æœ¬å½“ã®å§¿ã‚’çŸ¥ã‚‹ã§ã—ã‚‡ã†ã€‚ã€',
                    '...æœ¬å½“ã®å§¿ã¨ã¯ï¼Ÿ'
                ],
                wedge_south: [
                    `${wedgeNames[wedgeId]}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`,
                    'ã•ã‚‰ãªã‚‹è¨˜æ†¶ãŒè˜‡ã‚‹...',
                    'â€•â€•è¨˜æ†¶â€•â€•',
                    'æ˜Ÿèª­ã¿ã®æˆ¦å£«ï¼šã€Œå½±ã¯...å…ƒã€…ã“ã®ä¸–ç•Œã®å®ˆè­·è€…ã ã£ãŸã€‚ã€',
                    'æˆ¦å£«ï¼šã€Œã ãŒä½•ã‹ãŒæ­ªã¿ã€æš´èµ°ã—ã¦ã—ã¾ã£ãŸã€‚ã€',
                    'æˆ¦å£«ï¼šã€Œç ´å£Šã™ã‚‹ã®ã§ã¯ãªãã€æ•‘ã†æ–¹æ³•ãŒã‚ã‚‹ã¯ãš...ã€',
                    '...å®ˆè­·è€…...ï¼Ÿ æ•‘ã†æ–¹æ³•...ï¼Ÿ'
                ],
                wedge_west: [
                    `${wedgeNames[wedgeId]}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`,
                    'æœ€å¾Œã®è¨˜æ†¶ãŒæµã‚Œè¾¼ã‚€...',
                    'â€•â€•æœ€å¾Œã®è¨˜æ†¶â€•â€•',
                    'æ˜Ÿèª­ã¿ã®å¤§è³¢è€…ï¼šã€Œå¾Œä¸–ã®å‹‡è€…ã‚ˆã€èã„ã¦ãã‚Œã€‚ã€',
                    'è³¢è€…ï¼šã€Œå½±ã®æ ¸ã«ã¯ã€ç´”ç²‹ãªå…‰ãŒã‚ã‚‹ã€‚ã€',
                    'è³¢è€…ï¼šã€Œãã®å…‰ã‚’è§£æ”¾ã§ãã‚Œã°ã€å½±ã¯æœ¬æ¥ã®å§¿ã«æˆ»ã‚‹ã€‚ã€',
                    'è³¢è€…ï¼šã€Œæˆ‘ã‚‰ã«ã¯ãã®åŠ›ãŒãªã‹ã£ãŸ...ã€',
                    'è³¢è€…ï¼šã€Œã ãŒæœªæ¥ã®å‹‡è€…ãªã‚‰...ãã£ã¨ã€‚ã€',
                    '...ã“ã‚ŒãŒã€ç¥–å…ˆã®éºå¿—...'
                ]
            };

            // ã‚»ãƒ¬ãƒ³ã®åŠ å…¥æ¡ä»¶ã‚’æ›´æ–°ï¼ˆæ¥”1ã¤å–å¾—ã§stage3é”æˆï¼‰
            const collectedCount = Object.values(gameProgress.quests.wedges)
                .filter((v, i) => i < 4 && v).length;
            if (collectedCount >= 1 && !gameProgress.quests.serenJoin.stage3_completed) {
                gameProgress.quests.serenJoin.stage3_completed = true;
            }

            // ãƒœã‚¹æˆ¦å¾Œã®å‘¼ã³å‡ºã—ã®å ´åˆã¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ã‚¹ã‚­ãƒƒãƒ—
            if (skipDialog) {
                checkAllWedgesCollected();
                saveGame();
                return;
            }

            startDialogWithCallback(wedgeMemories[wedgeId] || [
                `${wedgeNames[wedgeId]}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`,
                'å¤ä»£ã®åŠ›ã‚’æ„Ÿã˜ã‚‹...'
            ], () => {
                checkAllWedgesCollected();
                saveGame();
            });
        }

        // å…¨ã¦ã®æ¥”ãŒæƒã£ãŸã‹ãƒã‚§ãƒƒã‚¯
        function checkAllWedgesCollected() {
            const w = gameProgress.quests.wedges;
            if (w.wedge_north && w.wedge_east && w.wedge_south && w.wedge_west) {
                if (!w.allCollected) {
                    w.allCollected = true;
                    gameProgress.storyFlags.ancientCastleUnlocked = true;
                    // æ¼”å‡ºãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    startDialog([
                        '4ã¤ã®æ¥”ãŒæƒã£ãŸï¼',
                        'å¤ã®å°å°ãŒè§£ã‹ã‚Œã‚‹éŸ³ãŒèã“ãˆã‚‹...',
                        'å¤åŸã®æœ€ä¸Šéšã¸ã®é“ãŒé–‹ã‹ã‚ŒãŸï¼'
                    ]);
                    saveGame();
                }
                return true;
            }
            return false;
        }

        // éš ã—å£ã‚’èª¿ã¹ã‚‹
        function checkHiddenWall(x, y) {
            if (x < 0 || y < 0 || y >= currentMap.rows || x >= currentMap.cols) return;

            const tile = currentMap.data[y][x];
            if (tile === TILE.HIDDEN_WALL) {
                // éš ã—é€šè·¯ã‚’ç™ºè¦‹ï¼
                revealHiddenPassage(x, y);
            }
        }

        // éš ã—é€šè·¯ã‚’é–‹ã
        function revealHiddenPassage(x, y) {
            // ã‚¿ã‚¤ãƒ«ã‚’é€šè·¯ã«å¤‰æ›´
            currentMap.data[y][x] = TILE.FLOOR;

            // é€²è¡ŒçŠ¶æ³ã«è¨˜éŒ²
            openPassage(currentMapId, x, y);

            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            flashScreen('#ffffff', 200);

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
            startDialogWithCallback(
                ['ãªã‚“ã¨ï¼', 'ã‹ãã—ã¤ã†ã‚ã‚’ ã¿ã¤ã‘ãŸï¼'],
                () => {
                    saveGame();
                }
            );
        }

        // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
        function flashScreen(color, duration) {
            fadeOverlay.style.backgroundColor = color;
            fadeOverlay.classList.add('active');
            setTimeout(() => {
                fadeOverlay.classList.remove('active');
                fadeOverlay.style.backgroundColor = '';
            }, duration);
        }

        // ãƒ’ãƒ¼ãƒ©ãƒ¼NPCå‡¦ç†ï¼ˆHP/MPå…¨å›å¾©ï¼‰
        function handleHealerNpc(npc) {
            // æœ€åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            const messages = npc.messages || ['ç™’ã—ã®åŠ›ã‚’æˆã‘ã¾ã—ã‚‡ã†ã€‚'];
            startDialogWithCallback(messages, () => {
                // å›å¾©æ¼”å‡º
                spellFlash.active = true;
                spellFlash.color = 'rgba(100, 255, 150, 0.6)';
                spellFlash.alpha = 1.0;

                setTimeout(() => {
                    spellFlash.active = false;

                    // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®HP/MPã‚’å…¨å›å¾©ï¼ˆå®¿å±‹ã¨åŒã˜å‡¦ç†ï¼‰
                    restoreAll();

                    // å›å¾©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    SE.inn(); // å›å¾©SE
                    const healMessages = npc.healMessages || ['è–ãªã‚‹å…‰ã‚ˆ...'];
                    const resultMessages = [...healMessages, 'ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®HP/MPãŒ å›å¾©ã—ãŸï¼'];
                    startDialog(resultMessages);

                    saveGame();
                }, 400);
            });
        }

        // å¤ä»£å‘ªæ–‡ã‚¯ã‚¨ã‚¹ãƒˆNPCå‡¦ç†
        function handleAncientSpellQuest(npc) {
            // æ—¢ã«å‘ªæ–‡ã‚’æˆã‹ã£ãŸ
            if (getStoryFlag('ancientSpellReceived')) {
                startDialog(npc.alreadyRewarded || ['ã‚‚ã†å‘ªæ–‡ã¯æˆã‘ãŸã¯ãšã˜ã‚ƒã€‚']);
                return;
            }

            // é—‡ã®å®ˆè­·è€…ã‚’æ’ƒç ´ã—ã¦ã„ãªã„
            if (!getStoryFlag('shadowGuardianDefeated')) {
                startDialog(npc.questNotComplete || npc.messages);
                return;
            }

            // æ¡ä»¶é”æˆ - å‘ªæ–‡ã‚’æˆã‘ã‚‹
            startDialogWithCallback(npc.questComplete || ['å¤ä»£å‘ªæ–‡ã‚’æˆã‘ã‚ˆã†ã€‚'], () => {
                // å‘ªæ–‡ç¿’å¾—æ¼”å‡º
                spellFlash.active = true;
                spellFlash.color = 'rgba(255, 255, 255, 1.0)';
                spellFlash.alpha = 1.0;

                setTimeout(() => {
                    spellFlash.active = false;

                    // ã‚¶ã‚ªãƒªã‚¯ã‚’ç¿’å¾—
                    if (!player.spells.includes('zaoriku')) {
                        player.spells.push('zaoriku');
                    }

                    // ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                    setStoryFlag('ancientSpellReceived', true);

                    startDialog([
                        `${player.name}ã¯ ã‚¶ã‚ªãƒªã‚¯ã‚’ è¦šãˆãŸï¼`,
                        'ï¼ˆç¢ºå®Ÿã« ä»²é–“ã‚’è˜‡ç”Ÿã•ã›ã‚‹ ç©¶æ¥µã®å¾©æ´»å‘ªæ–‡ï¼‰'
                    ]);

                    saveGame();
                }, 600);
            });
        }

        // ç‹æ§˜ã¨ã®ä¼šè©±å‡¦ç†ï¼ˆæ¡ä»¶åˆ†å²ï¼‰
        function handleKingDialog(npc) {
            // ç ‚æ¼ ã®ç‹ã®å ´åˆã¯å°‚ç”¨å‡¦ç†
            if (npc.id === 'desert_king') {
                if (isBossDefeated('desertGuardian') && npc.clearedMessages) {
                    startDialog(npc.clearedMessages);
                } else {
                    startDialog(npc.messages);
                }
                return;
            }

            // é­”ç‹è¨ä¼æ¸ˆã¿
            if (gameCleared && npc.clearedMessages) {
                startDialog(npc.clearedMessages);
                return;
            }

            // ä¸­ãƒœã‚¹æ’ƒç ´å¾Œã€ã¾ã å ±å‘Šã—ã¦ã„ãªã„å ´åˆ
            if (isBossDefeated('midBoss') && !getStoryFlag('reportedMidBossDefeat')) {
                startDialogWithCallback([
                    'ãŠãŠï¼å‹‡è€…ã‚ˆï¼',
                    'ãªã‚“ã¨ï¼æ´çªŸã®ç•ªäººã‚’å€’ã—ãŸã¨ã„ã†ã®ã‹ï¼',
                    'ã‚ˆããã‚„ã£ã¦ãã‚ŒãŸï¼',
                    'ã“ã‚Œã§æ—…ã®æ‰‰ã®éƒ¨å±‹ã¸è¡Œã‘ã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ã€‚',
                    'åŸã®åŒ—å´ã«ã‚ã‚‹éƒ¨å±‹ã˜ã‚ƒã€‚',
                    'æ—…ã®æ‰‰ã‚’é€šã‚Œã°ã€æ–°ãŸãªå¤§é™¸ã¸è¡Œã‘ã‚‹ã€‚',
                    'ã•ã‚‰ãªã‚‹å†’é™ºãŒå¾…ã£ã¦ãŠã‚‹ãï¼'
                ], () => {
                    setStoryFlag('reportedMidBossDefeat', true);
                    setStoryFlag('portalRoomUnlocked', true);
                    saveGame();
                });
                return;
            }

            // æ—…ã®æ‰‰ãŒé–‹æ”¾æ¸ˆã¿
            if (getStoryFlag('portalRoomUnlocked')) {
                startDialog([
                    'ãŠãŠã€å‹‡è€…ã‚ˆï¼',
                    'æ—…ã®æ‰‰ã®éƒ¨å±‹ã¯åŸã®åŒ—å´ã˜ã‚ƒã€‚',
                    'æ–°ãŸãªå¤§é™¸ã§å¼·æ•µãŒå¾…ã£ã¦ãŠã‚‹ãã€‚',
                    'æ°—ã‚’ã¤ã‘ã¦è¡Œãã®ã˜ã‚ƒï¼'
                ]);
                return;
            }

            // é€šå¸¸ã®ä¼šè©±
            startDialog(npc.messages);
        }

        // ãƒœã‚¹NPCæˆ¦ã®å‡¦ç†
        function handleBossNpc(npc) {
            const bossId = npc.bossId;

            // æ—¢ã«ãƒœã‚¹ã‚’å€’ã—ã¦ã„ã‚‹å ´åˆ
            if (isBossDefeated(bossId)) {
                if (npc.defeatedMessages) {
                    startDialog(npc.defeatedMessages);
                } else {
                    startDialog(['......ã€‚', 'ï¼ˆã‚‚ã†æˆ¦ã†ç›¸æ‰‹ã¯ã„ãªã„ï¼‰']);
                }
                return;
            }

            // ç‰¹å®šã®ãƒ•ãƒ©ã‚°ãŒå¿…è¦ãªãƒœã‚¹ï¼ˆæ¥”ãŒæƒã£ã¦ã„ãªã„å ´åˆãªã©ï¼‰
            if (npc.requiresFlag && !getStoryFlag(npc.requiresFlag)) {
                startDialog([
                    '......ã€‚',
                    'ï¼ˆã¾ã æˆ¦ãˆã‚‹çŠ¶æ…‹ã§ã¯ãªã„ã‚ˆã†ã ï¼‰',
                    'ï¼ˆå¿…è¦ãªã‚‚ã®ã‚’å…¨ã¦é›†ã‚ã¦ã‹ã‚‰æ¥ã‚‹ã¹ãã ï¼‰'
                ]);
                return;
            }

            // ç ‚æ¼ ã®å®ˆè­·è€…ã¯3ã¤ã®ã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†ãŒå¿…è¦
            if (npc.requiresAllQuests && !areAllDesertQuestsCompleted()) {
                startDialog([
                    'æˆ‘ã¯ç ‚æ¼ ã®å®ˆè­·è€…...',
                    'ä¸‰ã¤ã®è©¦ç·´ã‚’ä¹—ã‚Šè¶ŠãˆãŸè€…ã ã‘ãŒ',
                    'æˆ‘ã«æŒ‘ã‚€è³‡æ ¼ãŒã‚ã‚‹ã€‚',
                    'æ¸…ã‚‰ã‹ãªæ°´ã€é€šè¡Œæ‰‹å½¢ã€ç‹å®¶ã®ç´‹ç« ...',
                    'å…¨ã¦ã‚’é›†ã‚ã¦å‡ºç›´ã™ãŒã„ã„ã€‚'
                ]);
                return;
            }

            // ãƒœã‚¹æˆ¦å‰ã®ä¼šè©±â†’æˆ¦é—˜é–‹å§‹
            const bossMessages = (npc.messages && npc.messages.length > 0)
                ? npc.messages
                : ['......ã€‚'];
            startDialogWithCallback(bossMessages, () => {
                startBossBattle(bossId);
            });
        }

        // ã‚¯ã‚¨ã‚¹ãƒˆNPCå‡¦ç†ï¼ˆæ‘é•·ãªã©ï¼‰
        function handleQuestGiver(npc) {
            const questId = npc.questId;

            if (!questId) {
                startDialog(npc.messages);
                return;
            }

            // æ°´ä¸è¶³ã‚¯ã‚¨ã‚¹ãƒˆï¼ˆã‚ªã‚¢ã‚·ã‚¹ã®æ‘é•·ï¼‰
            if (questId === 'waterShortage') {
                handleWaterShortageQuest(npc);
                return;
            }

            // å¤ªé™½ã®ç‚ã‚¯ã‚¨ã‚¹ãƒˆï¼ˆæ°·ã®ç¥æ®¿ï¼‰
            if (questId === 'sunFlame') {
                handleSunFlameQuest(npc);
                return;
            }

            // é€šè¡Œæ‰‹å½¢ã‚¯ã‚¨ã‚¹ãƒˆé–¢é€£ã¯ç›—è³Šãƒœã‚¹æ’ƒç ´ã§è‡ªå‹•å®Œäº†
            // ç‹å®¶ã®ç´‹ç« ã‚¯ã‚¨ã‚¹ãƒˆé–¢é€£ã¯ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ãƒœã‚¹æ’ƒç ´ã§è‡ªå‹•å®Œäº†

            startDialog(npc.messages);
        }

        // æ°´ä¸è¶³ã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†
        function handleWaterShortageQuest(npc) {
            // ã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†æ¸ˆã¿
            if (isQuestCompleted('waterShortage')) {
                startDialog(npc.completedMessages || [
                    'ãŠã‹ã’ã§æ‘ã«æ°´ãŒæˆ»ã£ãŸã€‚',
                    'ã‚ã‚ŠãŒã¨ã†ã€å‹‡è€…æ§˜ï¼'
                ]);
                return;
            }

            // æ¸…ã‚‰ã‹ãªæ°´ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ
            if (hasItem(30)) {
                startDialogWithCallback([
                    'ãŠãŠï¼ãã‚Œã¯æ¸…ã‚‰ã‹ãªæ°´ï¼',
                    'ã“ã‚Œã§æ‘ã‚’æ•‘ãˆã‚‹ï¼',
                    'ã‚ã‚ŠãŒã¨ã†ã€å‹‡è€…æ§˜ï¼',
                    'ã“ã®æ©ã¯å¿˜ã‚Œãªã„ï¼'
                ], () => {
                    removeItem(30);
                    setQuestFlag('waterShortage', 'completed', true);
                    // å ±é…¬
                    player.gold += 500;
                    player.exp += 200;
                    showMessage('500ã‚´ãƒ¼ãƒ«ãƒ‰ã¨200EXPã‚’ç²å¾—ï¼');
                    // å…¨ã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†æ™‚ã«å¤ªé™½ã®åŸå¡ã‚’é–‹æ”¾
                    areAllDesertQuestsCompleted();
                    saveGame();
                });
                return;
            }

            // ãƒœã‚¹æ’ƒç ´å¾Œã ãŒæ°´ã‚’æŒã£ã¦ã„ãªã„
            if (getQuestFlag('waterShortage', 'bossDefeated')) {
                startDialog([
                    'æµç ‚ã®æ´çªŸã®å¥¥ã«æ¸…ã‚‰ã‹ãªæ°´ãŒã‚ã‚‹ã¨ã„ã†ã€‚',
                    'ãƒœã‚¹ã¯å€’ã—ãŸã®ã‹ï¼Ÿ',
                    'æ°´ã‚’æŒã£ã¦ãã¦ãã‚Œï¼'
                ]);
                return;
            }

            // ã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹å‰ã¾ãŸã¯é€²è¡Œä¸­
            if (!getQuestFlag('waterShortage', 'started')) {
                startDialogWithCallback(npc.messages, () => {
                    setQuestFlag('waterShortage', 'started', true);
                    saveGame();
                });
            } else {
                startDialog(npc.messages);
            }
        }

        // å¤ªé™½ã®ç‚ã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†
        function handleSunFlameQuest(npc) {
            // æ—¢ã«å…¥æ‰‹æ¸ˆã¿
            if (getStoryFlag('sunFlameObtained')) {
                startDialog(npc.clearedMessages || [
                    'æ±ã¯æ—¢ã«å¤ªé™½ã®ç‚ã‚’æŒã£ã¦ã„ã‚‹ã€‚',
                    'è¡Œã‘ã€å¥³ç‹ã‚’æ•‘ã†ã®ã ã€‚'
                ]);
                return;
            }

            // å¤ªé™½ã®ç‚ã‚’æˆã‘ã‚‹
            startDialogWithCallback([
                'æ±ã€è©¦ç·´ã‚’ä¹—ã‚Šè¶Šãˆã—è€…ã‚ˆ...',
                'ã“ã®åœ°ã®æ°‘ã‚’æ•‘ã†ãŸã‚ã€å¤ªé™½ã®ç‚ã‚’æˆã‘ã‚ˆã†ã€‚',
                'ã“ã®ç‚ã¯ã€ã„ã‹ãªã‚‹æ°·ã‚’ã‚‚æº¶ã‹ã™åŠ›ã‚’æŒã¤ã€‚',
                'æ°·ã®åŸã¸å‘ã‹ã„ã€å¥³ç‹ã‚’æ•‘ã†ã®ã ã€‚'
            ], () => {
                addItem(95);  // å¤ªé™½ã®ç‚
                setStoryFlag('sunFlameObtained', true);
                startDialogWithCallback([
                    'å¤ªé™½ã®ç‚ ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼',
                    'ï¼ˆæ°·ã®åŸã®é–€ãŒé–‹ã‘ã‚‹ã‚ˆã†ã«ãªã£ãŸï¼‰'
                ], () => {
                    saveGame();
                });
            });
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥ç¢ºèªçŠ¶æ…‹
        let partyJoinConfirm = {
            active: false,
            npcId: null,
            selectedIndex: 0  // 0: ã¯ã„, 1: ã„ã„ãˆ
        };

        // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥NPCå‡¦ç†
        function handlePartyJoinNpc(npc) {
            // æ—¢ã«ä»²é–“ã«ãªã£ã¦ã„ã‚‹å ´åˆ
            if (gameProgress.storyFlags.mageJoined && npc.id === 'oasis_mage') {
                startDialog(npc.alreadyJoinedMessages || ['ä¸€ç·’ã«å†’é™ºã§ãã¦å¬‰ã—ã„ã§ã™ï¼']);
                return;
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ãŒæº€å“¡ã®å ´åˆ
            if (party.length >= MAX_PARTY_SIZE) {
                startDialog(['ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ãŒã„ã£ã±ã„ã ...ï¼‰']);
                return;
            }

            // åŠ å…¥æ¡ä»¶ãƒã‚§ãƒƒã‚¯
            let conditionMet = false;
            if (npc.joinCondition === 'waterShortageCompleted') {
                conditionMet = isQuestCompleted('waterShortage');
            }
            // ä»–ã®æ¡ä»¶ã‚‚è¿½åŠ å¯èƒ½

            if (!conditionMet) {
                startDialog(npc.conditionNotMetMessages || npc.messages);
                return;
            }

            // åŠ å…¥ã‚ªãƒ•ã‚¡ãƒ¼ã‚’è¡¨ç¤ºã—ã¦ç¢ºèª
            startDialogWithCallback(npc.joinOfferMessages, () => {
                partyJoinConfirm.active = true;
                partyJoinConfirm.npcId = npc.id;
                partyJoinConfirm.selectedIndex = 0;
            });
        }

        // ã‚»ãƒ¬ãƒ³åŠ å…¥NPCå‡¦ç†ï¼ˆæ®µéšçš„ãªä¼šè©±ãƒ•ãƒ­ãƒ¼ï¼‰
        function handleSerenJoinNpc(npc) {
            // æ—¢ã«ä»²é–“ã«ãªã£ã¦ã„ã‚‹å ´åˆ
            if (gameProgress.storyFlags.serenJoined) {
                startDialog(npc.alreadyJoinedMessages || ['ã¾ãŸä¼šãˆã¦å¬‰ã—ã„ã§ã™ã­ã€‚']);
                return;
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ãŒæº€å“¡ã®å ´åˆ
            if (party.length >= MAX_PARTY_SIZE) {
                startDialog(['ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ãŒã„ã£ã±ã„ã ...ï¼‰']);
                return;
            }

            // æ®µéšçš„ãªä¼šè©±ãƒ•ãƒ­ãƒ¼
            if (!gameProgress.quests.serenJoin.stage1_met) {
                // åˆå›é­é‡ï¼šç´¹ä»‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                startDialogWithCallback(npc.stage1_messages || npc.messages, () => {
                    gameProgress.quests.serenJoin.stage1_met = true;
                    saveGame();
                });
            } else if (!gameProgress.quests.serenJoin.stage2_helped) {
                // 2å›ç›®ï¼šã‚¯ã‚¨ã‚¹ãƒˆèª¬æ˜
                startDialogWithCallback(npc.stage2_messages || npc.messages, () => {
                    gameProgress.quests.serenJoin.stage2_helped = true;
                    saveGame();
                });
            } else if (gameProgress.quests.serenJoin.stage3_completed) {
                // æ¡ä»¶é”æˆå¾Œï¼šåŠ å…¥ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
                startDialogWithCallback(npc.joinOfferMessages || npc.messages, () => {
                    partyJoinConfirm.active = true;
                    partyJoinConfirm.npcId = npc.id;
                    partyJoinConfirm.selectedIndex = 0;
                });
            } else {
                // æ¡ä»¶æœªé”æˆï¼šå¾…æ©Ÿãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                startDialog(npc.waitingMessages || npc.messages);
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥å®Ÿè¡Œ
        function executePartyJoin(npcId) {
            const npc = getNpcById(npcId);
            if (!npc) return;

            if (npcId === 'oasis_mage') {
                // ãƒãƒªã‚¢ï¼ˆé­”æ³•ä½¿ã„ï¼‰ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã«è¿½åŠ 
                const mage = createPartyMember({
                    id: 'mage_maria',
                    name: 'ãƒãƒªã‚¢',
                    job: 'mage',
                    sprite: 'ğŸ§™',
                    hp: 35,
                    maxHp: 35,
                    mp: 50,
                    maxMp: 50,
                    baseAtk: 8,
                    baseDef: 6,
                    speed: 8,
                    level: 5,
                    exp: 300,
                    spells: ['mera', 'gira', 'hoimi'],
                    equipment: { weapon: null, armor: null }
                });
                party.push(mage);
                gameProgress.storyFlags.mageJoined = true;

                startDialogWithCallback(npc.joinAcceptMessages, () => {
                    saveGame();
                });
            } else if (npc.type === 'party_join_seren') {
                // ã‚»ãƒ¬ãƒ³ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã«è¿½åŠ 
                executeSerenJoin();
            }
        }

        // ã‚»ãƒ¬ãƒ³åŠ å…¥å‡¦ç†
        function executeSerenJoin() {
            if (gameProgress.quests.serenJoin.joined) return;

            const seren = createPartyMember({
                id: 'seer_seren',
                name: 'ã‚»ãƒ¬ãƒ³',
                job: 'seer',
                sprite: 'ğŸ”®',
                hp: 35,
                maxHp: 35,
                mp: 60,
                maxMp: 60,
                baseAtk: 8,
                baseDef: 6,
                speed: 14,
                level: 15,
                exp: 3500,
                spells: ['rukani', 'rariho', 'piorimu'],
                equipment: { weapon: null, armor: null }
            });

            party.push(seren);
            gameProgress.quests.serenJoin.joined = true;
            gameProgress.storyFlags.serenJoined = true;

            startDialogWithCallback(['ã‚»ãƒ¬ãƒ³ãŒä»²é–“ã«ãªã£ãŸï¼'], () => {
                saveGame();
            });
        }

        // ã‚°ãƒ©ã‚·ã‚ªåŠ å…¥å‡¦ç†
        function executeGlacioJoin() {
            if (gameProgress.quests.glacioJoin.joined) return;

            const glacio = createPartyMember({
                id: 'frozen_knight_glacio',
                name: 'ã‚°ãƒ©ã‚·ã‚ª',
                job: 'iceKnight',
                sprite: 'ğŸ§Š',
                hp: 90,
                maxHp: 90,
                mp: 15,
                maxMp: 15,
                baseAtk: 45,
                baseDef: 35,
                speed: 5,
                level: 38,
                exp: 45000,
                spells: ['iceSlash', 'frostArmor'],
                equipment: { weapon: 74, armor: 81 }  // ã“ãŠã‚Šã®ãŠãŠãªãŸã€ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰ãƒ¡ã‚¤ãƒ«
            });

            party.push(glacio);
            gameProgress.quests.glacioJoin.joined = true;
            gameProgress.storyFlags.glacioJoined = true;

            startDialogWithCallback([
                'å‡ã‚Šã¤ã„ãŸé¨å£«ã‚°ãƒ©ã‚·ã‚ªãŒä»²é–“ã«ãªã£ãŸï¼',
                'ã€Œæˆ‘ãŒå‰£ã¯ã€ä»Šåº¦ã“ãæ­£ã—ãé“ã®ãŸã‚ã«æŒ¯ã‚‹ãŠã†ã€'
            ], () => {
                saveGame();
            });
        }

        // ã‚°ãƒ©ã‚·ã‚ªåŠ å…¥NPCã®å‡¦ç†
        function handleGlacioJoinNpc(npc) {
            // æ—¢ã«åŠ å…¥æ¸ˆã¿
            if (gameProgress.quests.glacioJoin.joined) {
                startDialog([
                    'ã€Œå…±ã«æˆ¦ãŠã†ã€æ—…äººã‚ˆã€‚ã€',
                    'ã€Œå¥³ç‹æ§˜ã‚’æ•‘ã†ã¾ã§ã€æˆ‘ãŒå‰£ã¯æ±ã®ç›¾ã¨ãªã‚‹ã€‚ã€'
                ]);
                return;
            }

            // å¤ªé™½ã®ç‚ã‚’æŒã£ã¦ã„ãªã„å ´åˆ
            if (!getStoryFlag('sunFlameObtained')) {
                startDialog([
                    '...æ±ã¯...æ—…äººã‹...',
                    'ç§ã¯ã‚°ãƒ©ã‚·ã‚ª...ã“ã®åŸã®é¨å£«ã ã£ãŸã€‚',
                    '100å¹´ã‚‚ã®é–“...æ°·ã«é–‰ã–ã•ã‚Œ...è‹¦ã—ã¿ç¶šã‘ãŸã€‚',
                    '...å¾…ã£ã¦ã„ã‚‹...å¤ªé™½ã®ç‚ã‚’æŒã¤è€…ã‚’...',
                    'è¥¿ã®ç¥æ®¿ã«...ãã®ç‚ãŒã‚ã‚‹ã¯ãšã ...'
                ]);
                setQuestFlag('glacioJoin', 'met', true);
                return;
            }

            // å¤ªé™½ã®ç‚ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ - åŠ å…¥ã‚¤ãƒ™ãƒ³ãƒˆ
            startDialogWithCallback([
                '...ãã®ç‚ã¯...å¤ªé™½ã®ç‚ï¼',
                '100å¹´å¾…ã¡ç¶šã‘ãŸ...ã‚ˆã†ã‚„ãæ¥ã¦ãã‚ŒãŸï¼',
                'ä»Šã€ç§ã‚’æ°·ã‹ã‚‰è§£æ”¾ã—ã¦ãã‚Œï¼'
            ], () => {
                startDialogWithCallback([
                    'ï¼ˆå¤ªé™½ã®ç‚ãŒã‚°ãƒ©ã‚·ã‚ªã®æ°·ã‚’æº¶ã‹ã—ã¦ã„ã...ï¼‰'
                ], () => {
                    executeGlacioJoin();
                });
            });
        }

        // NPC IDã§å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function getNpcById(npcId) {
            if (!currentMap || !currentMap.npcs) return null;
            return currentMap.npcs.find(n => n.id === npcId);
        }

        // ãƒœã‚¹æˆ¦é–‹å§‹ï¼ˆæ±ç”¨ï¼‰
        function startBossBattle(bossId) {
            const monsterData = monsters[bossId];
            if (!monsterData) {
                console.error('Boss not found:', bossId);
                return;
            }

            // ãƒœã‚¹ã‚’æ•µé…åˆ—ã«è¿½åŠ 
            const bossEnemy = {
                ...monsterData,
                id: `${bossId}_0`,
                type: bossId,
                displayName: monsterData.name,
                currentHp: monsterData.hp,
                currentMp: monsterData.mp || 0,
                status: { sleep: 0, poison: 0, blind: 0 },
                actionCount: 0,
                bossId: bossId,
                index: 0
            };

            SE.encounter(); // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆéŸ³
            BGM.play('bossBattle'); // ãƒœã‚¹æˆ¦BGM
            battle.active = true;
            battle.enemies = [bossEnemy];
            battle.enemy = bossEnemy; // å¾Œæ–¹äº’æ›ç”¨
            battle.targetIndex = 0;
            battle.currentEnemyIndex = 0;
            battle.isSelectingTarget = false;
            battle.isSelectingAlly = false;
            battle.phase = 'start';
            battle.commandIndex = 0;
            battle.spellIndex = 0;
            battle.showSpells = false;
            battle.showItems = false;
            battle.itemCursor = 0;
            battle.message = '';
            battle.messageQueue = [];
            battle.result = null;
            battle.flashCount = 8;

            // ãƒ‘ãƒ¼ãƒ†ã‚£é–¢é€£ã®åˆæœŸåŒ–
            battle.currentPartyIndex = 0;
            battle.partyActions = [];
            battle.executingActionIndex = 0;

            // ãƒãƒ•ã‚’ãƒªã‚»ãƒƒãƒˆ
            if (battle.buffs) {
                battle.buffs.attackUp = 0;
                battle.buffs.defenseUp = 0;
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£å…¨å“¡ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            party.forEach(member => {
                member.status = { sleep: 0, poison: 0, blind: 0 };
            });
            gameMode = MODE.BATTLE;

            // ãƒãƒˆãƒ«ä¸­ã¯ãƒãƒƒãƒ—åã‚’éè¡¨ç¤º
            mapNameArea.style.display = 'none';

            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            const flashInterval = setInterval(() => {
                battle.flashCount--;
                if (battle.flashCount <= 0) {
                    clearInterval(flashInterval);
                    showBattleMessage(`${monsterData.name} ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼`, () => {
                        battle.phase = 'command';
                        const currentMember = getCurrentPartyMember();
                        battle.message = `${currentMember.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                    });
                }
            }, 80);
        }

        // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ããƒ€ã‚¤ã‚¢ãƒ­ã‚°
        function startDialogWithCallback(messages, onComplete) {
            dialog.active = true;
            dialog.messages = Array.isArray(messages) ? messages : [messages];
            dialog.currentIndex = 0;
            dialog.displayedText = '';
            dialog.charIndex = 0;
            dialog.isTyping = true;
            dialog.onComplete = onComplete;  // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä¿å­˜
            typeNextChar();
        }

        // é­”ç‹æˆ¦é–‹å§‹
        function startMaouBattle() {
            // é­”ç‹å°‚ç”¨ã®æ¼”å‡ºä»˜ããƒãƒˆãƒ«é–‹å§‹
            const monsterData = monsters['maou'];
            SE.encounter(); // ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆéŸ³
            BGM.play('bossBattle'); // ãƒœã‚¹æˆ¦BGM
            battle.active = true;
            battle.enemy = {
                ...monsterData,
                currentHp: monsterData.hp,
                currentMp: monsterData.mp,
                status: { sleep: 0, poison: 0, blind: 0 },
                actionCount: 0  // 2å›è¡Œå‹•ç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            };
            battle.phase = 'start';
            battle.commandIndex = 0;
            battle.spellIndex = 0;
            battle.showSpells = false;
            battle.showItems = false;
            battle.itemCursor = 0;
            battle.message = '';
            battle.messageQueue = [];
            battle.result = null;
            battle.flashCount = 12;  // é­”ç‹ã¯æ¿€ã—ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥

            player.status = { sleep: 0, poison: 0, blind: 0 };
            gameMode = MODE.BATTLE;

            // ãƒãƒˆãƒ«ä¸­ã¯ãƒãƒƒãƒ—åã‚’éè¡¨ç¤º
            mapNameArea.style.display = 'none';

            // æ¿€ã—ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
            const flashInterval = setInterval(() => {
                battle.flashCount--;
                if (battle.flashCount <= 0) {
                    clearInterval(flashInterval);
                    // é­”ç‹å°‚ç”¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    showBattleMessage('ã¤ã„ã« ããŸã‹...', () => {
                        showBattleMessage('ç§ãŒ é­”ç‹ã ï¼', () => {
                            screenShake.active = true;
                            screenShake.intensity = 8;
                            screenShake.duration = 30;
                            showBattleMessage('ãã‚‰ãˆï¼ ã“ã®åŠ›ã‚’ï¼', () => {
                                battle.phase = 'command';
                                const currentMember = getCurrentPartyMember();
                                battle.message = `${currentMember.name} ã® ã“ã†ã©ã†ï¼Ÿ`;
                            });
                        });
                    });
                }
            }, 80);
        }

        // é­”ç‹ã®AIè¡Œå‹•é¸æŠ
        // å…¨ä½“æ”»æ’ƒã‚¹ã‚­ãƒ«ã®ãƒªã‚¹ãƒˆ
        const aoeSkills = ['hageshiiHonoo', 'ionazun', 'hyados', 'giragura', 'bagigross', 'raiden'];

        function selectMaouAction() {
            const hpRatio = battle.enemy.currentHp / battle.enemy.hp;
            const skills = battle.enemy.skills;

            // ã‚¹ã‚­ãƒ«ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ãƒœã‚¹ã¯é€šå¸¸æ”»æ’ƒã®ã¿
            if (!skills || !Array.isArray(skills) || skills.length === 0) {
                return 'attack';
            }

            // 2å›è¡Œå‹•ã®2å›ç›®ã¯å…¨ä½“æ”»æ’ƒã‚’é¸ã°ãªã„
            const isSecondAction = battle.enemy.actionCount > 0;
            const lastActionWasAoe = battle.enemy.lastActionWasAoe || false;

            // HP50%ä»¥ä¸‹ã§ãƒ™ãƒ›ãƒã‚’ä½¿ã†ç¢ºç‡ãŒä¸ŠãŒã‚‹ï¼ˆæˆ¦é—˜ä¸­1å›ã®ã¿ï¼‰
            const canUseBehoma = skills.includes('behoma') && !battle.enemy.usedBehoma;
            if (hpRatio < 0.5 && canUseBehoma && Math.random() < 0.35) {
                battle.enemy.lastActionWasAoe = false;
                battle.enemy.usedBehoma = true;  // ä½¿ç”¨æ¸ˆã¿ãƒ•ãƒ©ã‚°
                return 'behoma';
            }

            // HP30%ä»¥ä¸‹ã§å¼·åŠ›ãªæ”»æ’ƒã‚’å¤šç”¨ï¼ˆãŸã ã—2å›ç›®ã¯å˜ä½“æ”»æ’ƒï¼‰
            if (hpRatio < 0.3 && !isSecondAction) {
                const aggressiveSkills = skills.filter(s => aoeSkills.includes(s));
                if (aggressiveSkills.length > 0 && Math.random() < 0.6) {
                    battle.enemy.lastActionWasAoe = true;
                    return aggressiveSkills[Math.floor(Math.random() * aggressiveSkills.length)];
                }
            }

            // é€šå¸¸æ™‚ã¯ãƒ©ãƒ³ãƒ€ãƒ ã«è¡Œå‹•ï¼ˆãƒ™ãƒ›ãƒä»¥å¤–ï¼‰
            let availableSkills = skills.filter(s => s !== 'behoma');

            // 2å›ç›®ã®è¡Œå‹•ã§ã¯å…¨ä½“æ”»æ’ƒã‚’é™¤å¤–
            if (isSecondAction || lastActionWasAoe) {
                availableSkills = availableSkills.filter(s => !aoeSkills.includes(s));
            }

            if (availableSkills.length === 0) {
                battle.enemy.lastActionWasAoe = false;
                return 'attack';
            }

            const selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
            battle.enemy.lastActionWasAoe = aoeSkills.includes(selectedSkill);
            return selectedSkill;
        }

        // ãƒœã‚¹ã®ã‚¹ã‚­ãƒ«å®Ÿè¡Œ
        function executeMaouSkill(skillId, callback) {
            const bossName = battle.enemy.displayName || battle.enemy.name || 'ãƒœã‚¹';

            if (skillId === 'attack') {
                // é€šå¸¸æ”»æ’ƒ - ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                const target = getRandomAlivePartyMember();
                if (!target) {
                    checkBattleEnd();
                    return;
                }

                let def = target.actualDef;
                // ã‚¹ã‚¯ãƒ«ãƒˆã«ã‚ˆã‚‹é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—
                if (battle.buffs.defenseUp > 0) {
                    const defenseMultiplier = 1 + battle.buffs.defenseUp * 0.25;
                    def = Math.floor(def * defenseMultiplier);
                }
                const damage = Math.max(1, Math.floor(battle.enemy.atk / 2 - def / 4 + Math.random() * 10));
                target.hp -= damage;

                screenShake.active = true;
                screenShake.intensity = 5;
                screenShake.duration = 15;

                showBattleMessage(`${bossName} ã® ã“ã†ã’ãï¼ ${target.name} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, () => {
                    if (target.hp <= 0) {
                        target.hp = 0;
                        target.isAlive = false;
                        showBattleMessage(`${target.name} ã¯ ãŸãŠã‚ŒãŸï¼`, () => {
                            checkBattleEnd() || callback();
                        });
                    } else {
                        callback();
                    }
                });
            } else {
                const skill = bossSkills[skillId];
                if (!skill) {
                    callback();
                    return;
                }

                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
                if (skill.flashColor) {
                    startSpellFlash(skill.flashColor);
                }

                // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ï¼ˆæ”»æ’ƒã‚¹ã‚­ãƒ«ã®ã¿ï¼‰
                if (skill.type === 'attack') {
                    screenShake.active = true;
                    screenShake.intensity = 10;
                    screenShake.duration = 20;
                }

                showBattleMessage(`${bossName} ã¯ ${skill.name} ã‚’ ã¯ãªã£ãŸï¼`, () => {
                    if (skill.type === 'heal') {
                        battle.enemy.currentHp = Math.min(battle.enemy.hp, battle.enemy.currentHp + skill.power);
                        showBattleMessage(`${bossName} ã® HPãŒ ã‹ã„ãµãã—ãŸï¼`, () => {
                            callback();
                        });
                    } else if (skill.type === 'attack') {
                        // å…¨ä½“æ”»æ’ƒã‹å˜ä½“æ”»æ’ƒã‹åˆ¤å®š
                        if (skill.target === 'all') {
                            // å…¨ä½“æ”»æ’ƒï¼šç”Ÿå­˜ã—ã¦ã„ã‚‹å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                            const aliveMembers = getAlivePartyMembers();
                            if (aliveMembers.length === 0) {
                                checkBattleEnd();
                                return;
                            }
                            let totalDamageMsg = '';
                            let defeatedMembers = [];
                            let elementEffects = [];
                            aliveMembers.forEach(member => {
                                // å±æ€§å€ç‡ã‚’è¨ˆç®—
                                const { multiplier, effectiveness } = getPlayerElementMultiplier(skill, member);
                                const baseDamage = skill.power + Math.floor(Math.random() * 15) - Math.floor(member.actualDef / 8);
                                const damage = Math.max(1, Math.floor(baseDamage * multiplier));
                                member.hp -= damage;
                                totalDamageMsg += `${member.name}ã« ${damage}  `;
                                // å±æ€§åŠ¹æœã‚’è¨˜éŒ²
                                if (effectiveness !== 'normal') {
                                    elementEffects.push({ name: member.name, effectiveness });
                                }
                                if (member.hp <= 0) {
                                    member.hp = 0;
                                    member.isAlive = false;
                                    defeatedMembers.push(member.name);
                                }
                            });
                            // å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                            let effectMsg = '';
                            if (elementEffects.length > 0) {
                                const resistedMembers = elementEffects.filter(e => e.effectiveness === 'resisted' || e.effectiveness === 'resistant');
                                const weakMembers = elementEffects.filter(e => e.effectiveness === 'weak' || e.effectiveness === 'effective');
                                if (resistedMembers.length > 0) effectMsg += ' (è€æ€§ã‚ã‚Š)';
                                if (weakMembers.length > 0) effectMsg += ' (å¼±ç‚¹!)';
                            }
                            showBattleMessage(totalDamageMsg + 'ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼' + effectMsg, () => {
                                if (defeatedMembers.length > 0) {
                                    showBattleMessage(`${defeatedMembers.join('ã¨ ')} ã¯ ãŸãŠã‚ŒãŸï¼`, () => {
                                        checkBattleEnd() || callback();
                                    });
                                } else {
                                    callback();
                                }
                            });
                        } else {
                            // å˜ä½“æ”»æ’ƒï¼šãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                            const target = getRandomAlivePartyMember();
                            if (!target) {
                                checkBattleEnd();
                                return;
                            }
                            // å±æ€§å€ç‡ã‚’è¨ˆç®—
                            const { multiplier, effectiveness } = getPlayerElementMultiplier(skill, target);
                            const baseDamage = skill.power + Math.floor(Math.random() * 15);
                            const damage = Math.max(1, Math.floor(baseDamage * multiplier));
                            target.hp -= damage;
                            // å±æ€§åŠ¹æœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                            const effectMsg = getPlayerElementEffectivenessMessage(effectiveness, target.name);
                            showBattleMessage(`${target.name} ã« ${damage} ã® ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, () => {
                                const showEffectAndContinue = (nextCallback) => {
                                    if (effectMsg) {
                                        showBattleMessage(effectMsg, nextCallback);
                                    } else {
                                        nextCallback();
                                    }
                                };
                                showEffectAndContinue(() => {
                                    if (target.hp <= 0) {
                                        target.hp = 0;
                                        target.isAlive = false;
                                        showBattleMessage(`${target.name} ã¯ ãŸãŠã‚ŒãŸï¼`, () => {
                                            checkBattleEnd() || callback();
                                        });
                                    } else {
                                        callback();
                                    }
                                });
                            });
                        }
                    } else if (skill.type === 'debuff') {
                        // ãƒ‡ãƒãƒ•ã‚¹ã‚­ãƒ«ï¼ˆãƒãƒ›ãƒˆãƒ¼ãƒ³ãªã©ï¼‰
                        showBattleMessage('ã—ã‹ã— ãªã«ã‚‚ ãŠã“ã‚‰ãªã‹ã£ãŸ...', () => {
                            callback();
                        });
                    } else {
                        callback();
                    }
                });
            }
        }

        // é­”ç‹ã®2å›è¡Œå‹•ã‚¿ãƒ¼ãƒ³
        function maouTurn() {
            battle.phase = 'enemyTurn';
            battle.enemy.actionCount = 0;
            executeMaouActions();
        }

        function executeMaouActions() {
            const bossName = battle.enemy.displayName || battle.enemy.name || 'ãƒœã‚¹';
            // çœ ã‚Šãƒã‚§ãƒƒã‚¯
            const wakeResult = checkWakeUp(battle.enemy, bossName);
            if (!wakeResult.awake) {
                showBattleMessage(wakeResult.message, () => {
                    processEnemyTurnEnd();
                });
                return;
            }
            if (wakeResult.message) {
                showBattleMessage(wakeResult.message, () => {
                    doMaouAction();
                });
                return;
            }
            doMaouAction();
        }

        function doMaouAction() {
            const skillId = selectMaouAction();
            battle.enemy.actionCount++;

            const bossActions = battle.enemy.actions || 1; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯1å›è¡Œå‹•
            const bossName = battle.enemy.displayName || battle.enemy.name || 'ãƒœã‚¹';

            executeMaouSkill(skillId, () => {
                // è¤‡æ•°å›è¡Œå‹•ãƒã‚§ãƒƒã‚¯
                if (battle.enemy.actionCount < bossActions && player.hp > 0) {
                    showBattleMessage(`${bossName} ã¯ ã•ã‚‰ã« ã“ã†ã’ãã‚’ ã—ã‹ã‘ã¦ããŸï¼`, () => {
                        doMaouAction();
                    });
                } else {
                    processEnemyTurnEnd();
                }
            });
        }

        // ========================================
        // å…¥åŠ›å‡¦ç†
        // ========================================
        document.addEventListener('keydown', (e) => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            if (isTransitioning) return;

            // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—è¡¨ç¤ºä¸­
            if (gameMode === MODE.MAP_VIEW) {
                if (e.key === 'm' || e.key === 'M' || e.key === 'Escape' || e.key === 'Enter' || e.key === ' ') {
                    closeWorldMap();
                }
                e.preventDefault();
                return;
            }

            // Mã‚­ãƒ¼ã§ãƒãƒƒãƒ—ã‚’é–‹ãï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ä¸­ï¼‰
            if ((e.key === 'm' || e.key === 'M') &&
                (gameMode === MODE.FIELD || gameMode === MODE.MENU || gameMode === MODE.DIALOG)) {
                openWorldMap();
                e.preventDefault();
                return;
            }

            // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢
            if (gameMode === MODE.TITLE) {
                if (!titleMenuActive) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        activateTitleMenu();
                    }
                } else {
                    const menuCount = hasSaveData ? 2 : 1;
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            titleMenuIndex = Math.max(0, titleMenuIndex - 1);
                            updateTitleMenuSelection();
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            titleMenuIndex = Math.min(menuCount - 1, titleMenuIndex + 1);
                            updateTitleMenuSelection();
                            break;
                        case 'Enter': case ' ': case 'z':
                            selectTitleMenuItem();
                            break;
                    }
                }
                e.preventDefault();
                return;
            }

            // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­
            if (gameMode === MODE.ENDING) {
                handleEndingInput();
                return;
            }

            // ãƒãƒˆãƒ«ä¸­
            if (gameMode === MODE.BATTLE) {
                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒ¢ãƒ¼ãƒ‰
                if (battle.isSelectingTarget) {
                    switch (e.key) {
                        case 'ArrowLeft': case 'a': case 'A':
                            battle.targetIndex = getPrevAliveEnemyIndex(battle.targetIndex);
                            break;
                        case 'ArrowRight': case 'd': case 'D':
                            battle.targetIndex = getNextAliveEnemyIndex(battle.targetIndex);
                            break;
                        case 'Enter': case ' ': case 'z':
                            confirmTargetSelection();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            cancelTargetSelection();
                            break;
                    }
                    e.preventDefault();
                    return;
                }

                // å‘³æ–¹é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼ˆå›å¾©å‘ªæ–‡ãªã©ï¼‰
                if (battle.isSelectingAlly) {
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            battle.allyTargetIndex = (battle.allyTargetIndex + party.length - 1) % party.length;
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            battle.allyTargetIndex = (battle.allyTargetIndex + 1) % party.length;
                            break;
                        case 'Enter': case ' ': case 'z':
                            confirmAllySelection();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            cancelAllySelection();
                            break;
                    }
                    e.preventDefault();
                    return;
                }

                if (battle.phase === 'command') {
                    if (battle.showSpells) {
                        const currentMember = getCurrentPartyMember();
                        const validSpells = currentMember.spells.filter(id => spells[id]);
                        switch (e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                battle.spellIndex = Math.max(0, battle.spellIndex - 1);
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                battle.spellIndex = Math.min(validSpells.length - 1, battle.spellIndex + 1);
                                break;
                            case 'Enter': case ' ': case 'z':
                                executeBattleCommand();
                                break;
                            case 'Escape': case 'x': case 'b': case 'B':
                                battle.showSpells = false;
                                break;
                        }
                    } else if (battle.showItems) {
                        // æœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆ
                        const validItems = player.inventory.filter(slot => items[slot.id]);
                        switch (e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                battle.itemCursor = Math.max(0, battle.itemCursor - 1);
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                battle.itemCursor = Math.min(Math.max(0, validItems.length - 1), battle.itemCursor + 1);
                                break;
                            case 'Enter': case ' ': case 'z':
                                executeBattleCommand();
                                break;
                            case 'Escape': case 'x': case 'b': case 'B':
                                battle.showItems = false;
                                break;
                        }
                    } else {
                        switch (e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                battle.commandIndex = Math.max(0, battle.commandIndex - 1);
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                battle.commandIndex = Math.min(3, battle.commandIndex + 1);
                                break;
                            case 'Enter': case ' ': case 'z':
                                executeBattleCommand();
                                break;
                        }
                    }
                }
                e.preventDefault();
                return;
            }

            // ã‚·ãƒ§ãƒƒãƒ—
            if (shop.active) {
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        handleShopInput('up');
                        break;
                    case 'ArrowDown': case 's': case 'S':
                        handleShopInput('down');
                        break;
                    case 'ArrowLeft': case 'a': case 'A':
                        handleShopInput('left');
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        handleShopInput('right');
                        break;
                    case 'Enter': case ' ': case 'z':
                        handleShopInput('confirm');
                        break;
                    case 'Escape': case 'x': case 'b': case 'B':
                        handleShopInput('cancel');
                        break;
                }
                e.preventDefault();
                return;
            }

            // å®¿å±‹
            if (inn.active) {
                switch (e.key) {
                    case 'ArrowLeft': case 'a': case 'A':
                        inn.selectedIndex = 0;
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        inn.selectedIndex = 1;
                        break;
                    case 'Enter': case ' ': case 'z':
                        confirmInn();
                        break;
                    case 'Escape': case 'x': case 'b': case 'B':
                        closeInn();
                        startDialog(['ã¾ãŸã®ãŠè¶Šã—ã‚’ ãŠã¾ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚']);
                        break;
                }
                e.preventDefault();
                return;
            }

            // æ•™ä¼š
            if (church.active) {
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        if (church.phase === 'menu') {
                            church.menuIndex = (church.menuIndex - 1 + 4) % 4;
                        } else if (church.phase === 'selectMember') {
                            church.selectedMember = (church.selectedMember - 1 + party.length) % party.length;
                        }
                        break;
                    case 'ArrowDown': case 's': case 'S':
                        if (church.phase === 'menu') {
                            church.menuIndex = (church.menuIndex + 1) % 4;
                        } else if (church.phase === 'selectMember') {
                            church.selectedMember = (church.selectedMember + 1) % party.length;
                        }
                        break;
                    case 'ArrowLeft': case 'a': case 'A':
                        if (church.phase === 'confirm') {
                            church.confirmIndex = 0;
                        }
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        if (church.phase === 'confirm') {
                            church.confirmIndex = 1;
                        }
                        break;
                    case 'Enter': case ' ': case 'z':
                        if (church.phase === 'menu') {
                            selectChurchMenu();
                        } else if (church.phase === 'selectMember') {
                            confirmChurchMember();
                        } else if (church.phase === 'confirm') {
                            confirmChurchAction();
                        }
                        break;
                    case 'Escape': case 'x': case 'b': case 'B':
                        if (church.phase === 'confirm') {
                            church.phase = 'selectMember';
                        } else if (church.phase === 'selectMember') {
                            church.phase = 'menu';
                        } else {
                            closeChurch();
                            startDialog(['ã¾ãŸ ã„ã¤ã§ã‚‚ ãŠã“ã—ãã ã•ã„ã€‚']);
                        }
                        break;
                }
                e.preventDefault();
                return;
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥ç¢ºèª
            if (partyJoinConfirm.active) {
                switch (e.key) {
                    case 'ArrowLeft': case 'a': case 'A':
                        partyJoinConfirm.selectedIndex = 0;
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        partyJoinConfirm.selectedIndex = 1;
                        break;
                    case 'Enter': case ' ': case 'z':
                        if (partyJoinConfirm.selectedIndex === 0) {
                            // ã¯ã„
                            partyJoinConfirm.active = false;
                            executePartyJoin(partyJoinConfirm.npcId);
                        } else {
                            // ã„ã„ãˆ
                            partyJoinConfirm.active = false;
                            const npc = getNpcById(partyJoinConfirm.npcId);
                            if (npc && npc.joinDeclineMessages) {
                                startDialog(npc.joinDeclineMessages);
                            }
                        }
                        break;
                    case 'Escape': case 'x': case 'b': case 'B':
                        partyJoinConfirm.active = false;
                        const npc = getNpcById(partyJoinConfirm.npcId);
                        if (npc && npc.joinDeclineMessages) {
                            startDialog(npc.joinDeclineMessages);
                        }
                        break;
                }
                e.preventDefault();
                return;
            }

            // ãƒ«ãƒ¼ãƒ©æ‹ ç‚¹é¸æŠ
            if (ruraState.active) {
                // ã‚¨ãƒªã‚¢åˆ¶é™å¯¾å¿œï¼šåˆ©ç”¨å¯èƒ½ãªæ‹ ç‚¹ã®ã¿
                const locations = getAvailableRuraLocations();
                // æ‹ ç‚¹ãŒãªã„å ´åˆã¯é¸æŠã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆNaNé˜²æ­¢ï¼‰
                if (locations.length === 0) {
                    cancelRuraSelection();
                    e.preventDefault();
                    return;
                }
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        ruraState.cursor = (ruraState.cursor + locations.length - 1) % locations.length;
                        break;
                    case 'ArrowDown': case 's': case 'S':
                        ruraState.cursor = (ruraState.cursor + 1) % locations.length;
                        break;
                    case 'Enter': case ' ': case 'z': case 'Z':
                        executeRura(ruraState.cursor);
                        break;
                    case 'Escape': case 'x': case 'b': case 'B':
                        cancelRuraSelection();
                        break;
                }
                e.preventDefault();
                return;
            }

            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
            if (menu.active) {
                if (menu.selectingEquipMember) {
                    // è£…å‚™å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            menu.targetMemberCursor = (menu.targetMemberCursor + party.length - 1) % party.length;
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            menu.targetMemberCursor = (menu.targetMemberCursor + 1) % party.length;
                            break;
                        case 'Enter': case ' ': case 'z': case 'Z':
                            confirmEquipMember();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            menu.selectingEquipMember = false;
                            menu.showItemAction = true;
                            break;
                    }
                } else if (menu.selectingItemMember) {
                    // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ‰
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            menu.targetMemberCursor = (menu.targetMemberCursor + party.length - 1) % party.length;
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            menu.targetMemberCursor = (menu.targetMemberCursor + 1) % party.length;
                            break;
                        case 'Enter': case ' ': case 'z': case 'Z':
                            confirmItemMember();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            menu.selectingItemMember = false;
                            menu.showItemAction = true;
                            break;
                    }
                } else if (menu.showItemAction) {
                    // ã‚¢ã‚¤ãƒ†ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œ
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            menu.itemActionIndex = (menu.itemActionIndex + 3) % 4;
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            menu.itemActionIndex = (menu.itemActionIndex + 1) % 4;
                            break;
                        case 'Enter': case ' ': case 'z': case 'Z':
                            executeItemAction();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            menu.showItemAction = false;
                            break;
                    }
                } else if (menu.mode === 'items' && player.inventory.length > 0) {
                    // ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆæ“ä½œï¼ˆæœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆï¼‰
                    const validItems = player.inventory.filter(slot => items[slot.id]);
                    if (validItems.length === 0) return;
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            menu.itemCursor = (menu.itemCursor + validItems.length - 1) % validItems.length;
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            menu.itemCursor = (menu.itemCursor + 1) % validItems.length;
                            break;
                        case 'ArrowLeft': case 'a': case 'A':
                            menu.mode = 'spells';
                            menu.spellCursor = 0;
                            break;
                        case 'ArrowRight': case 'd': case 'D':
                            menu.mode = 'map';
                            break;
                        case 'Enter': case ' ': case 'z': case 'Z':
                            menu.showItemAction = true;
                            menu.itemActionIndex = 0;
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            closeMenu();
                            break;
                    }
                } else if (menu.mode === 'spells') {
                    const selectedMember = party[menu.memberCursor] || party[0];
                    if (menu.selectingMember) {
                        // å‘ªæ–‡å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰
                        switch (e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                menu.targetMemberCursor = (menu.targetMemberCursor + party.length - 1) % party.length;
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                menu.targetMemberCursor = (menu.targetMemberCursor + 1) % party.length;
                                break;
                            case 'Enter': case ' ': case 'z': case 'Z':
                                executeFieldSpellOnTarget();
                                break;
                            case 'Escape': case 'x': case 'b': case 'B':
                                menu.selectingMember = false;
                                break;
                        }
                    } else if (selectedMember.spells.length > 0) {
                        // å‘ªæ–‡ãƒªã‚¹ãƒˆæ“ä½œ
                        switch (e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                menu.spellCursor = (menu.spellCursor + selectedMember.spells.length - 1) % selectedMember.spells.length;
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                menu.spellCursor = (menu.spellCursor + 1) % selectedMember.spells.length;
                                break;
                            case 'ArrowLeft': case 'a': case 'A':
                                if (party.length > 1) {
                                    menu.memberCursor = (menu.memberCursor + party.length - 1) % party.length;
                                    menu.spellCursor = 0;
                                } else {
                                    menu.mode = 'status';
                                }
                                break;
                            case 'ArrowRight': case 'd': case 'D':
                                if (party.length > 1) {
                                    menu.memberCursor = (menu.memberCursor + 1) % party.length;
                                    menu.spellCursor = 0;
                                } else {
                                    menu.mode = 'items';
                                    menu.itemCursor = 0;
                                }
                                break;
                            case 'Enter': case ' ': case 'z': case 'Z':
                                useSpellInField();
                                break;
                            case 'Escape': case 'x': case 'b': case 'B':
                                closeMenu();
                                break;
                        }
                    } else {
                        // å‘ªæ–‡ãŒãªã„å ´åˆã¯ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
                        switch (e.key) {
                            case 'ArrowLeft': case 'a': case 'A':
                                if (party.length > 1) {
                                    menu.memberCursor = (menu.memberCursor + party.length - 1) % party.length;
                                    menu.spellCursor = 0;
                                } else {
                                    menu.mode = 'status';
                                }
                                break;
                            case 'ArrowRight': case 'd': case 'D':
                                if (party.length > 1) {
                                    menu.memberCursor = (menu.memberCursor + 1) % party.length;
                                    menu.spellCursor = 0;
                                } else {
                                    menu.mode = 'items';
                                    menu.itemCursor = 0;
                                }
                                break;
                            case 'Escape': case 'x': case 'b': case 'B':
                                closeMenu();
                                break;
                        }
                    }
                } else if (menu.mode === 'map') {
                    // ã¡ãšã‚¿ãƒ–
                    switch (e.key) {
                        case 'ArrowLeft': case 'a': case 'A':
                            menu.mode = 'items';
                            menu.itemCursor = 0;
                            break;
                        case 'ArrowRight': case 'd': case 'D':
                            menu.mode = 'status';
                            break;
                        case 'Enter': case ' ': case 'z': case 'Z':
                            closeMenu();
                            openWorldMap();
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            closeMenu();
                            break;
                    }
                } else if (menu.mode === 'status') {
                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼é¸æŠå¯èƒ½ï¼‰
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W':
                            if (party.length > 1) {
                                menu.memberCursor = (menu.memberCursor + party.length - 1) % party.length;
                            }
                            break;
                        case 'ArrowDown': case 's': case 'S':
                            if (party.length > 1) {
                                menu.memberCursor = (menu.memberCursor + 1) % party.length;
                            }
                            break;
                        case 'ArrowLeft': case 'a': case 'A':
                            menu.mode = 'map';
                            break;
                        case 'ArrowRight': case 'd': case 'D':
                            menu.mode = 'spells';
                            menu.spellCursor = 0;
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            closeMenu();
                            break;
                    }
                } else {
                    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚¢ã‚¤ãƒ†ãƒ ãƒ»å‘ªæ–‡ãŒãªã„å ´åˆï¼‰
                    switch (e.key) {
                        case 'ArrowLeft': case 'a': case 'A':
                            if (menu.mode === 'spells') {
                                menu.mode = 'status';
                            } else if (menu.mode === 'items') {
                                menu.mode = 'spells';
                                menu.spellCursor = 0;
                            }
                            break;
                        case 'ArrowRight': case 'd': case 'D':
                            if (menu.mode === 'spells') {
                                menu.mode = 'items';
                                menu.itemCursor = 0;
                            } else if (menu.mode === 'items') {
                                menu.mode = 'map';
                            }
                            break;
                        case 'Escape': case 'x': case 'b': case 'B':
                            closeMenu();
                            break;
                    }
                }
                e.preventDefault();
                return;
            }

            if (dialog.active) {
                if (e.key === 'Enter' || e.key === ' ' || e.key === 'z') {
                    advanceDialog();
                    e.preventDefault();
                }
                return;
            }

            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': startContinuousMove(0, -1); break;
                case 'ArrowDown': case 's': case 'S': startContinuousMove(0, 1); break;
                case 'ArrowLeft': case 'a': case 'A': startContinuousMove(-1, 0); break;
                case 'ArrowRight': case 'd': case 'D': startContinuousMove(1, 0); break;
                case 'Enter': case ' ': case 'z': interact(); break;
                case 'Escape': case 'x': case 'b': case 'B': openMenu(); break;
            }
            e.preventDefault();
        });

        // ã‚­ãƒ¼ã‚’é›¢ã—ãŸæ™‚ã«é€£ç¶šç§»å‹•ã‚’åœæ­¢
        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                case 'ArrowDown': case 's': case 'S':
                case 'ArrowLeft': case 'a': case 'A':
                case 'ArrowRight': case 'd': case 'D':
                    stopContinuousMove();
                    break;
            }
        });

        // é€£ç¶šç§»å‹•ã®é–‹å§‹
        function startContinuousMove(dx, dy) {
            // æ—¢å­˜ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ–¹å‘ã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼‰
            if (moveInterval) {
                clearInterval(moveInterval);
                moveInterval = null;
            }
            currentMoveDirection = { dx, dy };
            movePlayer(dx, dy);  // å³åº§ã«1å›ç§»å‹•
            moveInterval = setInterval(() => {
                if (gameMode === MODE.FIELD && !isTransitioning && !dialog.active &&
                    !menu.active && !inn.active && !shop.active) {
                    movePlayer(currentMoveDirection.dx, currentMoveDirection.dy);
                }
            }, CONTINUOUS_MOVE_DELAY);
        }

        // é€£ç¶šç§»å‹•ã®åœæ­¢
        function stopContinuousMove() {
            if (moveInterval) {
                clearInterval(moveInterval);
                moveInterval = null;
            }
            currentMoveDirection = { dx: 0, dy: 0 };
        }

        // ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³
        function setupDpadButton(id, dx, dy) {
            const btn = document.getElementById(id);
            const handlePress = (e) => {
                e.preventDefault();
                initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
                // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥ç¢ºèª
                if (partyJoinConfirm.active) {
                    if (dx < 0) partyJoinConfirm.selectedIndex = 0;
                    else if (dx > 0) partyJoinConfirm.selectedIndex = 1;
                    return;
                }
                // ãƒãƒˆãƒ«ä¸­ - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒ¢ãƒ¼ãƒ‰
                if (gameMode === MODE.BATTLE && battle.isSelectingTarget) {
                    if (dx < 0) battle.targetIndex = getPrevAliveEnemyIndex(battle.targetIndex);
                    else if (dx > 0) battle.targetIndex = getNextAliveEnemyIndex(battle.targetIndex);
                    return;
                }
                // ãƒãƒˆãƒ«ä¸­ - å‘³æ–¹é¸æŠãƒ¢ãƒ¼ãƒ‰
                if (gameMode === MODE.BATTLE && battle.isSelectingAlly) {
                    if (dy < 0) battle.allyTargetIndex = (battle.allyTargetIndex + party.length - 1) % party.length;
                    else if (dy > 0) battle.allyTargetIndex = (battle.allyTargetIndex + 1) % party.length;
                    return;
                }
                // ãƒãƒˆãƒ«ä¸­ - ã‚³ãƒãƒ³ãƒ‰é¸æŠ
                if (gameMode === MODE.BATTLE && battle.phase === 'command') {
                    if (dy < 0) {
                        if (battle.showSpells) {
                            battle.spellIndex = Math.max(0, battle.spellIndex - 1);
                        } else if (battle.showItems) {
                            battle.itemCursor = Math.max(0, battle.itemCursor - 1);
                        } else {
                            battle.commandIndex = Math.max(0, battle.commandIndex - 1);
                        }
                    } else if (dy > 0) {
                        if (battle.showSpells) {
                            const currentMember = getCurrentPartyMember();
                            const validSpells = currentMember.spells.filter(id => spells[id]);
                            battle.spellIndex = Math.min(validSpells.length - 1, battle.spellIndex + 1);
                        } else if (battle.showItems) {
                            const validItems = player.inventory.filter(slot => items[slot.id]);
                            battle.itemCursor = Math.min(Math.max(0, validItems.length - 1), battle.itemCursor + 1);
                        } else {
                            battle.commandIndex = Math.min(3, battle.commandIndex + 1);
                        }
                    }
                    return;
                }
                // ã‚·ãƒ§ãƒƒãƒ—
                if (shop.active) {
                    if (dy < 0) handleShopInput('up');
                    else if (dy > 0) handleShopInput('down');
                    else if (dx < 0) handleShopInput('left');
                    else if (dx > 0) handleShopInput('right');
                    return;
                }
                // å®¿å±‹
                if (inn.active) {
                    if (dx < 0) inn.selectedIndex = 0;
                    else if (dx > 0) inn.selectedIndex = 1;
                    return;
                }
                // æ•™ä¼š
                if (church.active) {
                    if (church.phase === 'menu') {
                        if (dy < 0) church.menuIndex = (church.menuIndex - 1 + 4) % 4;
                        else if (dy > 0) church.menuIndex = (church.menuIndex + 1) % 4;
                    } else if (church.phase === 'selectMember') {
                        if (dy < 0) church.selectedMember = (church.selectedMember - 1 + party.length) % party.length;
                        else if (dy > 0) church.selectedMember = (church.selectedMember + 1) % party.length;
                    } else if (church.phase === 'confirm') {
                        if (dx < 0) church.confirmIndex = 0;
                        else if (dx > 0) church.confirmIndex = 1;
                    }
                    return;
                }
                // ãƒ¡ãƒ‹ãƒ¥ãƒ¼
                if (menu.active) {
                    if (menu.selectingMember) {
                        // å‘ªæ–‡å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼ˆå›å¾©å‘ªæ–‡ãªã©ï¼‰
                        if (dy < 0) menu.targetMemberCursor = (menu.targetMemberCursor + party.length - 1) % party.length;
                        else if (dy > 0) menu.targetMemberCursor = (menu.targetMemberCursor + 1) % party.length;
                    } else if (menu.selectingEquipMember || menu.selectingItemMember) {
                        // è£…å‚™/ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯¾è±¡ãƒ¡ãƒ³ãƒãƒ¼é¸æŠ
                        if (dy < 0) menu.targetMemberCursor = (menu.targetMemberCursor + party.length - 1) % party.length;
                        else if (dy > 0) menu.targetMemberCursor = (menu.targetMemberCursor + 1) % party.length;
                    } else if (menu.showItemAction) {
                        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼
                        if (dy < 0) menu.itemActionIndex = (menu.itemActionIndex + 3) % 4;
                        else if (dy > 0) menu.itemActionIndex = (menu.itemActionIndex + 1) % 4;
                    } else if (menu.mode === 'items' && player.inventory.length > 0) {
                        // ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆï¼ˆæœ‰åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆï¼‰
                        const validItems = player.inventory.filter(slot => items[slot.id]);
                        if (validItems.length > 0) {
                            if (dy < 0) menu.itemCursor = (menu.itemCursor + validItems.length - 1) % validItems.length;
                            else if (dy > 0) menu.itemCursor = (menu.itemCursor + 1) % validItems.length;
                            else if (dx < 0) { menu.mode = 'spells'; menu.spellCursor = 0; }
                            else if (dx > 0) menu.mode = 'map';
                        }
                    } else if (menu.mode === 'spells' && player.spells.length > 0) {
                        // å‘ªæ–‡ãƒªã‚¹ãƒˆ
                        if (dy < 0) menu.spellCursor = (menu.spellCursor + player.spells.length - 1) % player.spells.length;
                        else if (dy > 0) menu.spellCursor = (menu.spellCursor + 1) % player.spells.length;
                        else if (dx < 0) menu.mode = 'status';
                        else if (dx > 0) { menu.mode = 'items'; menu.itemCursor = 0; }
                    } else if (menu.mode === 'map') {
                        // ã¡ãšã‚¿ãƒ–
                        if (dx < 0) { menu.mode = 'items'; menu.itemCursor = 0; }
                        else if (dx > 0) menu.mode = 'status';
                    } else if (menu.mode === 'status' && party.length > 1) {
                        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ - ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼é¸æŠ
                        if (dy < 0) menu.memberCursor = (menu.memberCursor + party.length - 1) % party.length;
                        else if (dy > 0) menu.memberCursor = (menu.memberCursor + 1) % party.length;
                        else if (dx < 0) menu.mode = 'map';
                        else if (dx > 0) { menu.mode = 'spells'; menu.spellCursor = 0; }
                    } else {
                        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆï¼ˆstatus/å‘ªæ–‡ãªã—/ã‚¢ã‚¤ãƒ†ãƒ ãªã—ã®å ´åˆï¼‰
                        if (dx < 0) {
                            if (menu.mode === 'status') menu.mode = 'map';
                            else if (menu.mode === 'spells') menu.mode = 'status';
                            else if (menu.mode === 'items') { menu.mode = 'spells'; menu.spellCursor = 0; }
                            else if (menu.mode === 'map') { menu.mode = 'items'; menu.itemCursor = 0; }
                        } else if (dx > 0) {
                            if (menu.mode === 'status') { menu.mode = 'spells'; menu.spellCursor = 0; }
                            else if (menu.mode === 'spells') { menu.mode = 'items'; menu.itemCursor = 0; }
                            else if (menu.mode === 'items') menu.mode = 'map';
                            else if (menu.mode === 'map') menu.mode = 'status';
                        }
                    }
                    return;
                }
                if (isTransitioning || dialog.active) return;
                btn.classList.add('pressed');
                // é€£ç¶šç§»å‹•ã‚’é–‹å§‹
                startContinuousMove(dx, dy);
            };
            const handleRelease = () => {
                btn.classList.remove('pressed');
                stopContinuousMove();
            };
            btn.addEventListener('touchstart', handlePress, { passive: false });
            btn.addEventListener('touchend', handleRelease);
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
            btn.addEventListener('mouseleave', handleRelease);
        }

        setupDpadButton('dpad-up', 0, -1);
        setupDpadButton('dpad-down', 0, 1);
        setupDpadButton('dpad-left', -1, 0);
        setupDpadButton('dpad-right', 1, 0);

        function setupActionButton(id, callback) {
            const btn = document.getElementById(id);
            const handlePress = (e) => { e.preventDefault(); initAudio(); btn.classList.add('pressed'); callback(); };
            const handleRelease = () => { btn.classList.remove('pressed'); };
            btn.addEventListener('touchstart', handlePress, { passive: false });
            btn.addEventListener('touchend', handleRelease);
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
            btn.addEventListener('mouseleave', handleRelease);
        }

        function onActionA() {
            if (isTransitioning) return;
            // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥ç¢ºèª
            if (partyJoinConfirm.active) {
                if (partyJoinConfirm.selectedIndex === 0) {
                    partyJoinConfirm.active = false;
                    executePartyJoin(partyJoinConfirm.npcId);
                } else {
                    partyJoinConfirm.active = false;
                    const npc = getNpcById(partyJoinConfirm.npcId);
                    if (npc && npc.joinDeclineMessages) {
                        startDialog(npc.joinDeclineMessages);
                    }
                }
                return;
            }
            // ãƒãƒˆãƒ«ä¸­ - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠç¢ºå®š
            if (gameMode === MODE.BATTLE && battle.isSelectingTarget) {
                confirmTargetSelection();
                return;
            }
            // ãƒãƒˆãƒ«ä¸­ - å‘³æ–¹é¸æŠç¢ºå®š
            if (gameMode === MODE.BATTLE && battle.isSelectingAlly) {
                confirmAllySelection();
                return;
            }
            if (gameMode === MODE.BATTLE && battle.phase === 'command') {
                executeBattleCommand();
            } else if (shop.active) {
                handleShopInput('confirm');
            } else if (inn.active) {
                confirmInn();
            } else if (church.active) {
                if (church.phase === 'menu') {
                    selectChurchMenu();
                } else if (church.phase === 'selectMember') {
                    confirmChurchMember();
                } else if (church.phase === 'confirm') {
                    confirmChurchAction();
                }
            } else if (menu.active) {
                // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å†…æ“ä½œ
                if (menu.selectingMember) {
                    // å‘ªæ–‡å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰ - å¯¾è±¡ã‚’æ±ºå®š
                    executeFieldSpellOnTarget();
                } else if (menu.selectingEquipMember) {
                    confirmEquipMember();
                } else if (menu.selectingItemMember) {
                    confirmItemMember();
                } else if (menu.showItemAction) {
                    executeItemAction();
                } else if (menu.mode === 'items' && player.inventory.length > 0) {
                    menu.showItemAction = true;
                    menu.itemActionIndex = 0;
                } else if (menu.mode === 'spells' && player.spells.length > 0) {
                    useSpellInField();
                } else if (menu.mode === 'map') {
                    // ã¡ãšã‚¿ãƒ–ã§Aãƒœã‚¿ãƒ³ â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã
                    closeMenu();
                    openWorldMap();
                }
            } else {
                interact();
            }
        }

        function onActionB() {
            // ãƒ‘ãƒ¼ãƒ†ã‚£åŠ å…¥ç¢ºèªã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (partyJoinConfirm.active) {
                partyJoinConfirm.active = false;
                const npc = getNpcById(partyJoinConfirm.npcId);
                if (npc && npc.joinDeclineMessages) {
                    startDialog(npc.joinDeclineMessages);
                }
                return;
            }
            // ãƒãƒˆãƒ«ä¸­ - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (gameMode === MODE.BATTLE && battle.isSelectingTarget) {
                cancelTargetSelection();
                return;
            }
            // ãƒãƒˆãƒ«ä¸­ - å‘³æ–¹é¸æŠã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (gameMode === MODE.BATTLE && battle.isSelectingAlly) {
                cancelAllySelection();
                return;
            }
            if (gameMode === MODE.BATTLE && battle.showSpells) {
                battle.showSpells = false;
            } else if (gameMode === MODE.BATTLE && battle.showItems) {
                battle.showItems = false;
            } else if (shop.active) {
                handleShopInput('cancel');
            } else if (inn.active) {
                closeInn();
                startDialog(['ã¾ãŸã®ãŠè¶Šã—ã‚’ ãŠã¾ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚']);
            } else if (church.active) {
                if (church.phase === 'confirm') {
                    church.phase = 'selectMember';
                } else if (church.phase === 'selectMember') {
                    church.phase = 'menu';
                } else {
                    closeChurch();
                    startDialog(['ã¾ãŸ ã„ã¤ã§ã‚‚ ãŠã“ã—ãã ã•ã„ã€‚']);
                }
            } else if (dialog.active) {
                closeDialog();
            } else if (menu.active) {
                if (menu.selectingMember) {
                    // å‘ªæ–‡å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰ - ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    menu.selectingMember = false;
                } else if (menu.selectingEquipMember) {
                    menu.selectingEquipMember = false;
                    menu.showItemAction = true;
                } else if (menu.selectingItemMember) {
                    menu.selectingItemMember = false;
                    menu.showItemAction = true;
                } else if (menu.showItemAction) {
                    menu.showItemAction = false;
                } else {
                    closeMenu();
                }
            } else {
                openMenu();
            }
        }

        setupActionButton('btn-a', onActionA);
        setupActionButton('btn-b', onActionB);

        // ========================================
        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å†…ã‚¿ãƒƒãƒ—æ“ä½œï¼ˆã‚¹ãƒãƒ›å‘ã‘ãƒ¡ãƒ³ãƒãƒ¼é¸æŠï¼‰
        // ========================================
        function handleCanvasTap(clientX, clientY) {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®åº§æ¨™ã«å¤‰æ›
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const tapX = (clientX - rect.left) * scaleX;
            const tapY = (clientY - rect.top) * scaleY;

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã¦ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‹å‘ªæ–‡ã‚¿ãƒ–ã®å ´åˆã®ã¿å‡¦ç†
            if (!menu.active) return false;
            if (menu.mode !== 'status' && menu.mode !== 'spells') return false;
            if (party.length <= 1) return false;  // ä»²é–“ãŒã„ãªã„å ´åˆã¯ä¸è¦
            if (menu.selectingMember) return false;  // å‘ªæ–‡å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ä¸å‡¦ç†

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼åº§æ¨™ã‚’è¨ˆç®—ï¼ˆdrawMenuã¨åŒã˜è¨ˆç®—ï¼‰
            const menuWidth = canvasWidth * 0.85;
            const menuHeight = canvasHeight * 0.75;
            const menuX = (canvasWidth - menuWidth) / 2;
            const menuY = (canvasHeight - menuHeight) / 2;
            const tabY = menuY + 10;
            const contentY = tabY + tileSize * 0.7;
            const lineHeight = tileSize * 0.5;

            // ãƒ¡ãƒ³ãƒãƒ¼ãƒªã‚¹ãƒˆé ˜åŸŸï¼ˆå‘ªæ–‡ã‚¿ãƒ–ã®å·¦å´ï¼‰
            const memberListX = menuX + 15;
            const memberListY = contentY + 5;
            const memberListWidth = menuWidth * 0.28;

            // ã‚¿ãƒƒãƒ—ãŒãƒ¡ãƒ³ãƒãƒ¼ãƒªã‚¹ãƒˆé ˜åŸŸå†…ã‹ãƒã‚§ãƒƒã‚¯
            if (tapX >= memberListX - 5 && tapX <= memberListX + memberListWidth + 5) {
                for (let idx = 0; idx < party.length; idx++) {
                    const itemTop = memberListY + idx * lineHeight * 0.9 - 3;
                    const itemBottom = itemTop + lineHeight * 0.85;
                    if (tapY >= itemTop && tapY <= itemBottom) {
                        menu.memberCursor = idx;
                        if (menu.mode === 'spells') {
                            menu.spellCursor = 0;  // å‘ªæ–‡ã‚«ãƒ¼ã‚½ãƒ«ã‚‚ãƒªã‚»ãƒƒãƒˆ
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ã®ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('click', (e) => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            handleCanvasTap(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchend', (e) => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                if (handleCanvasTap(touch.clientX, touch.clientY)) {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // ========================================
        // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ãƒ»ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ é˜²æ­¢
        // ========================================

        // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ã‚’é˜²æ­¢
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã‚’é˜²æ­¢ï¼ˆ2æœ¬æŒ‡ã‚¿ãƒƒãƒï¼‰
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // gestureã‚¤ãƒ™ãƒ³ãƒˆï¼ˆSafariï¼‰ã‚’é˜²æ­¢
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gestureend', (e) => {
            e.preventDefault();
        }, { passive: false });

        // ========================================
        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        // ========================================

        // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºæ›´æ–°ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã§ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
        const encounterDebugElement = document.getElementById('encounterDebug');
        function updateEncounterDebug() {
            if (!encounterDebugElement) return;
            const rate = getCurrentEncounterRate();
            encounterDebugElement.textContent = `æ­©æ•°: ${stepsSinceLastBattle} | ç¢ºç‡: ${(rate * 100).toFixed(1)}%`;
        }

        function gameLoop() {
            // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«æ›´æ–°
            updateStaffRoll();

            // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºæ›´æ–°
            updateEncounterDebug();

            draw();
            requestAnimationFrame(gameLoop);
        }

        // ========================================
        // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ 
        // ========================================
        const worldMapOverlay = document.getElementById('worldMapOverlay');
        const worldMapCanvas = document.getElementById('worldMapCanvas');
        const worldMapCtx = worldMapCanvas.getContext('2d');
        const worldMapTitle = document.getElementById('worldMapTitle');

        // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆåœ°å½¢æç”»ç”¨ï¼‰
        let worldMapOffscreen = null;
        let worldMapOffscreenCtx = null;

        // åœ°å›³ã®è‰²è¨­å®šï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ç”¨ï¼‰
        const WORLD_MAP_COLORS = {
            0: '#44aa44', // è‰åŸ/å¹³åœ°
            1: '#886644', // å±±/å²©å ´
            2: '#2244aa', // æµ·/æ°´åŸŸ
            3: '#ffffff', // åŸ
            4: '#ffffff', // è¡—/å»ºç‰©
            5: '#8866aa', // éšæ®µ
            6: '#996633', // åºŠï¼ˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼‰
            7: '#555555', // å£
            8: '#6a4aaa', // æ—…ã®æ‰‰ï¼ˆç´«ï¼‰
            9: '#8866aa', // ä¸Šã‚Šéšæ®µ
            10: '#664488', // ä¸‹ã‚Šéšæ®µ
            // ç ‚æ¼ ã‚¿ã‚¤ãƒ«
            11: '#d4a559', // ç ‚æ¼ 
            12: '#44aa66', // ã‚ªã‚¢ã‚·ã‚¹
            13: '#c4a040', // ãƒ”ãƒ©ãƒŸãƒƒãƒ‰
            14: '#b89050', // æµç ‚
            // åœ°åº•ã‚¿ã‚¤ãƒ«
            17: '#2a1a3a', // åœ°åº•åºŠ - æš—ã„ç´«
            18: '#0a0a1a', // åœ°åº•å£ - ã»ã¼é»’
            20: '#ffffff'  // åœ°åº•ã®è¡— - ç™½ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ã§ç›®ç«‹ã¤ï¼‰
        };

        // åœ°å›³è¡¨ç¤ºã®çŠ¶æ…‹
        let worldMapAnimationId = null;
        let playerBlinkState = true;

        function openWorldMap() {
            if (gameMode === MODE.BATTLE || gameMode === MODE.TITLE || gameMode === MODE.ENDING) {
                return;
            }

            const previousMode = gameMode;
            gameMode = MODE.MAP_VIEW;

            // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¨­å®š
            worldMapTitle.textContent = currentMap.name || 'ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—';

            // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤º
            worldMapOverlay.classList.add('active');

            // åœ°å›³ã‚’æç”»
            renderWorldMap();

            // ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            startPlayerMarkerAnimation();
        }

        function closeWorldMap() {
            gameMode = MODE.FIELD;
            worldMapOverlay.classList.remove('active');

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ï¼ˆsetTimeoutã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚clearTimeoutã§åœæ­¢ï¼‰
            if (worldMapAnimationId) {
                clearTimeout(worldMapAnimationId);
                worldMapAnimationId = null;
            }
        }

        // åºƒå¤§ãƒãƒƒãƒ—ç”¨ã®éƒ¨åˆ†è¡¨ç¤ºè¨­å®š
        let worldMapViewport = {
            usePartialView: false,
            viewSize: 100,      // éƒ¨åˆ†è¡¨ç¤ºæ™‚ã®è¡¨ç¤ºç¯„å›²ï¼ˆã‚¿ã‚¤ãƒ«æ•°ï¼‰
            offsetX: 0,
            offsetY: 0,
            tileSize: 4
        };

        function renderWorldMap() {
            const mapData = currentMap.data;
            const rows = currentMap.rows;
            const cols = currentMap.cols;

            // è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆæœ€å¤§ã‚µã‚¤ã‚ºã‚’è¨­å®šï¼‰
            const maxWidth = Math.min(window.innerWidth * 0.7, 500);
            const maxHeight = Math.min(window.innerHeight * 0.5, 400);

            // åºƒå¤§ãƒãƒƒãƒ—åˆ¤å®šï¼ˆ100x100ä»¥ä¸Šã¯éƒ¨åˆ†è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ï¼‰
            const isLargeMap = cols > 100 || rows > 100;
            worldMapViewport.usePartialView = isLargeMap;

            let displayCols, displayRows, tileSize;

            if (isLargeMap) {
                // åºƒå¤§ãƒãƒƒãƒ—: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨è¾ºã®ã¿è¡¨ç¤º
                const viewSize = worldMapViewport.viewSize;
                displayCols = Math.min(cols, viewSize);
                displayRows = Math.min(rows, viewSize);

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸­å¿ƒã«ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
                worldMapViewport.offsetX = Math.max(0, Math.min(cols - displayCols, player.x - Math.floor(displayCols / 2)));
                worldMapViewport.offsetY = Math.max(0, Math.min(rows - displayRows, player.y - Math.floor(displayRows / 2)));

                // ã‚¿ã‚¤ãƒ«ã‚µã‚¤ã‚ºè¨ˆç®—ï¼ˆæœ€å°1pxï¼‰
                const tileW = Math.floor(maxWidth / displayCols);
                const tileH = Math.floor(maxHeight / displayRows);
                tileSize = Math.max(1, Math.min(tileW, tileH, 6));
            } else {
                // é€šå¸¸ãƒãƒƒãƒ—: å…¨ä½“è¡¨ç¤º
                displayCols = cols;
                displayRows = rows;
                worldMapViewport.offsetX = 0;
                worldMapViewport.offsetY = 0;

                // ã‚¿ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’è‡ªå‹•è¨ˆç®—ï¼ˆæœ€å°1pxã€å¤§ãã„ãƒãƒƒãƒ—ã¯ç¸®å°ï¼‰
                const tileW = Math.floor(maxWidth / cols);
                const tileH = Math.floor(maxHeight / rows);
                tileSize = Math.max(1, Math.min(tileW, tileH, 10));
            }

            worldMapViewport.tileSize = tileSize;

            const canvasW = displayCols * tileSize;
            const canvasH = displayRows * tileSize;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
            worldMapCanvas.width = canvasW;
            worldMapCanvas.height = canvasH;

            // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆï¼ˆåœ°å½¢ã‚’ä¸€åº¦ã ã‘æç”»ï¼‰
            worldMapOffscreen = document.createElement('canvas');
            worldMapOffscreen.width = canvasW;
            worldMapOffscreen.height = canvasH;
            worldMapOffscreenCtx = worldMapOffscreen.getContext('2d');

            // åœ°å½¢ã‚’æç”»ï¼ˆè¡¨ç¤ºç¯„å›²ã®ã¿ï¼‰
            const startCol = worldMapViewport.offsetX;
            const startRow = worldMapViewport.offsetY;
            const endCol = startCol + displayCols;
            const endRow = startRow + displayRows;

            for (let row = startRow; row < endRow && row < rows; row++) {
                for (let col = startCol; col < endCol && col < cols; col++) {
                    const tile = mapData[row][col];
                    const color = WORLD_MAP_COLORS[tile] || '#333333';
                    worldMapOffscreenCtx.fillStyle = color;
                    const drawX = (col - startCol) * tileSize;
                    const drawY = (row - startRow) * tileSize;
                    worldMapOffscreenCtx.fillRect(drawX, drawY, tileSize, tileSize);
                }
            }

            // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆå°ã•ã„ãƒãƒƒãƒ—ã‹ã¤ã‚¿ã‚¤ãƒ«ãŒ4pxä»¥ä¸Šã®å ´åˆã®ã¿ï¼‰
            if (displayCols <= 30 && displayRows <= 30 && tileSize >= 4) {
                worldMapOffscreenCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                worldMapOffscreenCtx.lineWidth = 0.5;
                for (let row = 0; row <= displayRows; row++) {
                    worldMapOffscreenCtx.beginPath();
                    worldMapOffscreenCtx.moveTo(0, row * tileSize);
                    worldMapOffscreenCtx.lineTo(canvasW, row * tileSize);
                    worldMapOffscreenCtx.stroke();
                }
                for (let col = 0; col <= displayCols; col++) {
                    worldMapOffscreenCtx.beginPath();
                    worldMapOffscreenCtx.moveTo(col * tileSize, 0);
                    worldMapOffscreenCtx.lineTo(col * tileSize, canvasH);
                    worldMapOffscreenCtx.stroke();
                }
            }

            // åºƒå¤§ãƒãƒƒãƒ—ã®å ´åˆã€è¡¨ç¤ºç¯„å›²ã®å¢ƒç•Œã‚’ç¤ºã™æ ã‚’æç”»
            if (isLargeMap) {
                worldMapOffscreenCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                worldMapOffscreenCtx.lineWidth = 2;
                worldMapOffscreenCtx.strokeRect(1, 1, canvasW - 2, canvasH - 2);

                // ãƒãƒƒãƒ—å…¨ä½“ã§ã®ä½ç½®ã‚’ç¤ºã™ãƒŸãƒ‹ãƒãƒƒãƒ—ï¼ˆå³ä¸Šã«å°ã•ãï¼‰
                const miniSize = 50;
                const miniTileW = miniSize / cols;
                const miniTileH = miniSize / rows;
                const miniX = canvasW - miniSize - 5;
                const miniY = 5;

                // ãƒŸãƒ‹ãƒãƒƒãƒ—èƒŒæ™¯
                worldMapOffscreenCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                worldMapOffscreenCtx.fillRect(miniX - 2, miniY - 2, miniSize + 4, miniSize + 4);

                // ãƒŸãƒ‹ãƒãƒƒãƒ—ä¸Šã®ç¾åœ¨è¡¨ç¤ºç¯„å›²
                worldMapOffscreenCtx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                worldMapOffscreenCtx.fillRect(miniX, miniY, miniSize, miniSize);

                worldMapOffscreenCtx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                worldMapOffscreenCtx.fillRect(
                    miniX + startCol * miniTileW,
                    miniY + startRow * miniTileH,
                    displayCols * miniTileW,
                    displayRows * miniTileH
                );

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ï¼ˆèµ¤ç‚¹ï¼‰
                worldMapOffscreenCtx.fillStyle = '#ff3333';
                worldMapOffscreenCtx.beginPath();
                worldMapOffscreenCtx.arc(
                    miniX + player.x * miniTileW,
                    miniY + player.y * miniTileH,
                    2, 0, Math.PI * 2
                );
                worldMapOffscreenCtx.fill();
            }

            // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‹ã‚‰è»¢é€
            worldMapCtx.drawImage(worldMapOffscreen, 0, 0);
        }

        function startPlayerMarkerAnimation() {
            const tileSize = worldMapViewport.tileSize;

            function animateMarker() {
                // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚’å†æç”»
                worldMapCtx.drawImage(worldMapOffscreen, 0, 0);

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’æç”»ï¼ˆç‚¹æ»…ï¼‰- éƒ¨åˆ†è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
                if (playerBlinkState) {
                    // éƒ¨åˆ†è¡¨ç¤ºã®å ´åˆã¯ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è€ƒæ…®
                    const displayX = player.x - worldMapViewport.offsetX;
                    const displayY = player.y - worldMapViewport.offsetY;

                    // è¡¨ç¤ºç¯„å›²å†…ã«ã„ã‚‹å ´åˆã®ã¿æç”»
                    const cols = worldMapViewport.usePartialView ? worldMapViewport.viewSize : currentMap.cols;
                    const rows = worldMapViewport.usePartialView ? worldMapViewport.viewSize : currentMap.rows;

                    if (displayX >= 0 && displayX < cols && displayY >= 0 && displayY < rows) {
                        const px = displayX * tileSize + tileSize / 2;
                        const py = displayY * tileSize + tileSize / 2;
                        const radius = Math.max(2, tileSize * 0.6);

                        // å¤–å´ã®å…‰å½©
                        worldMapCtx.beginPath();
                        worldMapCtx.arc(px, py, radius + 2, 0, Math.PI * 2);
                        worldMapCtx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                        worldMapCtx.fill();

                        // ä¸­å¿ƒã®ãƒãƒ¼ã‚«ãƒ¼
                        worldMapCtx.beginPath();
                        worldMapCtx.arc(px, py, radius, 0, Math.PI * 2);
                        worldMapCtx.fillStyle = '#ff3333';
                        worldMapCtx.fill();
                        worldMapCtx.strokeStyle = '#ffffff';
                        worldMapCtx.lineWidth = 1;
                        worldMapCtx.stroke();
                    }
                }

                playerBlinkState = !playerBlinkState;

                if (gameMode === MODE.MAP_VIEW) {
                    worldMapAnimationId = setTimeout(() => {
                        requestAnimationFrame(animateMarker);
                    }, 400); // 400msã”ã¨ã«ç‚¹æ»…
                }
            }

            animateMarker();
        }

        // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        worldMapOverlay.addEventListener('click', () => {
            if (gameMode === MODE.MAP_VIEW) {
                closeWorldMap();
            }
        });

        // ğŸ“ãƒœã‚¿ãƒ³ã®è¦ç´ ã¨ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        const mapPinBtn = document.getElementById('mapPinBtn');

        mapPinBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameMode === MODE.FIELD || gameMode === MODE.MENU || gameMode === MODE.DIALOG) {
                openWorldMap();
            }
        });

        // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ğŸ“ãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’æ›´æ–°
        function updateMapPinVisibility() {
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ã®ãƒãƒƒãƒ—ã§ã®ã¿ğŸ“ã‚’è¡¨ç¤º
            const showPin = currentMap && (currentMap.type === 'field' || currentMap.cols >= 20 || currentMap.rows >= 20);
            if (showPin) {
                mapPinBtn.classList.remove('hidden');
            } else {
                mapPinBtn.classList.add('hidden');
            }
        }

        // ãƒ•ãƒ­ã‚¢è¡¨ç¤ºã‚’æ›´æ–°
        const floorDisplayElement = document.getElementById('floorDisplay');
        function updateFloorDisplay() {
            if (!currentMap || currentMap.floor === undefined) {
                floorDisplayElement.textContent = '';
                return;
            }

            const floor = currentMap.floor;
            if (floor > 0) {
                // å¡”ãªã©ã®ä¸Šå±¤éš
                floorDisplayElement.textContent = `${floor}F`;
            } else if (floor < 0) {
                // åœ°ä¸‹éš
                floorDisplayElement.textContent = `B${Math.abs(floor)}F`;
            } else {
                // 0éšï¼ˆåœ°ä¸Šï¼‰
                floorDisplayElement.textContent = '';
            }
        }

        // ========================================
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢
        // ========================================
        const titleScreen = document.getElementById('titleScreen');
        const menuContinue = document.getElementById('menu-continue');
        const menuNewGame = document.getElementById('menu-newgame');
        const pressStart = document.getElementById('pressStart');
        const titleMenu = document.querySelector('.title-menu');

        function checkSaveData() {
            const savedData = localStorage.getItem(SAVE_KEY);
            hasSaveData = savedData !== null;
            return hasSaveData;
        }

        function initTitleScreen() {
            checkSaveData();

            if (hasSaveData) {
                menuContinue.style.display = 'flex';
                titleMenuIndex = 0; // ç¶šãã‹ã‚‰ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            } else {
                menuContinue.style.display = 'none';
                titleMenuIndex = 0;
            }

            titleMenuActive = false;
            debugToggleCount = 0;  // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒªã‚»ãƒƒãƒˆ
            pressStart.style.display = 'block';
            titleMenu.classList.remove('active');
            updateTitleMenuSelection();

            // ã‚µã‚¦ãƒ³ãƒ‰ãƒˆã‚°ãƒ«ã‚¢ã‚¤ã‚³ãƒ³åˆæœŸåŒ–
            updateSoundToggleIcon();

            // ã‚µã‚¦ãƒ³ãƒ‰ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            const soundToggleBtn = document.getElementById('soundToggle');
            if (soundToggleBtn) {
                soundToggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’é˜»æ­¢
                    initAudio();
                    toggleSound();
                    // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§20å›åˆ‡ã‚Šæ›¿ãˆã‚‹ã¨ãƒ‡ãƒãƒƒã‚°ã‚»ãƒ¼ãƒ–ä½œæˆ
                    const titleScreen = document.getElementById('titleScreen');
                    if (titleScreen && !titleScreen.classList.contains('hidden')) {
                        debugToggleCount++;
                        if (debugToggleCount === 20) {
                            createDebugSaveData();
                            debugToggleCount = 0;
                        }
                    }
                });
            }
        }

        // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚¨ãƒªã‚¢3ã‚¯ãƒªã‚¢çŠ¶æ…‹ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä½œæˆ
        function createDebugSaveData() {
            resetGameState().then(async () => {
                // ãƒ’ãƒ¼ãƒ­ãƒ¼ã‚’å¼·åŒ–
                party[0].level = 40;
                party[0].exp = 50000;
                party[0].maxHp = 200;
                party[0].hp = 200;
                party[0].maxMp = 80;
                party[0].mp = 80;
                party[0].equipment = { weapon: 35, armor: 43, accessory: 51 };

                // ãƒãƒªã‚¢ï¼ˆé­”æ³•ä½¿ã„ï¼‰ã‚’è¿½åŠ 
                const mage = createPartyMember({
                    id: 'mage_maria',
                    name: 'ãƒãƒªã‚¢',
                    job: 'mage',
                    sprite: 'ğŸ§™',
                    hp: 120,
                    maxHp: 120,
                    mp: 150,
                    maxMp: 150,
                    baseAtk: 25,
                    baseDef: 20,
                    speed: 12,
                    level: 38,
                    exp: 45000,
                    spells: ['mera', 'gira', 'hoimi', 'merami', 'giragira', 'behoimi'],
                    equipment: { weapon: 42, armor: 44, accessory: null }
                });
                party.push(mage);

                // ã‚»ãƒ¬ãƒ³ï¼ˆæ˜Ÿèª­ã¿ï¼‰ã‚’è¿½åŠ 
                const seren = createPartyMember({
                    id: 'seer_seren',
                    name: 'ã‚»ãƒ¬ãƒ³',
                    job: 'seer',
                    sprite: 'ğŸ”®',
                    hp: 100,
                    maxHp: 100,
                    mp: 180,
                    maxMp: 180,
                    baseAtk: 20,
                    baseDef: 18,
                    speed: 18,
                    level: 36,
                    exp: 40000,
                    spells: ['rukani', 'rariho', 'piorimu', 'hoimi', 'behoimi'],
                    equipment: { weapon: null, armor: 44, accessory: null }
                });
                party.push(seren);

                updateActualStats();
                partyData.gold = 50000;

                // ãƒ•ãƒ©ã‚°è¨­å®š
                gameProgress.storyFlags.mageJoined = true;
                gameProgress.storyFlags.serenJoined = true;
                gameProgress.quests.serenJoin.joined = true;
                gameProgress.bossDefeated.shadowGuardian = true;
                gameProgress.storyFlags.shadowGuardianDefeated = true;
                gameProgress.storyFlags.northPathOpened = true;
                gameProgress.storyFlags.area3Completed = true;

                // ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã‚’surface_3åŒ—å´ï¼ˆã‚¨ãƒªã‚¢4å…¥å£ä»˜è¿‘ï¼‰ã«è¨­å®š
                currentMapPath = 'maps/surface_3.json';
                partyData.x = 49;
                partyData.y = 2;
                partyData.direction = 'up';
                await loadMapFromPath(currentMapPath);

                // ã‚»ãƒ¼ãƒ–
                saveGame();
                alert('ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå®Œäº†');
                location.reload();
            });
        }

        function updateTitleMenuSelection() {
            const items = titleMenu.querySelectorAll('.menu-item');
            items.forEach((item, index) => {
                if (item.style.display !== 'none') {
                    const actualIndex = hasSaveData ? index : index - 1;
                    item.classList.toggle('selected', actualIndex === titleMenuIndex || (!hasSaveData && index === 1 && titleMenuIndex === 0));
                }
            });
        }

        function activateTitleMenu() {
            if (titleMenuActive) return;
            titleMenuActive = true;
            pressStart.style.display = 'none';
            titleMenu.classList.add('active');
            updateTitleMenuSelection();
            // ã‚¿ã‚¤ãƒˆãƒ«BGMé–‹å§‹ï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼šå°‘ã—é…å»¶ã•ã›ã¦ç¢ºå®Ÿã«å†ç”Ÿï¼‰
            setTimeout(() => {
                BGM.play('title');
            }, 100);
        }

        async function selectTitleMenuItem() {
            if (!titleMenuActive) {
                activateTitleMenu();
                return;
            }

            // console.log('[DEBUG] selectTitleMenuItemé–‹å§‹');
            // console.log('[DEBUG] hasSaveData:', hasSaveData, 'titleMenuIndex:', titleMenuIndex);

            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            const fadeOverlay = document.getElementById('fadeOverlay');
            fadeOverlay.classList.add('active');

            await new Promise(resolve => setTimeout(resolve, 300));

            // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’éè¡¨ç¤º
            titleScreen.classList.add('hidden');
            gameMode = MODE.FIELD;
            // console.log('[DEBUG] gameModeå¤‰æ›´:', gameMode);

            if (hasSaveData && titleMenuIndex === 0) {
                // ç¶šãã‹ã‚‰
                // console.log('[DEBUG] ç¶šãã‹ã‚‰ã‚’é¸æŠ');
                await loadGame();
            } else {
                // ã¯ã˜ã‚ã‹ã‚‰ï¼ˆã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ï¼‰
                // console.log('[DEBUG] ã¯ã˜ã‚ã‹ã‚‰ã‚’é¸æŠ');
                localStorage.removeItem(SAVE_KEY);
                await resetGameState();
                updateActualStats();
                // console.log('[DEBUG] resetGameStateå®Œäº†');
                // console.log('[DEBUG] currentMap:', currentMap);
                // console.log('[DEBUG] currentMap.dataå­˜åœ¨:', !!currentMap.data, 'rows:', currentMap.rows, 'cols:', currentMap.cols);
                // console.log('[DEBUG] player:', player.x, player.y);
            }

            // ãƒãƒƒãƒ—åã‚’æ›´æ–°
            document.getElementById('mapName').textContent = currentMap.name || 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰';
            updateMapNameColor();
            updateMapPinVisibility();
            updateFloorDisplay();

            // BGMé–‹å§‹
            BGM.play(BGM.getBgmTypeForMap(currentMap));

            // console.log('[DEBUG] resizeå‰ tileSize:', tileSize, 'canvasWidth:', canvasWidth);
            resize();
            // console.log('[DEBUG] resizeå¾Œ tileSize:', tileSize, 'canvasWidth:', canvasWidth);
            updateCamera();
            // console.log('[DEBUG] updateCameraå¾Œ cameraX:', cameraX, 'cameraY:', cameraY);

            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
            await new Promise(resolve => setTimeout(resolve, 100));
            fadeOverlay.classList.remove('active');
            // console.log('[DEBUG] ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†, gameMode:', gameMode);
        }

        async function resetGameState() {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ’ãƒ¼ãƒ­ãƒ¼ã®ã¿ï¼‰
            party.length = 0;
            const hero = createPartyMember({
                id: 'hero',
                name: 'ã‚†ã†ã—ã‚ƒ',
                job: 'hero',
                sprite: 'ğŸ§™',
                hp: 30,
                maxHp: 30,
                mp: 10,
                maxMp: 10,
                baseAtk: 12,
                baseDef: 8,
                speed: 6,
                level: 1,
                exp: 0,
                spells: [],
                equipment: { weapon: 10, armor: 20 }
            });
            party.push(hero);
            player = party[0];
            setupPlayerProxy();

            // partyDataã‚’ãƒªã‚»ãƒƒãƒˆ
            partyData.x = 4;
            partyData.y = 11;
            partyData.direction = 'down';
            partyData.moving = false;
            partyData.gold = 50;
            partyData.inventory = [{ id: 1, quantity: 3 }];

            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
            updateActualStats();

            // ãƒãƒƒãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå¤–éƒ¨JSONã‚’å„ªå…ˆã—ã¦ãƒ­ãƒ¼ãƒ‰ï¼‰
            currentMapId = 'field';
            currentMapPath = 'maps/field.json';

            try {
                const mapData = await loadMapFromDatabase(currentMapPath);
                // å¤–éƒ¨JSONãƒãƒƒãƒ—ã§ã‚ã‚‹ã“ã¨ã‚’ãƒãƒ¼ã‚¯
                mapData._isExternal = true;
                currentMap = {
                    data: mapData.data.map(row => [...row]),
                    cols: mapData.cols,
                    rows: mapData.rows,
                    npcs: JSON.parse(JSON.stringify(mapData.npcs || [])),
                    chests: JSON.parse(JSON.stringify(mapData.chests || [])),
                    warps: mapData.warps ? [...mapData.warps] : [],
                    name: mapData.name,
                    type: mapData.type,
                    encounterRate: mapData.encounterRate,
                    mapId: mapData.mapId,
                    _isExternal: true
                };
                maps[mapData.mapId] = mapData;
            } catch (err) {
                console.error('ãƒãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ã€å†…è”µãƒãƒƒãƒ—ã‚’ä½¿ç”¨:', err);
                const fieldMap = maps.field;
                currentMap = {
                    data: fieldMap.data.map(row => [...row]),
                    cols: fieldMap.cols,
                    rows: fieldMap.rows,
                    npcs: JSON.parse(JSON.stringify(fieldMap.npcs)),
                    chests: JSON.parse(JSON.stringify(fieldMap.chests)),
                    warps: fieldMap.warps ? [...fieldMap.warps] : [],
                    name: fieldMap.name,
                    type: fieldMap.type,
                    encounterRate: fieldMap.encounterRate
                };
            }

            // å®ç®±ã®é–‹å°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå†…éƒ¨ãƒãƒƒãƒ—ç”¨ï¼‰
            for (const mapId in maps) {
                if (maps[mapId].chests) {
                    maps[mapId].chests.forEach(chest => chest.isOpened = false);
                }
            }

            // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            if (typeof gameCleared !== 'undefined') {
                gameCleared = false;
            }
            // ã‚²ãƒ¼ãƒ é€²è¡Œãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            resetGameProgress();
        }

        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        menuContinue.addEventListener('click', () => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            if (gameMode === MODE.TITLE) {
                titleMenuIndex = 0;
                updateTitleMenuSelection();
                selectTitleMenuItem();
            }
        });

        menuNewGame.addEventListener('click', () => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            if (gameMode === MODE.TITLE) {
                titleMenuIndex = hasSaveData ? 1 : 0;
                updateTitleMenuSelection();
                selectTitleMenuItem();
            }
        });

        titleScreen.addEventListener('click', (e) => {
            initAudio(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’åˆæœŸåŒ–
            if (gameMode === MODE.TITLE && !titleMenuActive) {
                activateTitleMenu();
            }
        });

        // ========================================
        // åˆæœŸåŒ–
        // ========================================
        window.addEventListener('resize', resize);

        // éåŒæœŸåˆæœŸåŒ–
        async function initGame() {
            initTitleScreen();
            resize();
            gameLoop();
        }

        initGame();
        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>
