<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Number Link - Lumina</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 25%, #0d1b2a 50%, #1b0a28 75%, #0a0a1a 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            padding: 10px;
            overflow: hidden;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .header {
            text-align: center;
            margin-bottom: 10px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            letter-spacing: 4px;
        }
        .stage-info {
            font-size: 18px;
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
            margin-top: 5px;
        }
        .back-link {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #88ccff;
            text-decoration: none;
            font-size: 14px;
            padding: 8px 12px;
            border: 1px solid #88ccff;
            border-radius: 6px;
            transition: all 0.3s;
            z-index: 100;
        }
        .back-link:hover {
            background: rgba(136, 204, 255, 0.2);
        }
        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-canvas {
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
        }
        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .btn {
            padding: 10px 20px;
            font-size: 14px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        .btn-reset {
            background: rgba(255, 100, 100, 0.2);
            border-color: #ff6666;
            color: #ff6666;
            text-shadow: 0 0 10px #ff6666;
        }
        .btn-reset:hover {
            background: rgba(255, 100, 100, 0.4);
        }
        .btn-new {
            background: rgba(255, 200, 100, 0.2);
            border-color: #ffcc66;
            color: #ffcc66;
            text-shadow: 0 0 10px #ffcc66;
        }
        .btn-new:hover {
            background: rgba(255, 200, 100, 0.4);
        }
        #clear-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #clear-popup.show {
            display: flex;
        }
        .clear-content {
            text-align: center;
            animation: popIn 0.5s ease;
        }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .clear-text {
            font-size: 64px;
            font-weight: bold;
            color: #00ffcc;
            text-shadow: 0 0 30px #00ffcc, 0 0 60px #00ffcc;
            margin-bottom: 30px;
        }
        .clear-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: rgba(0, 255, 204, 0.2);
            border: 2px solid #00ffcc;
            color: #00ffcc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .clear-btn:hover {
            background: rgba(0, 255, 204, 0.4);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <div class="header">
        <h1 class="title">NUMBER LINK</h1>
        <div class="stage-info" id="stage-info">STAGE 1</div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div class="buttons">
            <button class="btn btn-reset" id="reset-btn">RESET</button>
            <button class="btn btn-new" id="new-btn">NEW GAME</button>
        </div>
    </div>

    <div id="clear-popup">
        <div class="clear-content">
            <div class="clear-text">CLEAR!</div>
            <button class="clear-btn" id="next-btn">Next Stage</button>
        </div>
    </div>

    <script>
        // ============================================
        // ゲーム設定
        // ============================================
        const COLORS = [
            '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3',
            '#dda0dd', '#87ceeb', '#ffa07a', '#98fb98',
            '#f0e68c', '#deb887', '#bc8f8f', '#add8e6',
            '#ffb6c1', '#e6e6fa', '#ffdab9', '#b0c4de',
            '#98d8c8', '#f5deb3'
        ];

        const STORAGE_KEY = 'numberlink_save';

        // ============================================
        // ゲーム状態
        // ============================================
        let currentStage = 1;
        let gridSize = 5;
        let cellSize = 50;
        let padding = 6;
        let gap = 2;
        let canvasSize = 0;

        let grid = [];
        let endpoints = [];
        let paths = {};
        let currentPath = null;
        let currentPathId = null;
        let isDrawing = false;

        // Canvas関連
        let canvas, ctx;

        // ============================================
        // ステージ設定
        // ============================================
        function getStageConfig(stage) {
            if (stage <= 2) return { gridSize: 5, pairCount: 4 + stage };
            if (stage <= 4) return { gridSize: 6, pairCount: 5 + stage };
            if (stage <= 6) return { gridSize: 7, pairCount: 6 + stage };
            if (stage <= 9) return { gridSize: 8, pairCount: 8 + Math.floor(stage / 2) };
            return { gridSize: 9, pairCount: Math.min(12 + Math.floor(stage / 3), 18) };
        }

        // ============================================
        // Canvas初期化
        // ============================================
        function initCanvas() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');

            calculateSizes();
            setupEventListeners();
        }

        function calculateSizes() {
            const maxWidth = Math.min(window.innerWidth - 40, 400);
            const maxHeight = window.innerHeight - 220;
            const maxGridSize = Math.min(maxWidth, maxHeight);

            cellSize = Math.floor((maxGridSize - padding * 2 - gap * (gridSize - 1)) / gridSize);
            cellSize = Math.max(cellSize, 35);

            canvasSize = cellSize * gridSize + gap * (gridSize - 1) + padding * 2;

            canvas.width = canvasSize;
            canvas.height = canvasSize;
            canvas.style.width = canvasSize + 'px';
            canvas.style.height = canvasSize + 'px';
        }

        // ============================================
        // イベントリスナー
        // ============================================
        function setupEventListeners() {
            // Pointer Events (統一されたマウス/タッチ処理)
            canvas.addEventListener('pointerdown', handlePointerDown);
            canvas.addEventListener('pointermove', handlePointerMove);
            canvas.addEventListener('pointerup', handlePointerUp);
            canvas.addEventListener('pointercancel', handlePointerUp);
            canvas.addEventListener('pointerleave', handlePointerUp);

            // ボタン
            document.getElementById('reset-btn').addEventListener('click', resetPuzzle);
            document.getElementById('new-btn').addEventListener('click', newGame);
            document.getElementById('next-btn').addEventListener('click', nextStage);

            // リサイズ
            window.addEventListener('resize', () => {
                calculateSizes();
                render();
            });
        }

        // ============================================
        // 座標計算
        // ============================================
        function getGridPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const x = Math.floor((canvasX - padding) / (cellSize + gap));
            const y = Math.floor((canvasY - padding) / (cellSize + gap));

            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                return { x, y };
            }
            return null;
        }

        // ============================================
        // ポインターイベント処理
        // ============================================
        function handlePointerDown(e) {
            e.preventDefault();
            canvas.setPointerCapture(e.pointerId);

            const pos = getGridPosition(e.clientX, e.clientY);
            if (!pos) return;

            const cellData = grid[pos.y][pos.x];

            if (cellData.isEndpoint) {
                // 端点から開始
                currentPathId = cellData.endpointId;
                clearPath(currentPathId);
                currentPath = [{ x: pos.x, y: pos.y }];
                paths[currentPathId] = currentPath;
                grid[pos.y][pos.x].pathId = currentPathId;
                isDrawing = true;
                render();
            } else if (cellData.pathId) {
                // 既存のパスから開始
                currentPathId = cellData.pathId;
                const path = paths[currentPathId];
                const idx = path.findIndex(p => p.x === pos.x && p.y === pos.y);
                if (idx !== -1) {
                    const removed = path.splice(idx + 1);
                    for (const cell of removed) {
                        if (!grid[cell.y][cell.x].isEndpoint || grid[cell.y][cell.x].endpointId !== currentPathId) {
                            grid[cell.y][cell.x].pathId = null;
                        }
                    }
                    currentPath = path;
                    isDrawing = true;
                    render();
                }
            }
        }

        function handlePointerMove(e) {
            if (!isDrawing || !currentPath) return;
            e.preventDefault();

            const pos = getGridPosition(e.clientX, e.clientY);
            if (!pos) return;

            const lastPos = currentPath[currentPath.length - 1];
            if (pos.x === lastPos.x && pos.y === lastPos.y) return;

            // 隣接チェック
            const dx = Math.abs(pos.x - lastPos.x);
            const dy = Math.abs(pos.y - lastPos.y);
            if (dx + dy !== 1) return;

            const cellData = grid[pos.y][pos.x];

            // 戻る場合
            if (currentPath.length >= 2) {
                const prevPos = currentPath[currentPath.length - 2];
                if (pos.x === prevPos.x && pos.y === prevPos.y) {
                    const removed = currentPath.pop();
                    if (!grid[removed.y][removed.x].isEndpoint || grid[removed.y][removed.x].endpointId !== currentPathId) {
                        grid[removed.y][removed.x].pathId = null;
                    }
                    render();
                    return;
                }
            }

            // 自分のパスには戻れない
            if (cellData.pathId === currentPathId) return;

            // 他のパスを上書き
            if (cellData.pathId && cellData.pathId !== currentPathId) {
                clearPath(cellData.pathId);
            }

            // 端点に到達
            if (cellData.isEndpoint) {
                if (cellData.endpointId === currentPathId) {
                    currentPath.push({ x: pos.x, y: pos.y });
                    grid[pos.y][pos.x].pathId = currentPathId;
                    isDrawing = false;
                    render();
                    saveGame();
                    checkClear();
                    return;
                }
                return;
            }

            // パスを追加
            currentPath.push({ x: pos.x, y: pos.y });
            grid[pos.y][pos.x].pathId = currentPathId;
            render();
        }

        function handlePointerUp(e) {
            if (isDrawing) {
                saveGame();
            }
            isDrawing = false;
            currentPath = null;
            currentPathId = null;
        }

        // ============================================
        // 描画
        // ============================================
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // セルの描画
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    drawCell(x, y);
                }
            }

            // パスの描画
            for (const pathId of Object.keys(paths)) {
                drawPath(parseInt(pathId));
            }

            // 端点の描画
            for (const ep of endpoints) {
                for (const cell of ep.cells) {
                    drawEndpoint(cell.x, cell.y, ep.id, ep.color);
                }
            }
        }

        function getCellRect(x, y) {
            return {
                x: padding + x * (cellSize + gap),
                y: padding + y * (cellSize + gap),
                w: cellSize,
                h: cellSize
            };
        }

        function drawCell(x, y) {
            const rect = getCellRect(x, y);
            ctx.fillStyle = 'rgba(30, 30, 50, 0.8)';
            ctx.beginPath();
            ctx.roundRect(rect.x, rect.y, rect.w, rect.h, 4);
            ctx.fill();
        }

        function drawPath(pathId) {
            const path = paths[pathId];
            if (!path || path.length < 1) return;

            const ep = endpoints.find(e => e.id === pathId);
            if (!ep) return;

            ctx.strokeStyle = ep.color;
            ctx.lineWidth = cellSize * 0.3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.7;

            ctx.beginPath();
            for (let i = 0; i < path.length; i++) {
                const rect = getCellRect(path[i].x, path[i].y);
                const cx = rect.x + rect.w / 2;
                const cy = rect.y + rect.h / 2;

                if (i === 0) {
                    ctx.moveTo(cx, cy);
                } else {
                    ctx.lineTo(cx, cy);
                }
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawEndpoint(x, y, id, color) {
            const rect = getCellRect(x, y);
            const cx = rect.x + rect.w / 2;
            const cy = rect.y + rect.h / 2;
            const radius = cellSize * 0.35;

            // 円
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // 番号
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${cellSize * 0.35}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(id.toString(), cx, cy);
            ctx.shadowBlur = 0;
        }

        // ============================================
        // パズル生成（解が必ず存在することを保証）
        // ============================================
        function initGrid() {
            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = { pathId: null, isEndpoint: false, endpointId: null };
                }
            }
        }

        function generatePuzzle() {
            const config = getStageConfig(currentStage);
            gridSize = config.gridSize;
            const targetPairs = config.pairCount;

            calculateSizes();

            // 解が存在するパズルが生成されるまで繰り返す
            let maxGlobalAttempts = 50;
            while (maxGlobalAttempts > 0) {
                maxGlobalAttempts--;

                if (tryGeneratePuzzle(targetPairs)) {
                    return; // 成功
                }
            }

            // 最終手段：より少ないペア数で生成
            for (let pairs = targetPairs - 1; pairs >= 3; pairs--) {
                if (tryGeneratePuzzle(pairs)) {
                    return;
                }
            }
        }

        function tryGeneratePuzzle(targetPairs) {
            initGrid();
            endpoints = [];
            paths = {};

            // 全セルを管理する配列
            const cellOwner = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

            let pathId = 1;
            let attempts = 0;
            const maxAttempts = 300;

            // フェーズ1: パスを生成してグリッド全体を埋める
            while (pathId <= targetPairs && attempts < maxAttempts) {
                attempts++;

                // 空きセルを探す
                const emptyCells = [];
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (cellOwner[y][x] === 0) emptyCells.push({ x, y });
                    }
                }

                if (emptyCells.length < 2) break;

                // ランダムな開始点
                const startIdx = Math.floor(Math.random() * emptyCells.length);
                const start = emptyCells[startIdx];

                const path = [{ x: start.x, y: start.y }];
                const tempOwner = cellOwner.map(row => [...row]);
                tempOwner[start.y][start.x] = pathId;

                let current = { x: start.x, y: start.y };

                // パスを延ばす
                const minLength = 2;
                const maxLength = Math.max(4, Math.floor(gridSize * 2));
                const targetLength = minLength + Math.floor(Math.random() * (maxLength - minLength + 1));

                while (path.length < targetLength) {
                    const shuffledDirs = [...directions].sort(() => Math.random() - 0.5);
                    let moved = false;

                    for (const [dx, dy] of shuffledDirs) {
                        const nx = current.x + dx;
                        const ny = current.y + dy;

                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && tempOwner[ny][nx] === 0) {
                            tempOwner[ny][nx] = pathId;
                            current = { x: nx, y: ny };
                            path.push({ x: nx, y: ny });
                            moved = true;
                            break;
                        }
                    }

                    if (!moved) break;
                }

                // 最低2セル必要
                if (path.length >= minLength) {
                    // cellOwnerを更新
                    for (const cell of path) {
                        cellOwner[cell.y][cell.x] = pathId;
                    }

                    const startCell = path[0];
                    const endCell = path[path.length - 1];

                    endpoints.push({
                        id: pathId,
                        color: COLORS[(pathId - 1) % COLORS.length],
                        cells: [startCell, endCell],
                        solutionPath: [...path]
                    });

                    paths[pathId] = [...path];
                    pathId++;
                    attempts = 0;
                }
            }

            // フェーズ2: 残りの空きセルを既存のパスに割り当てる
            let changed = true;
            while (changed) {
                changed = false;
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (cellOwner[y][x] === 0) {
                            // 隣接するパスを探す
                            const neighbors = [];
                            for (const [dx, dy] of directions) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && cellOwner[ny][nx] > 0) {
                                    neighbors.push(cellOwner[ny][nx]);
                                }
                            }

                            if (neighbors.length > 0) {
                                // ランダムに選択
                                const chosenPathId = neighbors[Math.floor(Math.random() * neighbors.length)];
                                cellOwner[y][x] = chosenPathId;

                                // パスに追加（解の経路を更新）
                                const ep = endpoints.find(e => e.id === chosenPathId);
                                if (ep) {
                                    ep.solutionPath.push({ x, y });
                                }
                                paths[chosenPathId].push({ x, y });
                                changed = true;
                            }
                        }
                    }
                }
            }

            // フェーズ3: まだ空きセルがあるか確認
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (cellOwner[y][x] === 0) {
                        // 空きセルが残っている - 失敗
                        return false;
                    }
                }
            }

            // フェーズ4: グリッドを設定して端点のみ残す
            initGrid();
            for (const ep of endpoints) {
                for (const cell of ep.cells) {
                    grid[cell.y][cell.x].isEndpoint = true;
                    grid[cell.y][cell.x].endpointId = ep.id;
                }
                // パスをクリア（端点情報は保持）
                paths[ep.id] = [];
            }

            return true;
        }

        function resetGridKeepEndpoints() {
            const endpointInfo = endpoints.map(ep => ({
                id: ep.id,
                color: ep.color,
                cells: [...ep.cells]
            }));

            initGrid();
            endpoints = endpointInfo;
            paths = {};

            for (const ep of endpoints) {
                for (const cell of ep.cells) {
                    grid[cell.y][cell.x].isEndpoint = true;
                    grid[cell.y][cell.x].endpointId = ep.id;
                }
                paths[ep.id] = [];
            }
        }

        function clearPath(pathId) {
            const path = paths[pathId];
            if (path) {
                for (const cell of path) {
                    if (!grid[cell.y][cell.x].isEndpoint || grid[cell.y][cell.x].endpointId !== pathId) {
                        grid[cell.y][cell.x].pathId = null;
                    }
                }
            }
            paths[pathId] = [];
        }

        // ============================================
        // クリア判定
        // ============================================
        function checkClear() {
            // すべてのマスが埋まっているか
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    if (!cell.isEndpoint && !cell.pathId) return false;
                }
            }

            // すべてのペアが繋がっているか
            for (const ep of endpoints) {
                const path = paths[ep.id];
                if (!path || path.length < 2) return false;

                const start = path[0];
                const end = path[path.length - 1];
                const epCells = ep.cells;

                const startsAtEndpoint = epCells.some(c => c.x === start.x && c.y === start.y);
                const endsAtEndpoint = epCells.some(c => c.x === end.x && c.y === end.y);

                if (!startsAtEndpoint || !endsAtEndpoint) return false;
                if (start.x === end.x && start.y === end.y) return false;
            }

            document.getElementById('clear-popup').classList.add('show');
            return true;
        }

        // ============================================
        // ゲーム操作
        // ============================================
        function resetPuzzle() {
            resetGridKeepEndpoints();
            render();
            saveGame();
        }

        function newGame() {
            if (confirm('最初からやり直しますか？')) {
                clearSave();
                currentStage = 1;
                document.getElementById('clear-popup').classList.remove('show');
                generatePuzzle();
                render();
                updateStageInfo();
                saveGame();
            }
        }

        function nextStage() {
            currentStage++;
            document.getElementById('clear-popup').classList.remove('show');
            generatePuzzle();
            render();
            updateStageInfo();
            saveGame();
        }

        function updateStageInfo() {
            document.getElementById('stage-info').textContent = `STAGE ${currentStage}`;
        }

        // ============================================
        // セーブ/ロード
        // ============================================
        function saveGame() {
            const saveData = {
                currentStage,
                gridSize,
                grid,
                endpoints,
                paths
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save game:', e);
            }
        }

        function loadGame() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) return JSON.parse(saved);
            } catch (e) {
                console.warn('Failed to load game:', e);
            }
            return null;
        }

        function clearSave() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.warn('Failed to clear save:', e);
            }
        }

        // ============================================
        // 初期化
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas();

            const savedGame = loadGame();
            if (savedGame) {
                currentStage = savedGame.currentStage;
                gridSize = savedGame.gridSize;
                grid = savedGame.grid;
                endpoints = savedGame.endpoints;
                paths = savedGame.paths;
                calculateSizes();
                render();
            } else {
                generatePuzzle();
                render();
                saveGame();
            }

            updateStageInfo();
        });
    </script>
</body>
</html>
