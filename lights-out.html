<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lumina Logic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            touch-action: manipulation;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 25%, #0d1b2a 50%, #1b0a28 75%, #0a0a1a 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        #stage-info {
            color: #ffcc00;
            font-size: 20px;
            text-shadow: 0 0 10px #ffcc00;
            margin-bottom: 10px;
        }
        #instruction {
            color: #88ccff;
            font-size: 24px;
            text-shadow: 0 0 10px #88ccff;
            letter-spacing: 2px;
        }
        #clear-message {
            color: #00ffcc;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #00ffcc, 0 0 40px #00ffcc;
            margin-top: 20px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #clear-message.show {
            opacity: 1;
        }
        #next-stage-hint {
            color: #88ccff;
            font-size: 16px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #next-stage-hint.show {
            opacity: 1;
        }
        #reset-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.2);
            border: 2px solid #ff6666;
            color: #ff6666;
            padding: 12px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            text-shadow: 0 0 10px #ff6666;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
            z-index: 100;
        }
        #reset-btn:hover {
            background: rgba(255, 100, 100, 0.4);
            box-shadow: 0 0 25px rgba(255, 100, 100, 0.5);
        }
        #reset-btn:active {
            transform: translateX(-50%) scale(0.95);
        }
        #hint-btn {
            position: absolute;
            bottom: 30px;
            left: calc(50% + 100px);
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid #66ccff;
            color: #66ccff;
            padding: 12px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            text-shadow: 0 0 10px #66ccff;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
            z-index: 100;
        }
        #hint-btn:hover {
            background: rgba(100, 200, 255, 0.4);
            box-shadow: 0 0 25px rgba(100, 200, 255, 0.5);
        }
        #hint-btn:active {
            transform: scale(0.95);
        }
        #newgame-btn {
            position: absolute;
            bottom: 30px;
            left: calc(50% - 100px);
            transform: translateX(-100%);
            background: rgba(255, 200, 100, 0.2);
            border: 2px solid #ffcc66;
            color: #ffcc66;
            padding: 12px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            text-shadow: 0 0 10px #ffcc66;
            box-shadow: 0 0 15px rgba(255, 200, 100, 0.3);
            z-index: 100;
        }
        #newgame-btn:hover {
            background: rgba(255, 200, 100, 0.4);
            box-shadow: 0 0 25px rgba(255, 200, 100, 0.5);
        }
        #newgame-btn:active {
            transform: translateX(-100%) scale(0.95);
        }
        #reset-btn {
            left: 50%;
            transform: translateX(-50%);
        }
        #reset-btn:active {
            transform: translateX(-50%) scale(0.95);
        }
        canvas {
            display: block;
        }
        .back-link {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #88ccff;
            text-decoration: none;
            font-size: 14px;
            padding: 8px 12px;
            border: 1px solid #88ccff;
            border-radius: 6px;
            transition: all 0.3s;
            z-index: 100;
        }
        .back-link:hover {
            background: rgba(136, 204, 255, 0.2);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div id="ui">
        <div id="stage-info">STAGE 1</div>
        <div id="instruction">すべて点灯させろ</div>
        <div id="clear-message">CLEAR!</div>
        <div id="next-stage-hint">クリックで次のステージへ</div>
    </div>
    <button id="newgame-btn">NEW GAME</button>
    <button id="reset-btn">RESET</button>
    <button id="hint-btn">HINT</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ステージ管理
        let currentStage = 1;
        let isCleared = false;

        // localStorage キー
        const STORAGE_KEY = 'lumina_save';

        // ゲーム状態を保存
        function saveGame() {
            const saveData = {
                currentStage: currentStage,
                cubeStates: cubeStates,
                initialCubeStates: initialCubeStates,
                isCleared: isCleared
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save game:', e);
            }
        }

        // ゲーム状態を読み込み
        function loadGame() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Failed to load game:', e);
            }
            return null;
        }

        // 保存データを削除
        function clearSave() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.warn('Failed to clear save:', e);
            }
        }

        // ステージ設定を取得
        function getStageConfig(stage) {
            // ステージ1: 3x3x3, シャッフル10回
            // ステージ2: 3x3x3, シャッフル15回
            // ステージ3: 4x4x4, シャッフル15回
            // ステージ4: 4x4x4, シャッフル20回
            // ステージ5以降: 5x5x5, シャッフル20+5*(stage-5)回
            if (stage === 1) {
                return { gridSize: 3, shuffleCount: 10 };
            } else if (stage === 2) {
                return { gridSize: 3, shuffleCount: 15 };
            } else if (stage === 3) {
                return { gridSize: 4, shuffleCount: 15 };
            } else if (stage === 4) {
                return { gridSize: 4, shuffleCount: 20 };
            } else {
                return { gridSize: 5, shuffleCount: 20 + 5 * (stage - 5) };
            }
        }

        // シーン、カメラ、レンダラーの設定
        const scene = new THREE.Scene();
        // 背景を透明にしてCSSグラデーションを見せる
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0); // 透明背景
        document.body.appendChild(renderer.domElement);

        // ライトの設定
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // ネオン感を出すためのポイントライト
        const pointLight1 = new THREE.PointLight(0x00ffff, 0.5, 20);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 0.3, 20);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        // 立方体の配列と状態
        let cubes = [];
        let cubeStates = {}; // true = 点灯, false = 消灯
        let initialCubeStates = {}; // ステージ開始時の状態を保存
        const cubeAnimations = {}; // アニメーション状態を管理
        let gridSize = 3;
        const CUBE_SIZE = 0.92;
        const GAP = 0.18;
        let totalSize = CUBE_SIZE + GAP;
        const ANIMATION_DURATION = 0.2; // アニメーション時間（秒）

        // ピボット（回転用）
        const pivot = new THREE.Group();
        scene.add(pivot);

        // マテリアル（ネオン光沢）
        const litMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.92,
            metalness: 0.3,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            reflectivity: 0.9
        });

        const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            linewidth: 2
        });

        // 色の補間用ヘルパー
        const litColor = new THREE.Color(0x00ffff);
        const unlitColor = new THREE.Color(0x222233);
        const litEmissive = new THREE.Color(0x00ffff);
        const unlitEmissive = new THREE.Color(0x111122);

        // カメラ位置を調整
        function adjustCamera() {
            const distance = gridSize * 2.5;
            camera.position.set(distance, distance, distance);
            camera.lookAt(0, 0, 0);
        }

        // 立方体の生成
        function createCube(x, y, z) {
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cube = new THREE.Mesh(geometry, litMaterial.clone());

            // 位置を中心に配置
            const offset = (gridSize - 1) / 2;
            cube.position.set(
                (x - offset) * totalSize,
                (y - offset) * totalSize,
                (z - offset) * totalSize
            );

            // エッジ（白い枠線）の追加
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, edgeMaterial);
            cube.add(line);

            // グリッド座標を保存
            cube.userData = { gridX: x, gridY: y, gridZ: z };

            pivot.add(cube);
            cubes.push(cube);

            const key = `${x},${y},${z}`;
            cubeStates[key] = true; // 初期状態は点灯

            return cube;
        }

        // すべての立方体をクリア
        function clearCubes() {
            cubes.forEach(cube => {
                pivot.remove(cube);
                cube.geometry.dispose();
                cube.material.dispose();
            });
            cubes = [];
            cubeStates = {};
            // アニメーションもクリア
            for (const key in cubeAnimations) {
                delete cubeAnimations[key];
            }
        }

        // ステージを初期化
        function initStage(stage, savedState = null) {
            const config = getStageConfig(stage);
            gridSize = config.gridSize;
            totalSize = CUBE_SIZE + GAP;

            // 古い立方体をクリア
            clearCubes();

            // 新しい立方体を生成（表面のみ）
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        // 表面のブロックのみ生成（少なくとも1つの座標が端にある）
                        const isSurface = x === 0 || x === gridSize - 1 ||
                                          y === 0 || y === gridSize - 1 ||
                                          z === 0 || z === gridSize - 1;
                        if (!isSurface) continue;
                        createCube(x, y, z);
                    }
                }
            }

            // カメラ位置を調整
            adjustCamera();

            // ピボットの回転をリセット
            pivot.rotation.set(0, 0, 0);

            if (savedState) {
                // 保存データから復元
                cubeStates = {...savedState.cubeStates};
                initialCubeStates = {...savedState.initialCubeStates};
                isCleared = savedState.isCleared;
                // ビジュアルを更新
                cubes.forEach(updateCubeVisualInstant);
                if (isCleared) {
                    document.getElementById('clear-message').classList.add('show');
                    document.getElementById('next-stage-hint').classList.add('show');
                }
            } else {
                // シャッフル
                shuffle(config.shuffleCount);
                // 初期状態を保存（リセット用）
                initialCubeStates = {...cubeStates};
                isCleared = false;
            }

            // UI更新
            document.getElementById('stage-info').textContent = `STAGE ${stage}`;
            if (!isCleared) {
                document.getElementById('clear-message').classList.remove('show');
                document.getElementById('next-stage-hint').classList.remove('show');
            }

            // 保存
            saveGame();
        }

        // 立方体の状態を即座に更新（シャッフル用）
        function updateCubeVisualInstant(cube) {
            const { gridX, gridY, gridZ } = cube.userData;
            const key = `${gridX},${gridY},${gridZ}`;
            const isLit = cubeStates[key];

            if (isLit) {
                cube.material.color.setHex(0x00ffff);
                cube.material.emissive.setHex(0x00ffff);
                cube.material.emissiveIntensity = 0.8;
                cube.material.opacity = 0.92;
                cube.material.metalness = 0.3;
                cube.material.roughness = 0.2;
            } else {
                cube.material.color.setHex(0x222233);
                cube.material.emissive.setHex(0x111122);
                cube.material.emissiveIntensity = 0.1;
                cube.material.opacity = 0.6;
                cube.material.metalness = 0.1;
                cube.material.roughness = 0.5;
            }
        }

        // 立方体のアニメーションを開始
        function startCubeAnimation(cube) {
            const { gridX, gridY, gridZ } = cube.userData;
            const key = `${gridX},${gridY},${gridZ}`;
            const targetLit = cubeStates[key];

            // 現在の状態を保存
            cubeAnimations[key] = {
                cube: cube,
                startTime: performance.now(),
                fromColor: cube.material.color.clone(),
                fromEmissive: cube.material.emissive.clone(),
                fromEmissiveIntensity: cube.material.emissiveIntensity,
                fromOpacity: cube.material.opacity,
                fromMetalness: cube.material.metalness,
                fromRoughness: cube.material.roughness,
                toColor: targetLit ? litColor.clone() : unlitColor.clone(),
                toEmissive: targetLit ? litEmissive.clone() : unlitEmissive.clone(),
                toEmissiveIntensity: targetLit ? 0.8 : 0.1,
                toOpacity: targetLit ? 0.92 : 0.6,
                toMetalness: targetLit ? 0.3 : 0.1,
                toRoughness: targetLit ? 0.2 : 0.5
            };
        }

        // アニメーションを更新
        function updateAnimations() {
            const now = performance.now();

            for (const key in cubeAnimations) {
                const anim = cubeAnimations[key];
                const elapsed = (now - anim.startTime) / 1000; // 秒に変換
                const progress = Math.min(elapsed / ANIMATION_DURATION, 1);

                // イージング（ease-out）
                const eased = 1 - Math.pow(1 - progress, 3);

                // 色を補間
                anim.cube.material.color.lerpColors(anim.fromColor, anim.toColor, eased);
                anim.cube.material.emissive.lerpColors(anim.fromEmissive, anim.toEmissive, eased);
                anim.cube.material.emissiveIntensity = anim.fromEmissiveIntensity +
                    (anim.toEmissiveIntensity - anim.fromEmissiveIntensity) * eased;
                anim.cube.material.opacity = anim.fromOpacity +
                    (anim.toOpacity - anim.fromOpacity) * eased;
                anim.cube.material.metalness = anim.fromMetalness +
                    (anim.toMetalness - anim.fromMetalness) * eased;
                anim.cube.material.roughness = anim.fromRoughness +
                    (anim.toRoughness - anim.fromRoughness) * eased;

                // アニメーション完了
                if (progress >= 1) {
                    delete cubeAnimations[key];
                }
            }
        }

        // 状態を反転
        function toggleCube(x, y, z) {
            const key = `${x},${y},${z}`;
            if (cubeStates.hasOwnProperty(key)) {
                cubeStates[key] = !cubeStates[key];
            }
        }

        // クリック処理（隣接する立方体も反転）
        function handleClick(cube) {
            if (isCleared) return; // クリア後は操作不可

            const { gridX, gridY, gridZ } = cube.userData;

            // 自分自身と隣接する6方向を反転
            const directions = [
                [0, 0, 0],   // 自分
                [1, 0, 0],   // 右
                [-1, 0, 0],  // 左
                [0, 1, 0],   // 上
                [0, -1, 0],  // 下
                [0, 0, 1],   // 前
                [0, 0, -1]   // 後
            ];

            directions.forEach(([dx, dy, dz]) => {
                const nx = gridX + dx;
                const ny = gridY + dy;
                const nz = gridZ + dz;

                if (nx >= 0 && nx < gridSize &&
                    ny >= 0 && ny < gridSize &&
                    nz >= 0 && nz < gridSize) {
                    toggleCube(nx, ny, nz);
                }
            });

            // アニメーション付きでビジュアルを更新
            directions.forEach(([dx, dy, dz]) => {
                const nx = gridX + dx;
                const ny = gridY + dy;
                const nz = gridZ + dz;

                if (nx >= 0 && nx < gridSize &&
                    ny >= 0 && ny < gridSize &&
                    nz >= 0 && nz < gridSize) {
                    const targetCube = cubes.find(c =>
                        c.userData.gridX === nx &&
                        c.userData.gridY === ny &&
                        c.userData.gridZ === nz
                    );
                    if (targetCube) {
                        startCubeAnimation(targetCube);
                    }
                }
            });

            // 保存
            saveGame();

            // クリア判定（アニメーション完了後にチェック）
            setTimeout(checkClear, ANIMATION_DURATION * 1000);
        }

        // クリア判定
        function checkClear() {
            if (isCleared) return;

            const allLit = Object.values(cubeStates).every(state => state === true);
            const clearMessage = document.getElementById('clear-message');
            const nextStageHint = document.getElementById('next-stage-hint');

            if (allLit) {
                clearMessage.classList.add('show');
                nextStageHint.classList.add('show');
                isCleared = true;
                saveGame();
            }
        }

        // 次のステージへ
        function nextStage() {
            if (isCleared) {
                currentStage++;
                initStage(currentStage);
            }
        }

        // ヒント機能：Gaussian eliminationで解を求めてブロックを点滅させる
        let hintCube = null;
        let hintBlinking = false;

        // 表面のブロックかどうか判定
        function isSurfaceCube(x, y, z) {
            return x === 0 || x === gridSize - 1 ||
                   y === 0 || y === gridSize - 1 ||
                   z === 0 || z === gridSize - 1;
        }

        // Gaussian elimination (GF(2)) でLights Outパズルを解く
        function solveLightsOut() {
            // 表面のブロックのみを対象にする
            const surfaceCubes = [];
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        if (isSurfaceCube(x, y, z)) {
                            surfaceCubes.push({ x, y, z });
                        }
                    }
                }
            }

            const n = surfaceCubes.length;

            // キューブのインデックスマップを作成
            const cubeIndex = {};
            surfaceCubes.forEach((cube, idx) => {
                cubeIndex[`${cube.x},${cube.y},${cube.z}`] = idx;
            });

            // 拡大係数行列を構築 [A|b]
            // A[i][j] = 1 if clicking cube j affects cube i
            // b[i] = 1 if cube i is currently unlit (needs to be toggled)
            const matrix = [];

            for (let i = 0; i < n; i++) {
                const row = new Array(n + 1).fill(0);
                const { x: ix, y: iy, z: iz } = surfaceCubes[i];

                // 自分自身と隣接6方向のブロックをチェック
                const directions = [
                    [0, 0, 0],
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];

                directions.forEach(([dx, dy, dz]) => {
                    const nx = ix + dx;
                    const ny = iy + dy;
                    const nz = iz + dz;
                    const key = `${nx},${ny},${nz}`;

                    // そのブロックが表面に存在するかチェック
                    if (cubeIndex.hasOwnProperty(key)) {
                        // ブロックjをクリックするとブロックiに影響がある
                        row[cubeIndex[key]] = 1;
                    }
                });

                // b[i]: 消灯なら1（トグルが必要）、点灯なら0
                const key = `${ix},${iy},${iz}`;
                row[n] = cubeStates[key] ? 0 : 1;

                matrix.push(row);
            }

            // Gaussian elimination (GF(2))
            const pivotCol = new Array(n).fill(-1);
            let col = 0;

            for (let row = 0; row < n && col < n; col++) {
                // ピボットを探す
                let pivotRow = -1;
                for (let r = row; r < n; r++) {
                    if (matrix[r][col] === 1) {
                        pivotRow = r;
                        break;
                    }
                }

                if (pivotRow === -1) continue;

                // 行を交換
                [matrix[row], matrix[pivotRow]] = [matrix[pivotRow], matrix[row]];
                pivotCol[col] = row;

                // 他の行からこの列を消去
                for (let r = 0; r < n; r++) {
                    if (r !== row && matrix[r][col] === 1) {
                        for (let c = 0; c <= n; c++) {
                            matrix[r][c] ^= matrix[row][c];
                        }
                    }
                }

                row++;
            }

            // 後退代入で解を求める
            const solution = new Array(n).fill(0);

            for (let c = n - 1; c >= 0; c--) {
                if (pivotCol[c] !== -1) {
                    const row = pivotCol[c];
                    let val = matrix[row][n];
                    for (let c2 = c + 1; c2 < n; c2++) {
                        val ^= (matrix[row][c2] & solution[c2]);
                    }
                    solution[c] = val;
                }
            }

            // 解の中でクリックすべきブロック（solution[i] === 1）を返す
            const clicksNeeded = [];
            for (let i = 0; i < n; i++) {
                if (solution[i] === 1) {
                    clicksNeeded.push(surfaceCubes[i]);
                }
            }

            return clicksNeeded;
        }

        function findHintCube() {
            // Gaussian eliminationで解を求める
            const solution = solveLightsOut();

            if (solution.length === 0) {
                // 解がない、または既にクリア状態
                return null;
            }

            // 解のうち最初のブロックを返す
            const target = solution[0];
            return cubes.find(c =>
                c.userData.gridX === target.x &&
                c.userData.gridY === target.y &&
                c.userData.gridZ === target.z
            );
        }

        function showHint() {
            if (isCleared || hintBlinking) return;

            hintCube = findHintCube();
            if (!hintCube) return;

            hintBlinking = true;
            let blinkCount = 0;
            const originalColor = hintCube.material.color.clone();
            const originalEmissive = hintCube.material.emissive.clone();
            const originalIntensity = hintCube.material.emissiveIntensity;

            const blinkInterval = setInterval(() => {
                if (blinkCount >= 6) {
                    // 元に戻す
                    hintCube.material.color.copy(originalColor);
                    hintCube.material.emissive.copy(originalEmissive);
                    hintCube.material.emissiveIntensity = originalIntensity;
                    hintBlinking = false;
                    clearInterval(blinkInterval);
                    return;
                }

                if (blinkCount % 2 === 0) {
                    // 黄色に光る
                    hintCube.material.color.setHex(0xffff00);
                    hintCube.material.emissive.setHex(0xffff00);
                    hintCube.material.emissiveIntensity = 1.0;
                } else {
                    // 元の色に戻す
                    hintCube.material.color.copy(originalColor);
                    hintCube.material.emissive.copy(originalEmissive);
                    hintCube.material.emissiveIntensity = originalIntensity;
                }

                blinkCount++;
            }, 200);
        }

        // シャッフル（ランダムにクリック、アニメーションなし）
        function shuffle(count) {
            for (let i = 0; i < count; i++) {
                const randomIndex = Math.floor(Math.random() * cubes.length);
                const randomCube = cubes[randomIndex];
                const { gridX, gridY, gridZ } = randomCube.userData;

                // 自分自身と隣接する6方向を反転
                const directions = [
                    [0, 0, 0],
                    [1, 0, 0],
                    [-1, 0, 0],
                    [0, 1, 0],
                    [0, -1, 0],
                    [0, 0, 1],
                    [0, 0, -1]
                ];

                directions.forEach(([dx, dy, dz]) => {
                    const nx = gridX + dx;
                    const ny = gridY + dy;
                    const nz = gridZ + dz;

                    if (nx >= 0 && nx < gridSize &&
                        ny >= 0 && ny < gridSize &&
                        nz >= 0 && nz < gridSize) {
                        toggleCube(nx, ny, nz);
                    }
                });
            }
            // 即座にビジュアルを更新
            cubes.forEach(updateCubeVisualInstant);
        }

        // 初期化：保存データがあれば復元、なければ新規開始
        const savedGame = loadGame();
        if (savedGame) {
            currentStage = savedGame.currentStage;
            initStage(currentStage, savedGame);
        } else {
            initStage(currentStage);
        }

        // NEW GAMEボタン（ステージ1から再開始）
        document.getElementById('newgame-btn').addEventListener('click', () => {
            if (confirm('最初からやり直しますか？')) {
                clearSave();
                currentStage = 1;
                initStage(currentStage);
            }
        });

        // リセットボタン（ステージの初期状態に戻す）
        document.getElementById('reset-btn').addEventListener('click', () => {
            // 保存した初期状態に戻す
            cubeStates = {...initialCubeStates};
            // ビジュアルを更新
            cubes.forEach(updateCubeVisualInstant);
            // クリア状態をリセット
            document.getElementById('clear-message').classList.remove('show');
            document.getElementById('next-stage-hint').classList.remove('show');
            isCleared = false;
            // 保存
            saveGame();
        });

        // ヒントボタン
        document.getElementById('hint-btn').addEventListener('click', () => {
            showHint();
        });

        // マウス・タッチ操作
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let clickStartPosition = { x: 0, y: 0 };

        // 座標取得のヘルパー関数
        function getPointerPosition(event) {
            if (event.touches && event.touches.length > 0) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        // ポインター開始（マウス・タッチ共通）
        function onPointerStart(event) {
            event.preventDefault();
            const pos = getPointerPosition(event);
            isDragging = true;
            previousMousePosition = { x: pos.x, y: pos.y };
            clickStartPosition = { x: pos.x, y: pos.y };
        }

        // ポインター移動（マウス・タッチ共通）
        function onPointerMove(event) {
            if (!isDragging) return;
            event.preventDefault();

            const pos = getPointerPosition(event);
            const deltaMove = {
                x: pos.x - previousMousePosition.x,
                y: pos.y - previousMousePosition.y
            };

            pivot.rotation.y += deltaMove.x * 0.01;
            pivot.rotation.x += deltaMove.y * 0.01;

            previousMousePosition = { x: pos.x, y: pos.y };
        }

        // ポインター終了（マウス・タッチ共通）
        function onPointerEnd(event) {
            isDragging = false;

            // タッチ終了時の座標を取得
            let endPos;
            if (event.changedTouches && event.changedTouches.length > 0) {
                endPos = { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };
            } else {
                endPos = { x: event.clientX, y: event.clientY };
            }

            // クリック判定（ドラッグしていない場合のみ）
            const moveDistance = Math.sqrt(
                Math.pow(endPos.x - clickStartPosition.x, 2) +
                Math.pow(endPos.y - clickStartPosition.y, 2)
            );

            if (moveDistance < 10) {
                // クリア状態なら次のステージへ
                if (isCleared) {
                    nextStage();
                    return;
                }

                mouse.x = (endPos.x / window.innerWidth) * 2 - 1;
                mouse.y = -(endPos.y / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);

                if (intersects.length > 0) {
                    handleClick(intersects[0].object);
                }
            }
        }

        // マウスイベント
        renderer.domElement.addEventListener('mousedown', onPointerStart);
        renderer.domElement.addEventListener('mousemove', onPointerMove);
        renderer.domElement.addEventListener('mouseup', onPointerEnd);

        // タッチイベント
        renderer.domElement.addEventListener('touchstart', onPointerStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onPointerEnd, { passive: false });

        // ホイールでズーム
        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);

            // ズーム制限
            const distance = camera.position.length();
            const minDistance = gridSize * 1.5;
            const maxDistance = gridSize * 5;
            if (distance < minDistance) {
                camera.position.setLength(minDistance);
            } else if (distance > maxDistance) {
                camera.position.setLength(maxDistance);
            }
        }, { passive: false });

        // ウィンドウリサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            updateAnimations(); // 色のアニメーションを更新
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
