<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÁßªÂãï„Åô„Çã‰∏âÁõÆ‰∏¶„Åπ - 3x3 Slide Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Segoe UI', 'Hiragino Sans', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 25%, #0d1b2a 50%, #1b0a28 75%, #0a0a1a 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .back-link {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #88ccff;
            text-decoration: none;
            font-size: 14px;
            padding: 8px 12px;
            border: 1px solid #88ccff;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(136, 204, 255, 0.2);
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
        }

        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .turn-indicator {
            padding: 8px 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .turn-indicator.player-turn {
            background: rgba(0, 150, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
        }

        .turn-indicator.ai-turn {
            background: rgba(255, 100, 100, 0.3);
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.5);
        }

        .timer {
            font-size: 1.3rem;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        .timer.warning {
            color: #ff6b6b;
            animation: pulse 0.5s infinite;
        }

        .timer.disabled {
            color: #666;
            font-size: 1rem;
        }

        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #88ccff;
            cursor: pointer;
            user-select: none;
            margin-bottom: 10px;
        }

        .mode-toggle input {
            display: none;
        }

        .toggle-switch {
            width: 40px;
            height: 22px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 11px;
            position: relative;
            transition: all 0.3s;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .mode-toggle input:checked + .toggle-switch {
            background: rgba(0, 200, 100, 0.5);
        }

        .mode-toggle input:checked + .toggle-switch::after {
            left: 20px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .phase-indicator {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .board-container {
            position: relative;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .cell:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.2);
        }

        .cell.player {
            color: #00bfff;
            text-shadow: 0 0 15px rgba(0, 191, 255, 0.8);
        }

        .cell.ai {
            color: #ff6b6b;
            text-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
        }

        .cell.selected {
            animation: glow 0.8s infinite alternate;
            background: rgba(0, 191, 255, 0.3);
        }

        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(0, 191, 255, 0.5); }
            to { box-shadow: 0 0 25px rgba(0, 191, 255, 0.9); }
        }

        .cell.movable {
            background: rgba(0, 255, 0, 0.2);
            animation: movable-pulse 1s infinite;
        }

        @keyframes movable-pulse {
            0%, 100% { background: rgba(0, 255, 0, 0.15); }
            50% { background: rgba(0, 255, 0, 0.3); }
        }

        .cell.reach-warning {
            animation: reach-warning 0.5s infinite;
        }

        @keyframes reach-warning {
            0%, 100% { box-shadow: inset 0 0 20px rgba(255, 200, 0, 0.5); }
            50% { box-shadow: inset 0 0 30px rgba(255, 200, 0, 0.8); }
        }

        .cell.disabled {
            cursor: default;
            opacity: 0.7;
        }

        .winning-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            height: 6px;
            border-radius: 3px;
            animation: winning-flash 0.5s infinite alternate;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes winning-flash {
            from { opacity: 0.7; box-shadow: 0 0 10px #fff; }
            to { opacity: 1; box-shadow: 0 0 25px #fff; }
        }

        .message {
            margin-top: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            min-height: 40px;
        }

        .message.win {
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            animation: victory 0.5s ease-out;
        }

        .message.lose {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
        }

        @keyframes victory {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .buttons {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-new {
            background: rgba(255, 200, 100, 0.2);
            border-color: #ffcc66;
            color: #ffcc66;
            text-shadow: 0 0 10px #ffcc66;
        }

        .btn-new:hover {
            background: rgba(255, 200, 100, 0.4);
        }

        .score-board {
            margin-top: 15px;
            display: flex;
            gap: 30px;
            font-size: 1rem;
        }

        .score {
            padding: 5px 15px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }

        .score.player-score {
            border-left: 3px solid #00bfff;
        }

        .score.ai-score {
            border-left: 3px solid #ff6b6b;
        }

        /* ÁîªÈù¢„Çµ„Ç§„Ç∫„Å´Âøú„Åò„ÅüË™øÊï¥ */
        @media (max-width: 400px) {
            .cell {
                width: 75px;
                height: 75px;
                font-size: 2.5rem;
            }

            h1 {
                font-size: 1.2rem;
            }
        }

        @media (min-height: 800px) {
            .cell {
                width: 100px;
                height: 100px;
            }
        }

        /* ÂãùÂà©ÊôÇ„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            pointer-events: none;
            animation: confetti-fall 3s linear forwards;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>ÁßªÂãï„Åô„Çã‰∏âÁõÆ‰∏¶„Åπ</h1>

    <div class="game-info">
        <div class="turn-indicator" id="turnIndicator">„ÅÇ„Å™„Åü„ÅÆÁï™</div>
        <div class="timer" id="timer">5</div>
    </div>

    <label class="mode-toggle">
        <input type="checkbox" id="timerToggle" checked>
        <span class="toggle-switch"></span>
        <span>Âà∂ÈôêÊôÇÈñì„ÅÇ„Çä</span>
    </label>

    <div class="phase-indicator" id="phaseIndicator">„Éï„Çß„Éº„Ç∫1: Èßí„ÇíÈÖçÁΩÆ („ÅÇ„Å™„Åü: 0/3)</div>

    <div class="board-container">
        <div class="board" id="board"></div>
    </div>

    <div class="message" id="message"></div>

    <div class="buttons">
        <button class="btn btn-new" id="restartBtn">NEW GAME</button>
    </div>

    <div class="score-board">
        <div class="score player-score">„ÅÇ„Å™„Åü: <span id="playerScore">0</span></div>
        <div class="score ai-score">AI: <span id="aiScore">0</span></div>
    </div>

    <script>
        // „Ç≤„Éº„É†Áä∂ÊÖã
        const EMPTY = null;
        const PLAYER = 'player';
        const AI = 'ai';

        let board = Array(9).fill(EMPTY);
        let currentTurn = PLAYER;
        let phase = 1; // 1: ÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫, 2: ÁßªÂãï„Éï„Çß„Éº„Ç∫
        let playerPieces = 0;
        let aiPieces = 0;
        let selectedCell = null;
        let gameOver = false;
        let timer = 5;
        let timerInterval = null;
        let scores = { player: 0, ai: 0 };
        let timerEnabled = true;

        // DOMË¶ÅÁ¥†
        const boardEl = document.getElementById('board');
        const turnIndicatorEl = document.getElementById('turnIndicator');
        const timerEl = document.getElementById('timer');
        const phaseIndicatorEl = document.getElementById('phaseIndicator');
        const messageEl = document.getElementById('message');
        const restartBtn = document.getElementById('restartBtn');
        const playerScoreEl = document.getElementById('playerScore');
        const aiScoreEl = document.getElementById('aiScore');
        const timerToggleEl = document.getElementById('timerToggle');

        // ÂãùÂà©„Éë„Çø„Éº„É≥
        const WIN_PATTERNS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Ê®™
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Á∏¶
            [0, 4, 8], [2, 4, 6]             // Êñú„ÇÅ
        ];

        // Èö£Êé•„Çª„É´Ôºà‰∏ä‰∏ãÂ∑¶Âè≥Êñú„ÇÅÔºâ
        const ADJACENTS = {
            0: [1, 3, 4],
            1: [0, 2, 3, 4, 5],
            2: [1, 4, 5],
            3: [0, 1, 4, 6, 7],
            4: [0, 1, 2, 3, 5, 6, 7, 8],
            5: [1, 2, 4, 7, 8],
            6: [3, 4, 7],
            7: [3, 4, 5, 6, 8],
            8: [4, 5, 7]
        };

        // „Éú„Éº„ÉâÂàùÊúüÂåñ
        function initBoard() {
            boardEl.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.addEventListener('click', () => handleCellClick(i));
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleCellClick(i);
                }, { passive: false });
                boardEl.appendChild(cell);
            }
        }

        // „Çª„É´„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        function handleCellClick(index) {
            if (gameOver || currentTurn !== PLAYER) return;

            if (phase === 1) {
                // ÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫
                if (board[index] === EMPTY) {
                    placePiece(index, PLAYER);
                    playerPieces++;
                    checkPhaseTransition();
                    if (!gameOver && phase === 1) {
                        endTurn();
                    } else if (!gameOver && phase === 2) {
                        endTurn();
                    }
                }
            } else {
                // ÁßªÂãï„Éï„Çß„Éº„Ç∫
                if (selectedCell === null) {
                    // Èßí„ÇíÈÅ∏Êäû
                    if (board[index] === PLAYER) {
                        selectCell(index);
                    }
                } else {
                    if (index === selectedCell) {
                        // Âêå„Åò„Çª„É´„Çí„Çø„ÉÉ„Éó„ÅßÈÅ∏ÊäûËß£Èô§
                        deselectCell();
                    } else if (board[index] === PLAYER) {
                        // Âà•„ÅÆËá™ÂàÜ„ÅÆÈßí„ÇíÈÅ∏Êäû
                        deselectCell();
                        selectCell(index);
                    } else if (board[index] === EMPTY && isAdjacent(selectedCell, index)) {
                        // ÁßªÂãïÂÆüË°å
                        movePiece(selectedCell, index);
                        deselectCell();
                        if (!gameOver) {
                            endTurn();
                        }
                    }
                }
            }
        }

        // Èßí„ÇíÈÖçÁΩÆ
        function placePiece(index, owner) {
            board[index] = owner;
            updateCell(index);
            checkWin(owner);
        }

        // Èßí„ÇíÁßªÂãï
        function movePiece(from, to) {
            board[to] = board[from];
            board[from] = EMPTY;
            updateCell(from);
            updateCell(to);
            checkWin(board[to]);
        }

        // „Çª„É´„ÇíÈÅ∏Êäû
        function selectCell(index) {
            selectedCell = index;
            const cells = boardEl.children;
            cells[index].classList.add('selected');

            // ÁßªÂãïÂèØËÉΩ„Å™„Çª„É´„Çí„Éè„Ç§„É©„Ç§„Éà
            ADJACENTS[index].forEach(adj => {
                if (board[adj] === EMPTY) {
                    cells[adj].classList.add('movable');
                }
            });
        }

        // ÈÅ∏ÊäûËß£Èô§
        function deselectCell() {
            if (selectedCell !== null) {
                const cells = boardEl.children;
                cells[selectedCell].classList.remove('selected');
                for (let i = 0; i < 9; i++) {
                    cells[i].classList.remove('movable');
                }
                selectedCell = null;
            }
        }

        // Èö£Êé•Âà§ÂÆö
        function isAdjacent(from, to) {
            return ADJACENTS[from].includes(to);
        }

        // „Çª„É´Ë°®Á§∫Êõ¥Êñ∞
        function updateCell(index) {
            const cell = boardEl.children[index];
            cell.className = 'cell';
            if (board[index] === PLAYER) {
                cell.textContent = '‚óØ';
                cell.classList.add('player');
            } else if (board[index] === AI) {
                cell.textContent = '‚úñ';
                cell.classList.add('ai');
            } else {
                cell.textContent = '';
            }
        }

        // „Éï„Çß„Éº„Ç∫ÈÅ∑Áßª„ÉÅ„Çß„ÉÉ„ÇØ
        function checkPhaseTransition() {
            if (phase === 1 && playerPieces === 3 && aiPieces === 3) {
                phase = 2;
                updatePhaseIndicator();
            }
        }

        // ÂãùÂà©Âà§ÂÆö
        function checkWin(owner) {
            for (const pattern of WIN_PATTERNS) {
                if (pattern.every(i => board[i] === owner)) {
                    gameOver = true;
                    stopTimer();
                    highlightWinningLine(pattern);
                    if (owner === PLAYER) {
                        messageEl.textContent = 'üéâ „ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ';
                        messageEl.className = 'message win';
                        scores.player++;
                        playerScoreEl.textContent = scores.player;
                        createConfetti();
                    } else {
                        messageEl.textContent = 'üò¢ AI„ÅÆÂãù„Å°...';
                        messageEl.className = 'message lose';
                        scores.ai++;
                        aiScoreEl.textContent = scores.ai;
                    }
                    return true;
                }
            }
            return false;
        }

        // ÂãùÂà©„É©„Ç§„É≥Ë°®Á§∫
        function highlightWinningLine(pattern) {
            const cells = boardEl.children;
            pattern.forEach(i => {
                cells[i].classList.add('reach-warning');
            });
        }

        // „É™„Éº„ÉÅË≠¶Âëä
        function checkReach() {
            const cells = boardEl.children;
            // ÂÖ®„Çª„É´„ÅÆ„É™„Éº„ÉÅË≠¶Âëä„Çí„ÇØ„É™„Ç¢
            for (let i = 0; i < 9; i++) {
                cells[i].classList.remove('reach-warning');
            }

            if (gameOver) return;

            // „É™„Éº„ÉÅ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            for (const pattern of WIN_PATTERNS) {
                const values = pattern.map(i => board[i]);
                const playerCount = values.filter(v => v === PLAYER).length;
                const aiCount = values.filter(v => v === AI).length;
                const emptyCount = values.filter(v => v === EMPTY).length;

                if ((playerCount === 2 && emptyCount === 1) || (aiCount === 2 && emptyCount === 1)) {
                    pattern.forEach(i => {
                        if (board[i] !== EMPTY) {
                            cells[i].classList.add('reach-warning');
                        }
                    });
                }
            }
        }

        // „Çø„Éº„É≥ÁµÇ‰∫Ü
        function endTurn() {
            deselectCell();
            checkReach();

            if (gameOver) return;

            currentTurn = currentTurn === PLAYER ? AI : PLAYER;
            updateTurnIndicator();
            updatePhaseIndicator();
            resetTimer();

            if (currentTurn === AI) {
                setTimeout(aiTurn, 500);
            }
        }

        // AI„ÅÆ„Çø„Éº„É≥
        function aiTurn() {
            if (gameOver || currentTurn !== AI) return;

            stopTimer();

            if (phase === 1) {
                // ÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫
                const move = findBestPlacement();
                if (move !== -1) {
                    placePiece(move, AI);
                    aiPieces++;
                    checkPhaseTransition();
                }
            } else {
                // ÁßªÂãï„Éï„Çß„Éº„Ç∫
                const move = findBestMove();
                if (move) {
                    movePiece(move.from, move.to);
                }
            }

            if (!gameOver) {
                endTurn();
            }
        }

        // AI: Èáç„Åø‰ªò„Åç„É©„É≥„ÉÄ„É†ÈÅ∏ÊäûÔºàÊ°à4Ôºâ
        function weightedRandomSelect(candidates) {
            if (candidates.length === 0) return null;
            if (candidates.length === 1) return candidates[0];

            // „Çπ„Ç≥„Ç¢È†Ü„Å´„ÇΩ„Éº„ÉàÔºàÈôçÈ†ÜÔºâ
            candidates.sort((a, b) => b.score - a.score);

            const topScore = candidates[0].score;
            const topTier = candidates.filter(c => c.score === topScore);

            // ÊúÄÈ´ò„Çπ„Ç≥„Ç¢„ÅÆÊâã„ÅåË§áÊï∞„ÅÇ„Çå„Å∞„Åù„ÅÆ‰∏≠„Åã„Çâ„É©„É≥„ÉÄ„É†ÔºàÊ°à1Ôºâ
            if (topTier.length > 1) {
                return topTier[Math.floor(Math.random() * topTier.length)];
            }

            // 80%„ÅßÊúÄÂñÑÊâã„ÄÅ20%„ÅßÊ¨°ÂñÑÊâã‰ª•Èôç„Åã„ÇâÈÅ∏ÊäûÔºàÊ°à4Ôºâ
            if (Math.random() < 0.8 || candidates.length === 1) {
                return candidates[0];
            } else {
                // Ê¨°ÂñÑÊâã‰ª•Èôç„Åã„Çâ„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                const others = candidates.slice(1);
                return others[Math.floor(Math.random() * others.length)];
            }
        }

        // AI: ÊúÄÈÅ©„Å™ÈÖçÁΩÆ‰ΩçÁΩÆ„ÇíÊé¢„Åô
        function findBestPlacement() {
            const emptyCells = [];
            for (let i = 0; i < 9; i++) {
                if (board[i] === EMPTY) emptyCells.push(i);
            }

            // ÂêÑ„Çª„É´„Å´„Çπ„Ç≥„Ç¢„Çí‰ªò„Åë„Çã
            const candidates = [];

            for (const cell of emptyCells) {
                let score = 0;

                // Âãù„Å¶„Çã‰ΩçÁΩÆ„ÅØÊúÄÂÑ™ÂÖàÔºà„Çπ„Ç≥„Ç¢1000Ôºâ
                board[cell] = AI;
                if (checkWinWithoutEffect(AI)) {
                    board[cell] = EMPTY;
                    return cell; // Âãù„Å¶„Çã„Å™„ÇâÂç≥Ê±∫
                }
                board[cell] = EMPTY;

                // Áõ∏Êâã„ÅÆÂãùÂà©„ÇíÈòªÊ≠¢Ôºà„Çπ„Ç≥„Ç¢100Ôºâ
                board[cell] = PLAYER;
                if (checkWinWithoutEffect(PLAYER)) {
                    score += 100;
                }
                board[cell] = EMPTY;

                // „É™„Éº„ÉÅ„Çí‰Ωú„Çå„Çã‰ΩçÁΩÆÔºà„Çπ„Ç≥„Ç¢30Ôºâ
                board[cell] = AI;
                if (hasReach(AI)) {
                    score += 30;
                }
                board[cell] = EMPTY;

                // ‰∏≠Â§ÆÔºà„Çπ„Ç≥„Ç¢20Ôºâ
                if (cell === 4) score += 20;

                // ËßíÔºà„Çπ„Ç≥„Ç¢10Ôºâ
                if ([0, 2, 6, 8].includes(cell)) score += 10;

                // Âü∫Êú¨„Çπ„Ç≥„Ç¢Ôºà„É©„É≥„ÉÄ„É†Ë¶ÅÁ¥†Ôºâ
                score += Math.random() * 5;

                candidates.push({ cell, score });
            }

            const selected = weightedRandomSelect(candidates);
            return selected ? selected.cell : emptyCells[0];
        }

        // AI: ÊúÄÈÅ©„Å™ÁßªÂãï„ÇíÊé¢„Åô
        function findBestMove() {
            const aiCells = [];
            for (let i = 0; i < 9; i++) {
                if (board[i] === AI) aiCells.push(i);
            }

            // ÂÖ®„Å¶„ÅÆÊúâÂäπ„Å™ÁßªÂãï„ÇíÂèéÈõÜ„Åó„Å¶„Çπ„Ç≥„Ç¢„Çí‰ªò„Åë„Çã
            const candidates = [];

            for (const from of aiCells) {
                for (const to of ADJACENTS[from]) {
                    if (board[to] === EMPTY) {
                        let score = 0;

                        // Âãù„Å¶„ÇãÁßªÂãï„ÅØÂç≥Ê±∫Ôºà„Çπ„Ç≥„Ç¢1000Ôºâ
                        board[to] = AI;
                        board[from] = EMPTY;
                        if (checkWinWithoutEffect(AI)) {
                            board[from] = AI;
                            board[to] = EMPTY;
                            return { from, to }; // Âãù„Å¶„Çã„Å™„ÇâÂç≥Ê±∫
                        }

                        // „É™„Éº„ÉÅ„Çí‰Ωú„Çå„ÇãÔºà„Çπ„Ç≥„Ç¢50Ôºâ
                        if (hasReach(AI)) {
                            score += 50;
                        }

                        // „ÉÄ„Éñ„É´„É™„Éº„ÉÅÔºà2„Å§‰ª•‰∏ä„ÅÆ„É™„Éº„ÉÅÔºâ„Çí‰Ωú„Çå„ÇãÔºà„Çπ„Ç≥„Ç¢80Ôºâ
                        let reachCount = 0;
                        for (const pattern of WIN_PATTERNS) {
                            const values = pattern.map(i => board[i]);
                            const aiCount = values.filter(v => v === AI).length;
                            const emptyCount = values.filter(v => v === EMPTY).length;
                            if (aiCount === 2 && emptyCount === 1) reachCount++;
                        }
                        if (reachCount >= 2) score += 80;

                        board[from] = AI;
                        board[to] = EMPTY;

                        // Áõ∏Êâã„ÅÆÂãùÂà©„ÇíÈòªÊ≠¢Ôºà„Çπ„Ç≥„Ç¢100Ôºâ
                        const playerCells = [];
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === PLAYER) playerCells.push(i);
                        }
                        for (const pFrom of playerCells) {
                            for (const pTo of ADJACENTS[pFrom]) {
                                if (board[pTo] === EMPTY) {
                                    board[pTo] = PLAYER;
                                    board[pFrom] = EMPTY;
                                    if (checkWinWithoutEffect(PLAYER)) {
                                        // to„ÅåpTo„Å®Âêå„Åò‰ΩçÁΩÆ„Å™„ÇâÈòªÊ≠¢„Åß„Åç„Çã
                                        if (to === pTo) {
                                            score += 100;
                                        }
                                    }
                                    board[pFrom] = PLAYER;
                                    board[pTo] = EMPTY;
                                }
                            }
                        }

                        // ‰∏≠Â§Æ„Å∏„ÅÆÁßªÂãïÔºà„Çπ„Ç≥„Ç¢25Ôºâ
                        if (to === 4) score += 25;

                        // Ëßí„Å∏„ÅÆÁßªÂãïÔºà„Çπ„Ç≥„Ç¢10Ôºâ
                        if ([0, 2, 6, 8].includes(to)) score += 10;

                        // ‰∏≠Â§Æ„Åã„ÇâÈõ¢„Çå„ÇãÁßªÂãï„ÅØ„Éû„Ç§„Éä„Çπ
                        if (from === 4) score -= 15;

                        // Âü∫Êú¨„Çπ„Ç≥„Ç¢Ôºà„É©„É≥„ÉÄ„É†Ë¶ÅÁ¥†Ôºâ
                        score += Math.random() * 5;

                        candidates.push({ from, to, score });
                    }
                }
            }

            const selected = weightedRandomSelect(candidates);
            return selected ? { from: selected.from, to: selected.to } : null;
        }

        // ÂãùÂà©Âà§ÂÆöÔºàÂâØ‰ΩúÁî®„Å™„ÅóÔºâ
        function checkWinWithoutEffect(owner) {
            for (const pattern of WIN_PATTERNS) {
                if (pattern.every(i => board[i] === owner)) {
                    return true;
                }
            }
            return false;
        }

        // „É™„Éº„ÉÅÂà§ÂÆö
        function hasReach(owner) {
            for (const pattern of WIN_PATTERNS) {
                const values = pattern.map(i => board[i]);
                const ownerCount = values.filter(v => v === owner).length;
                const emptyCount = values.filter(v => v === EMPTY).length;
                if (ownerCount === 2 && emptyCount === 1) {
                    return true;
                }
            }
            return false;
        }

        // „Çø„Ç§„Éû„ÉºÈñ¢ÈÄ£
        function resetTimer() {
            stopTimer();

            if (!timerEnabled) {
                timerEl.textContent = '‚àû';
                timerEl.classList.add('disabled');
                timerEl.classList.remove('warning');
                return;
            }

            timer = 5;
            timerEl.textContent = timer;
            timerEl.classList.remove('warning', 'disabled');

            timerInterval = setInterval(() => {
                timer--;
                timerEl.textContent = timer;

                if (timer <= 2) {
                    timerEl.classList.add('warning');
                }

                if (timer <= 0) {
                    timeOut();
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function timeOut() {
            stopTimer();

            if (gameOver) return;

            if (currentTurn === PLAYER) {
                // „Éó„É¨„Ç§„É§„Éº„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà: „É©„É≥„ÉÄ„É†Ë°åÂãï
                if (phase === 1) {
                    const emptyCells = [];
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === EMPTY) emptyCells.push(i);
                    }
                    if (emptyCells.length > 0) {
                        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        placePiece(randomCell, PLAYER);
                        playerPieces++;
                        checkPhaseTransition();
                    }
                } else {
                    // „É©„É≥„ÉÄ„É†ÁßªÂãï
                    const playerCells = [];
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === PLAYER) playerCells.push(i);
                    }
                    const validMoves = [];
                    for (const from of playerCells) {
                        for (const to of ADJACENTS[from]) {
                            if (board[to] === EMPTY) {
                                validMoves.push({ from, to });
                            }
                        }
                    }
                    if (validMoves.length > 0) {
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        movePiece(move.from, move.to);
                    }
                }

                if (!gameOver) {
                    endTurn();
                }
            }
        }

        // UIÊõ¥Êñ∞
        function updateTurnIndicator() {
            if (currentTurn === PLAYER) {
                turnIndicatorEl.textContent = '„ÅÇ„Å™„Åü„ÅÆÁï™';
                turnIndicatorEl.className = 'turn-indicator player-turn';
            } else {
                turnIndicatorEl.textContent = 'AI„ÅÆÁï™';
                turnIndicatorEl.className = 'turn-indicator ai-turn';
            }
        }

        function updatePhaseIndicator() {
            if (phase === 1) {
                phaseIndicatorEl.textContent = `„Éï„Çß„Éº„Ç∫1: Èßí„ÇíÈÖçÁΩÆ („ÅÇ„Å™„Åü: ${playerPieces}/3, AI: ${aiPieces}/3)`;
            } else {
                phaseIndicatorEl.textContent = '„Éï„Çß„Éº„Ç∫2: Èßí„ÇíÁßªÂãï';
            }
        }

        // Á¥ôÂêπÈõ™„Ç®„Éï„Çß„ÇØ„Éà
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96e6a1', '#dda0dd', '#f7dc6f'];
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 4000);
                }, i * 50);
            }
        }

        // „Ç≤„Éº„É†„É™„Çª„ÉÉ„Éà
        function resetGame() {
            board = Array(9).fill(EMPTY);
            currentTurn = PLAYER;
            phase = 1;
            playerPieces = 0;
            aiPieces = 0;
            selectedCell = null;
            gameOver = false;

            stopTimer();

            for (let i = 0; i < 9; i++) {
                updateCell(i);
                boardEl.children[i].classList.remove('reach-warning', 'selected', 'movable');
            }

            messageEl.textContent = '';
            messageEl.className = 'message';

            updateTurnIndicator();
            updatePhaseIndicator();
            resetTimer();
        }

        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        restartBtn.addEventListener('click', resetGame);

        timerToggleEl.addEventListener('change', () => {
            timerEnabled = timerToggleEl.checked;
            timerToggleEl.parentElement.querySelector('span:last-child').textContent =
                timerEnabled ? 'Âà∂ÈôêÊôÇÈñì„ÅÇ„Çä' : 'Âà∂ÈôêÊôÇÈñì„Å™„Åó';
            resetTimer();
        });

        // ÂàùÊúüÂåñ
        initBoard();
        resetTimer();
    </script>
</body>
</html>
